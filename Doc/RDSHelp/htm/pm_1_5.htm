<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;1.5. Статические переменные блоков, входы и выходы</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="pm_index.htm">Руководство программиста</a></p>
<div class="level"><p><a href="pm_index.htm#light_htm:pm_1">Глава 1. Устройство RDS</a></p>
<div class="level"><p>&sect;1.5. Статические переменные блоков, входы и выходы</p>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="pm_1_4.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="pm_1_6.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="pm_index.htm#light_htm:pm_1_5">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Руководство программиста</h1>
<h2 class="off">Глава 1. Устройство RDS</h2>
<h3>&sect;1.5. Статические переменные блоков, входы и выходы</h3>
<p class="abstract">Описывается структура и возможные типы статических переменных блока, то есть тех переменных, которые обычно существуют все время жизни блока и не создаются и не уничтожаются в процессе работы схемы. Входы и выходы блока, к которым могут присоединяться связи, всегда являются статическими переменными. Описывается способ формирования строки типа, используемой для проверки правильности структуры переменных.</p>


<p><span class="term">Статические переменные</span>, в основном, служат для подключения связей к блоку, а также для
хранения параметров, которые создатель модели блока решил не размещать в
<a href="pm_1_4.htm#ref8" title="Личная область данных блока">личной области данных</a>. Для простых блоков
они, чаще всего, задаются при создании блока и указании его модели, после чего их структура уже не изменяется.
<a href="um_2_9_2.htm" title="&sect;2.9.2. Редактирование списка переменных блока">Редактор переменных</a>
(<a href="#pic2" title="Редактор переменных">рис.&nbsp;9</a>)
вызывается кнопкой &laquo;<span class="menu">Изменить</span>&raquo; вкладки &laquo;<span class="menu">Переменные</span>&raquo; окна параметров блока
(<a href="#pic1" title="Параметры блока &ndash; переменные">рис.&nbsp;8</a>).
В памяти эти переменные расположены друг за другом, поэтому, зная указатель на область переменных и размер каждой из
них в памяти, модель может обращаться к различным переменным по фиксированным смещениям. Для простых переменных
(целые и вещественные числа, логические значения) в памяти хранятся сами значения, а для сложных, размер которых может
изменяться (массивы, матрицы, переменные произвольного типа), в памяти хранится указатель на область памяти,
занимаемой сложной переменной.
<span id="ref1">Таким образом</span>, при наличии у блока сложных переменных, область
переменных представляет
собой дерево, поэтому набор статических переменных блока обычно называется
<span class="term" id="light_ref1">деревом переменных</span>.</p>

<div class="pic"><div class="container" id="pic1">
<img src="../img/BlockPref_Vars.png" width="534" height="349" alt="Параметры блока &ndash; переменные" />
<p id="light_pic1">Рис.&nbsp;8. Параметры блока &ndash; переменные</p>
</div></div>


<div class="pic"><div class="container" id="pic2">
<img src="../img/VarEditor.png" width="670" height="394" alt="Редактор переменных" />
<p id="light_pic2">Рис.&nbsp;9. Редактор переменных</p>
</div></div>


<p>Каждая статическая переменная имеет имя, уникальное в данном блоке &ndash; оно задается в колонке
&laquo;<span class="menu">Имя</span>&raquo; редактора (см. <a href="#pic2" title="Редактор переменных">рис.&nbsp;9</a>). Для того, чтобы имена
переменных блоков можно было использовать в программах их моделей, они должны подчиняться правилам, принятым
в большинстве языков программирования: имя переменной должно содержать только буквы латинского алфавита, цифры
и знак подчеркивания, и при этом оно не должно начинаться с цифры. Имена переменных чувствительны к регистру,
поэтому, например, &laquo;<span class="rdsvar">Start</span>&raquo; и &laquo;<span class="rdsvar">start</span>&raquo; будут считаться разными переменными.</p>

<p><span id="ref2">Переменные</span> в RDS могут быть одного из следующих
<span id="light_ref2">типов</span>,
выбираемых в колонке &laquo;<span class="menu">Тип</span>&raquo;
редактора переменных:</p>

<dl>
  <dt><span class="term"><span id="light_ref3">Сигнал</span></span>
  <span id="ref4">(размер</span>
  &ndash; 1 байт)</dt>
  <dd>Сигналы служат для передачи информации о наступлении какого-либо события, и могут
  принимать два значения: 1 (событие наступило) и 0 (событие не наступило). Сигнал передается по связи только в
  том случае, если значение выхода блока, от которого отходит эта связь, равно 1. После передачи значение
  выхода сбрасывается в 0, таким образом блокируется повторная передача информации о том же самом событии. Блок,
  обнаруживший на сигнальном входе единицу, должен сам сбросить ее в 0, чтобы подготовится к приему информации о
  следующем событии. <span id="light_ref4">Первая переменная простого блока</span>
  всегда является сигнальным входом (обычно она называется
  &laquo;<span class="rdsvar">Start</span>&raquo;), появление единицы в котором в
  <a href="pm_1_3.htm#ref3" title="Режим расчета">режиме расчета</a> приводит к запуску модели блока, а вторая
  переменная &ndash; сигнальным выходом (&laquo;<span class="rdsvar">Ready</span>&raquo;), единица в котором активизирует передачу данных
  с выходов блока.</dd>

  <dt><span class="term"><span id="light_ref5">Логический</span></span>
  (размер &ndash; 1 байт)</dt>
  <dd>Логические переменные могут принимать одно из двух значений: 0 (ложь) и 1 (истина).</dd>

  <dt><span class="term"><span id="light_ref6">char</span></span>
  (размер &ndash; 1 байт)</dt>
  <dd>Целая однобайтовая переменная, предназначенная для хранения небольших целых чисел
  (диапазон значений: &minus;128&thinsp;&hellip;&thinsp;127) или кодов символов,
  полностью эквивалентная типу <span class="cpp">signed char</span>
  в C++. Этот тип используется в блоках редко,
  в основном, для совместимости со старыми моделями. Для работы с целыми числами чаще
  всего используется тип <span class="term">int</span>.</dd>

  <dt><span class="term"><span id="light_ref7">short</span></span>
  (размер &ndash; 2 байта)</dt>
  <dd>Целая двухбайтовая переменная с диапазоном значений &minus;32768&thinsp;&hellip;&thinsp;32767, эквивалентная
  типу <span class="cpp">short int</span> в C++. В настоящее время используется редко.</dd>

  <dt><span class="term"><span id="light_ref8">int</span></span>
  (размер &ndash; 4 байта)</dt>
  <dd>Целая четырехбайтовая переменная с диапазоном значений &minus;2147483648&thinsp;&hellip;&thinsp;2147483647.
  Основной тип для работы с целыми числами в RDS. Эквивалентен тридцатидвухбитному типу
  <span class="cpp">int</span> в C++.</dd>

  <dt><span class="term"><span id="light_ref9">float</span></span>
  (размер &ndash; 4 байта)</dt>
  <dd>Вещественная
  переменная одинарной точности с диапазоном значений модуля числа
  1.18&times;10<sup>&minus;38</sup>&thinsp;&hellip;&thinsp;3.40&times;10<sup>38</sup>. Этот тип эквивалентен
  одноименному типу в C++. Используется редко.</dd>

  <dt><span class="term"><span id="light_ref10">double</span></span>
  (размер &ndash; 8 байтов).</dt>
  <dd> Вещественная переменная двойной точности с диапазоном значений модуля числа
  2.23&times;10<sup>&minus;308</sup>&thinsp;&hellip;&thinsp;1.79&times;10<sup>308</sup>. Этот тип
  эквивалентен одноименному типу в C++, он используется во всех стандартных блоках для работы с
  вещественными числами.</dd>

  <dt><span class="term"><span id="light_ref12"><span id="ref11">Строка</span></span></span> (размер &ndash; 4 байта).</dt>
  <dd>Содержит указатель на строку символов произвольной длины, завершающуюся кодом 0. Если строка пустая, может
  содержать нулевой указатель (<span class="cpp">NULL</span>). В строках RDS всегда используется кодировка
  Windows <span id="light_ref11">CP1251</span>, многобайтовые символы Unicode не поддерживаются.
  Работа со строками в модели блока рассматривается в <a href="pm_2_5_4.htm" title="&sect;2.5.4. Работа со строками">&sect;2.5.4</a>.</dd>

  <dt><span class="term"><span id="light_ref13">Массив</span></span>&nbsp;/&nbsp;<span class="term"><span id="light_ref14">матрица</span></span>
  (размер &ndash; 8 байтов)</dt>
  <dd>Первые 4 байта переменной содержат указатель на область данных массива или матрицы или нулевой указатель
  (<span class="cpp">NULL</span>) при отсутствии элементов. Вторые 4 байта &ndash; служебные, они используются
  RDS для определения типа элемента массива. Область данных матрицы содержит число строк и столбцов (первые и
  вторые 4 байта соответственно), за которыми следуют последовательно записанные данные элементов. Массив отличается
  от матрицы только тем, что при указании номера элемента используется только один индекс
  (второй считается нулевым). Область данных массива ничем не отличается от области данных матрицы (в качестве числа
  строк всегда хранится значение 1). Работа с массивами и матрицами в модели блока рассматривается в
  <a href="pm_2_5_3.htm" title="&sect;2.5.3. Доступ к матрицам и массивам">&sect;2.5.3</a>.</dd>

  <dt><span class="term"><span id="light_ref15">Произвольный тип</span></span>
  (размер &ndash; 8 байтов)</dt>
  <dd>Универсальный тип переменной, который может изменяться в процессе работы блока. К входам произвольного типа
  можно подключать связи от выходов любого типа &ndash; в момент срабатывания связи такой вход получит тот же
  фактический тип, что и выход, передавший ему значение. Выход произвольного типа может подстраиваться под разные
  типы значений при работе модели блока. Первые 4 байта переменной содержат указатель на область данных переменной,
  вторые 4 байта &ndash; служебные, используются RDS для хранения текущего фактитипа переменной. Переменные
  произвольного типа обрабатываются RDS медленнее, чем другие, поэтому их следует использовать только для
  данных, тип которых заранее неизвестен (например, при создании моделей универсальных мультиплексоров или
  демультиплексоров). Работа с переменными произвольного типа в модели блока рассматривается в
  <a href="pm_2_5_6.htm" title="&sect;2.5.6. Работа с переменными произвольного типа">&sect;2.5.6</a>.</dd>

  <dt><span class="term"><span id="ref17"><span id="light_ref16">Структура</span></span></span> (размер &ndash; 4 байта)</dt>
  <dd>Содержит указатель на область памяти, в которой последовательно размещены значения
  <span class="term" id="light_ref17">полей</span> структуры. Каждое поле &ndash; это отдельная
  переменная, имеющая собственные имя и тип. Связи могут подключаться как к структуре в целом, так и к ее
  отдельным полям. У структуры есть имя типа &ndash; произвольная строка, связанная с данным конкретным
  набором полей. Структуры чаще всего используются для работы со сложными данными, состав их полей
  <a href="um_2_14.htm" title="&sect;2.14. Создание и изменение структур">может редактироваться пользователем</a>. Работа со
  структурами в модели блока рассматривается в <a href="pm_2_5_5.htm" title="&sect;2.5.5. Работа со структурами">&sect;2.5.5</a>.</dd>

</dl>

<p>Статические переменные блока могут быть внутренними, входами или выходами &ndash; их роль задается в колонке
&laquo;<span class="menu">Вход/Выход</span>&raquo; редактора переменных. К внутренним переменным нельзя подключать связи, они обычно
используются для хранения параметров блока или для управления элементами его
<a href="pm_1_4.htm#light_ref4" title="Векторная картинка блока">векторной картинки</a>.</p>

<p>Входы могут получать данные через связи от других блоков (автоматически в
<a href="pm_1_3.htm#ref3" title="Режим расчета">режиме расчета</a> или при вызове специальной
<a href="rdsActivateOutputConnections.htm" title="А.5.6.1. rdsActivateOutputConnections &ndash; активация выходных связей блока">сервисной функции</a>
в других режимах).
<span id="ref18">Можно</span>
указать необходимость <span id="light_ref18">автоматического запуска модели блока</span> в режиме расчета при
срабатывании связи, подключенной к данному входу &ndash; для этого служит колонка
&laquo;<span class="menu">Пуск</span>&raquo; редактора переменных. Например, в структуре переменных, изображенной
на <a href="#pic2" title="Редактор переменных">рис.&nbsp;9</a>,
включен автоматический запуск модели при срабатывании связей, подключенных к переменным
&laquo;<span class="rdsvar">x_in</span>&raquo; и &laquo;<span class="rdsvar">y_in</span>&raquo;. Кроме того, к каждому входу блока можно привязать другую
переменную сигнального типа: при срабатывании связи, подключенной к данному входу, в эту переменную
автоматически запишется значение 1. Анализируя значения таких связанных сигналов, модель блока может выяснить,
какие из связей, подключенных к блоку, сработали в предыдущем такте расчета. Поскольку в RDS нулевые
значения сигнальных переменных не передаются при срабатывании связей, после анализа связанной сигнальной переменной
модель блока должна самостоятельно сбросить эти сигналы в 0, чтобы получить возможность определить следующее
срабатывание  связи &ndash; иначе в переменной навсегда останется единичное значение, и модель не сможет
отличить срабатывание следующей связи от предыдущей. Для привязывания сигнала к входу в редакторе переменных в
колонке &laquo;<span class="menu">Вход/Выход</span>&raquo; нужно выбрать для данной переменной вариант
&laquo;Вход/Сигнал&raquo;, и указать в этой же колонке имя связанного сигнала.
На <a href="#pic2" title="Редактор переменных">рис.&nbsp;9</a>
к входам &laquo;<span class="rdsvar">x_in</span>&raquo; и &laquo;<span class="rdsvar">y_in</span>&raquo; привязаны внутренние сигнальные переменные
&laquo;<span class="rdsvar">x_in_ok</span>&raquo; и &laquo;<span class="rdsvar">y_in_ok</span>&raquo; соответственно. Подробнее использование
связанных со входами сигналов рассматривается в <a href="pm_2_5_7.htm" title="&sect;2.5.7. Использование входов со связанными сигналами">&sect;2.5.7</a>.</p>

<p>К выходам блока могут подключаться связи, передающие данные на входы других блоков. С каждым выходом может быть
связана дополнительная переменная логического типа &ndash; при этом связи, подключенные к этому выходу, сработают
только в том случае, если эта переменная будет иметь значение 1 (истина). Для такой связи нужно в колонке
&laquo;<span class="menu">Вход/Выход</span>&raquo; редактора переменных выбрать вариант &laquo;Выход/Логическая&raquo; и указать имя
связанной логической переменной. С выходами-массивами можно связать не только логическую переменную, управляющую
передачей всего выхода в целом, но и целую &ndash; в этом случае будут работать только связи, присоединенные к
элементу массива, номер которого определяется этой целой переменной, и связи, присоединенные ко всему массиву как
к единому целому.  Подробнее использование
связанных со выходами управляющих переменных рассматривается в <a href="pm_2_5_8.htm" title="&sect;2.5.8. Использование выходов с управляющими переменными">&sect;2.5.8</a>.
Следует помнить, что в режиме расчета связи, присоединенные к выходам блока, срабатывают только в
том случае, если вторая сигнальная переменная этого блока (выход &laquo;<span class="rdsvar">Ready</span>&raquo;) имеет единичное значение.
При запуске модели блока в режиме расчета в эту переменную автоматически записывается единица, но блок может
обнулить ее, чтобы блокировать передачу по связям значений всех своих выходов.</p>

<p>В колонке &laquo;<span class="menu">По умолчанию</span>&raquo; редактора переменных задается исходное значение переменной,
которое она получит сразу после загрузки схемы, добавлении нового блока с этой структурой или после
сброса расчета. Для массивов и матриц можно задать только исходный размер и значение по умолчанию для
одного элемента, задать разные значения по умолчанию для разных элементов массива нельзя.</p>

<div class="picright"><div class="container" id="pic3">
<img src="../img/LinkConnMenu.png" width="174" height="141" alt="Меню подключения связи" />
<p id="light_pic3">Рис.&nbsp;10. Меню<br/>подключения связи</p>
</div></div>


<p>Флаг в колонке редактора &laquo;<span class="menu">Меню</span>&raquo; указывает на необходимость добавить имя данного входа
или выхода в меню подключении связи
(<a href="#pic3" title="Меню подключения связи">рис.&nbsp;10</a>).
К входам и выходам без этого флага все равно можно подключить связь, но в меню их имена отображаться не будут,
пользователь должен будет выбрать в нем пункт &laquo;<span class="menu">Список</span>&raquo; и указать имя подключаемой переменной в
отдельном окне. Обычно флаг &laquo;<span class="menu">меню</span>&raquo; устанавливают для основных входов и выходов блока, а у
дополнительных и редко используемых его сбрасывают, чтобы их имена не загромождали меню подключения связи.</p>

<p>Флаг в колонке &laquo;<span class="menu">ABC</span>&raquo; управляет отображением имени входа или выхода на схеме по умолчанию: если он
включен, при подключении новой связи к блоку рядом с точкой подключения будет выведено имя переменной, с которой
соединена эта связь (см. имена переменных
на <a href="pm_1_2.htm#pic1" title="Простой блок с подключенными связями">рис.&nbsp;1</a>).
Позже, независимо от состояния этого флага, изображение имени переменной можно включать и выключать по
желанию &ndash; для этого предназначен отдельный пункт в
<a href="um_2_3.htm#ref16" title="Контекстное меню точки связи или шины">контекстном меню точки связи</a>.</p>

<p>Колонки &laquo;<span class="menu">Начало</span>&raquo; и &laquo;<span class="menu">Размер</span>&raquo; (с изображением двунаправленной стрелки), недоступные
для изменения, показывают смещение к данной переменной от начала дерева и ее размер в байтах соответственно. Эти
значения вычисляются автоматически, они могут пригодиться при написании модели блока для обращения к конкретной
переменной при известном адресе начала дерева переменных в памяти. При написании функций моделей на языке C/C++
указатели на переменные не нужно вычислять вручную, для этого можно использовать
<a href="pm_2_5_1.htm#light_ref9" title="Макросы для статических переменных блока">макроопределения</a>, генерируемые RDS.</p>

<p><span id="ref19">Для</span>
однозначного определения типов всех переменных блока используется
<span class="term" id="light_ref19">строка типа</span>
(см. <a href="#pic2" title="Редактор переменных">рис.&nbsp;9</a>, внизу слева). В этой строке каждой переменной соответствует один
или несколько символов, указывающих на тип этой переменной. Большинству типов соответствует один символ:
сигнал &ndash; &laquo;S&raquo;, логический &ndash; &laquo;L&raquo;, char – &laquo;C&raquo;,
short &ndash; &laquo;H&raquo;, int &ndash; &laquo;I&raquo;, float &ndash; &laquo;F&raquo;,
double &ndash; &laquo;D&raquo;, строка &ndash; &laquo;A&raquo;,
произвольный &ndash; &laquo;V&raquo;. Массивам и матрицам соответствует символ
&laquo;M&raquo;, за которым следует тип элемента (например, &laquo;MD&raquo; &ndash; матрица переменных
double, &laquo;MMA&raquo; &ndash; матрица матриц строк). Структурам соответствуют символы
&laquo;{&raquo; и &laquo;}&raquo;, между которыми указываются типы всех полей структуры (например,
структура, состоящая из двух вещественных полей двойной точности, описывается строкой
&laquo;{DD}&raquo;). На самом деле, весь набор переменных блока тоже является структурой, поэтому строка типа
переменных блока всегда начинается с символа &laquo;{&raquo; и заканчивается символом &laquo;}&raquo;.
Например, тип переменных стандартного блока вычитания (имеющего, помимо двух обязательных сигналов
&laquo;<span class="rdsvar">Start</span>&raquo; и &laquo;<span class="rdsvar">Ready</span>&raquo;, два входа типа double и выход того же типа) описывается строкой
&laquo;{SSDDD}&raquo; , где две буквы &laquo;S&raquo; соответствуют двум сигналам, а три буквы
&laquo;D&raquo; &ndash; двум вещественным входам и выходу.</p>

<p>Модели блоков обычно используют строку типа для проверки, может ли данная модель работать с данной структурой
статических переменных (чаще всего это делается в реакции на событие
<span class="cpp"><a href="RDS_BFM_VARCHECK.htm" title="А.2.4.18. RDS_BFM_VARCHECK &ndash; проверка допустимости структуры статических переменных блока">RDS_BFM_VARCHECK</a></span>,
см. <a href="pm_2_5_1.htm" title="&sect;2.5.1. Доступ к статическим переменным и работа в режиме расчета">&sect;2.5.1</a>). Эта проверка очень важна, так как модели обычно работают со
статическими переменными по фиксированным смещениям относительно начала дерева переменных, и при несоответствии
структуры переменных ожиданиям модели, в лучшем случае, будут считаны и записаны неверные значения, в худшем
&ndash; возникнет ошибка общей защиты. Например, уже упомянутая стандартная модель блока вычитания откажется
работать с любым блоком, строка типа переменных которого не &laquo;{SSDDD}&raquo;. Эта модель обращается к
переменным блока по следующим смещениям: 0 &ndash; первый сигнал (&laquo;<span class="rdsvar">Start</span>&raquo;), 1 &ndash; второй
сигнал (&laquo;<span class="rdsvar">Ready</span>&raquo;), 2 (1+1) &ndash; первая вещественная (&laquo;<span class="rdsvar">x1</span>&raquo;), 10 (1+1+8)
&ndash; вторая вещественная (&laquo;<span class="rdsvar">x2</span>&raquo;), 18 (1+1+8+8) &ndash; третья вещественная (&laquo;<span class="rdsvar">y</span>&raquo;).
Если бы модель не проверяла типы переменных, при попытке подключить ее к блоку со строкой типа, например,
&laquo;{SSD}&raquo;, при обращении к переменной &laquo;<span class="rdsvar">y</span>&raquo; (смещение 18) возникла бы ошибка общей
защиты, поскольку байты 18-25 от начала области переменных находится за пределами отведенной памяти. В строке типа
нигде не указывается, является ли переменная входом или выходом, она определяет только типы переменных и их
последовательность в памяти. Если в структуре переменных блока вычитания поменять местами вход &laquo;<span class="rdsvar">x1</span>&raquo;
и выход &laquo;<span class="rdsvar">y</span>&raquo;, строка типов не изменится. Модель при этом будет работать неправильно, но, поскольку и
переменная &laquo;<span class="rdsvar">x1</span>&raquo;, и переменная &laquo;<span class="rdsvar">y</span>&raquo; имеют одинаковый размер и тип, фатальных ошибок,
вроде ошибки общей защиты, не произойдет.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="pm_1_4.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="pm_1_6.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="pm_index.htm#light_htm:pm_1_5">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
