<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;1.6. Взаимодействие блоков между собой</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="pm_index.htm">Руководство программиста</a></p>
<div class="level"><p><a href="pm_index.htm#light_htm:pm_1">Глава 1. Устройство RDS</a></p>
<div class="level"><p>&sect;1.6. Взаимодействие блоков между собой</p>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="pm_1_5.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="pm_1_7.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="pm_index.htm#light_htm:pm_1_6">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Руководство программиста</h1>
<h2 class="off">Глава 1. Устройство RDS</h2>
<h3>&sect;1.6. Взаимодействие блоков между собой</h3>
<p class="abstract">Описываются способы взаимодействия блоков друг с другом через динамические переменные, которые создаются в процессе работы одним блоком подсистемы и автоматически становятся доступными для других блоков. Использование динамических переменных для передачи данных не загромождает подсистему лишними связями и не требует запуска режима расчета, что иногда может оказаться очень удобным.</p>


<p>В RDS предусмотрено несколько способов передачи информации между блоками. Самый простой способ
&ndash; передача данных по связям. Она осуществляется автоматически, однако требует
<a href="pm_1_3.htm#ref3" title="Режим расчета">запуска расчета</a>,
что не всегда удобно. Кроме того, слишком большое число связей загромождает схему. Чтобы можно было передавать
данные в любом режиме, следует использовать другие способы.</p>

<p><span id="ref1">Если</span>
нескольким блокам требуется получить доступ к одной, общей для всех, переменной (например, к значению
текущего времени при моделировании в динамике), они могут использовать
<span class="term">динамическую переменную</span>. <span id="light_ref1">Динамическая переменная</span> создается
одним из блоков, после чего остальные блоки могут найти ее по имени и типу и получить к ней доступ
&ndash; <span class="term">подписаться</span> на переменную. Динамическая переменная всегда принадлежит
какому-нибудь блоку, при этом не обязательно тому, который ее создал. Например, если эта переменная нужна всем
блокам какой-либо подсистемы, ее целесообразно создать в этой подсистеме, чтобы все заинтересованные блоки могли
ее найти. Блок может создать динамическую переменную в себе самом, в родительской подсистеме или в корневой
подсистеме. При подписке на переменную можно указать режим поиска &ndash; в этом случае блок попытается найти
переменную в родительской подсистеме, и, если ее там не окажется, будет двигаться вверх по иерархии до тех пор,
пока не найдет переменную с заданными именем и типом или пока не дойдет до корневой подсистемы. Блок также может
подписаться на переменную, которой еще не существует. Факт подписки будет запомнен, и, как только переменная
будет создана, блок получит к ней доступ. Сервисные функции для работы с динамическими переменными рассмотрены в
<a href="pm_index.htm#light_htm:pm_2_6" title="&sect;2.6. Динамические переменные">&sect;2.6</a>.</p>

<p><span id="ref2">Если</span> блоку необходимо передать информацию одному или нескольким другим
блокам и получить ответ, можно
использовать механизм вызова <span class="term" id="light_ref2">функций блоков</span>. Можно вызвать
<a href="rdsCallBlockFunction.htm" title="А.5.13.7. rdsCallBlockFunction &ndash; прямой вызов функции блока">функцию конкретного блока</a>
(для этого нужно знать его
<a href="app_ids.htm#light_ref1" title="Идентификатор блока">идентификатор</a>) или
<a href="rdsBroadcastFunctionCallsEx.htm" title="А.5.13.6. rdsBroadcastFunctionCallsEx &ndash; прямой вызов функции всех блоков подсистемы">всех блоков</a> какой-либо подсистемы (при этом можно
включать вложенные подсистемы или ограничиться только одним уровнем иерархии). Каждая функция в схеме должна
иметь уникальное имя-строку, поэтому целесообразно давать им длинные осмысленные имена с указанием имени
библиотеки, блоки которой ее используют (
<span id="ref3">например</span>, функция уведомления органов
управления об изменении значения,
которую используют блоки из стандартной библиотеки &laquo;<span class="file">Common.dll</span>&raquo;, называется
&laquo;<span class="rdsvar"><span id="light_ref3">Common.ControlValueChanged</span></span>&raquo;).
<span id="ref4">Для</span> <span id="ref5">того</span>, чтобы
вызвать функцию блока или ввести в блок реакцию на вызываемую функцию, ее сначала нужно
<span class="term" id="light_ref5">зарегистрировать</span> в RDS при помощи сервисной функции
<span id="light_ref4"><span class="cpp"><a href="rdsRegisterFunction.htm" title="А.5.13.12. rdsRegisterFunction &ndash; регистрация функции блока">rdsRegisterFunction</a></span></span>.
Она присвоит функции блока уникальный целый идентификатор, который будет использоваться для вызова.
Регистрировать функции блоков можно при загрузке DLL или при создании блока, использующего функцию. Повторная
регистрация функции с тем же именем не приведет к ошибке, будет возвращен целый идентификатор, присвоенный
этой функции при первой регистрации.</p>

<p>В модель блока, функция которого вызвана, передается
<a href="RDS_BFM_FUNCTIONCALL.htm#ref1" title="Структура RDS_FUNCTIONCALLDATA">структура</a>,
содержащая уникальный целый идентификатор функции, идентификатор вызвавшего блока и указатель на параметры функции.
Параметры функции &ndash; это область данных (обычно структура или класс), в которой находятся входные параметры
функции блока. При необходимости, туда же помещаются результаты возврата функции. Такая структура создается
при написании модели блока для каждой конкретной функции. RDS никак не контролирует правильность передачи
параметров, указанный при вызове функции адрес передается в модель блока без изменений. По этой причине очень
важно следить за уникальностью имен функций &ndash; если параметры двух функций с одинаковыми именами будут
различаться, блок может принять одну функцию за другую, и либо считать неверные значения параметров, либо,
если размеры структур отличаются, обратиться к не отводившейся памяти и вызвать ошибку общей защиты. Для
исключения таких ситуаций имеет смысл во все структуры параметров всех функций включать специальное поле,
содержащее размер переданной структуры (причем лучше всего делать это поле самым первым в структуре), как
это делается во многих функциях Windows API и сервисных функциях RDS. Несоответствие значения этого поля
ожиданиям модели блока будет говорить о неправильном вызове функции.</p>

<div class="picright"><div class="container" id="pic1">
<img src="../img/HandleAndInput.png" width="201" height="182" alt="Соединение рукоятки и поля ввода" />
<p id="light_pic1">Рис.&nbsp;11. Соединение<br />рукоятки и поля ввода</p>
</div></div>


<p>Механизм вызова функций блоков можно использовать по-разному.
<span id="ref6">Например</span>,
блок может активировать передачу данных по своим выходным связям при помощи сервисной функции
<span id="light_ref6"><span class="cpp"><a href="rdsActivateOutputConnections.htm" title="А.5.6.1. rdsActivateOutputConnections &ndash; активация выходных связей блока">rdsActivateOutputConnections</a></span></span>, после чего получить из RDS список блоков, соединенных с
его выходами, и информировать каждый из них об изменении входных данных вызовом функции (естественно, в моделях
этих блоков должна быть реакция на эту функцию). Именно так работает функция
&laquo;<span class="rdsvar">Common.ControlValueChanged</span>&raquo;, которую поддерживают стандартные поля ввода и индикаторы из
библиотеки &laquo;<span class="file">Common.dll</span>&raquo;. Если, например, соединить связями вертикальную рукоятку и поле ввода
(<a href="#pic1" title="Соединение рукоятки и поля ввода">рис.&nbsp;11</a>),
то в режиме <a href="pm_1_3.htm#ref2" title="Режим моделирования">моделирования</a>
(без запуска расчета) при перемещении рукоятки будет автоматически изменяться значение в поле ввода. Как только
пользователь переместит рукоятку в другое положение, модель блока, отображающего рукоятку, вызовет сервисную
функцию <span class="cpp">rdsActivateOutputConnections</span>, что приведет к передаче по связи нового значения в
блок, отображающий поле ввода. После этого модель рукоятки вызовет функцию
&laquo;<span class="rdsvar">Common.ControlValueChanged</span>&raquo; для соединенных с ней блоков, то есть для поля ввода. Модель поля
ввода, реагируя на функцию, считает новое значение со своего входа и отобразит его. Эта же функция, вызываемая
моделью поля ввода, приведет к тому, что при изменении значения в поле ввода рукоятка будет перемещаться в новое
положение.</p>

<p>При помощи вызова функций можно также реализовать поиск блока по какому-нибудь значению, хранящемуся в
личной области данных. Для этого следует зарегистрировать функцию поиска и вызвать ее для всех блоков схемы,
передав в структуре параметров искомое значение. Модель блока, реагирующего на эту функцию, должна сравнить
переданное значение с хранящимся в личной области данных, и, при совпадении, записать в структуру параметров
функции идентификатор блока. Примеры взаимодействия блоков при помощи вызова функций рассмотрены в
<a href="pm_index.htm#light_htm:pm_2_13" title="&sect;2.13. Вызов функций блоков">&sect;2.13</a>.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="pm_1_5.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="pm_1_7.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="pm_index.htm#light_htm:pm_1_6">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
