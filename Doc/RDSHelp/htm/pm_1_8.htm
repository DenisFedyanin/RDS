<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;1.8. Открытие окон в модели блока</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="pm_index.htm">Руководство программиста</a></p>
<div class="level"><p><a href="pm_index.htm#light_htm:pm_1">Глава 1. Устройство RDS</a></p>
<div class="level"><p>&sect;1.8. Открытие окон в модели блока</p>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="pm_1_7.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="pm_2_1.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="pm_index.htm#light_htm:pm_1_8">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Руководство программиста</h1>
<h2 class="off">Глава 1. Устройство RDS</h2>
<h3>&sect;1.8. Открытие окон в модели блока</h3>
<p class="abstract">Описываются особенности открытия модальных (блокирующих доступ к остальным окнам приложения до своего закрытия) и немодальных (позволяющих переключаться в другие окна) окон из программы модели блока и связанные с этим проблемы, на которые следует обратить внимание. Различные примеры работы с окнами в моделях блоков приведены в <a href="pm_index.htm#light_htm:pm_2_7" title="&sect;2.7. Настройка параметров блока">&sect;2.7</a>.</p>


<p> <span id="ref1">Как</span>
<span id="ref2">и</span>
любая другая программа в Windows, модель блока может открывать модальные и 
<span id="light_ref2">немодальные окна</span> для диалога 
с пользователем. <span id="light_ref1">Модальные окна</span> отличаются от немодальных тем, что при 
открытом модальном окне пользователь не может перейти в какое-либо другое окно приложения, пока модальное не 
будет закрыто. Модель блока, открывшая модальное окно, получит управление обратно только после закрытия этого 
окна. Если же функция модели открывает немодальное окно, она получает управление обратно немедленно, в то время 
как окно остается открытым. Пользователь при этом может свободно переключаться между окнами.</p>

<p>Для корректного взаимодействия создаваемых моделью окон с RDS необходимо соблюдать некоторые правила. 
Если модель открывает немодальное окно, процедура обработки сообщений этого окна будет вызываться в 
произвольные моменты времени, тогда, когда это необходимо Windows. 
В <a href="pm_1_3.htm#ref3" title="Режим расчета">режиме расчета</a> к главному потоку RDS, 
занимающемуся обслуживанием окон и интерфейса, добавляется поток расчета, по очереди вызывающий модели простых 
блоков и передающий данные по связям между блоками. При этом необходимо синхронизировать работу процедуры окна, 
которая, вероятнее всего, будет работать в главном потоке, с потоком расчета. Если оба потока одновременно 
обратятся к каким-либо данным блока, могут возникнуть серьезные ошибки. При обращении к данным изнутри функции 
модели таких проблем не возникает, поскольку RDS самостоятельно синхронизирует вызовы моделей блоков 
в обоих потоках. Однако, процедура окна может быть вызвана Windows в любой момент, без синхронизации, за 
которой следит RDS. <span id="ref3">Поэтому</span>, чтобы избежать коллизий, 
в процедуре окна (и связанных с ней функциях, 
если они есть) необходимо перед любым обращением к данным блока и вызовом сервисных функций RDS вызывать 
функцию <span id="light_ref3"><span class="cpp"><a href="rdsLockBlockData.htm" title="А.5.3.3. rdsLockBlockData &ndash; включение блокировки данных">rdsLockBlockData</a></span></span>, которая заблокирует данные блока и 
запретит другому потоку доступ к ним. 
<span id="ref4">После</span> выполнения всех необходимых действий с данными блока необходимо 
вызвать функцию <span id="light_ref4"><span class="cpp"><a href="rdsUnlockBlockData.htm" title="А.5.3.5. rdsUnlockBlockData &ndash; выключение блокировки данных">rdsUnlockBlockData</a></span></span>, которая разблокирует данные 
и снова разрешит к ним доступ. Если второй поток попытается обратиться к данным блока после вызова 
<span class="cpp">rdsLockBlockData</span>, он будет остановлен до тех пор, пока не будет вызвана 
<span class="cpp">rdsUnlockBlockData</span>, поэтому желательно разблокировать данные блока как можно быстрее. 
Крайне необходимо следить за тем, чтобы за каждым вызовом функции <span class="cpp">rdsLockBlockData</span> 
обязательно следовал вызов <span class="cpp">rdsUnlockBlockData</span>, иначе один из потоков может зависнуть. 
<span id="ref5">Если</span>
компилятор поддерживает конструкции типа <span class="cpp" id="light_ref5">try...finally</span>, 
целесообразно использовать 
их для слежения за парностью этих вызовов, например (для Borland C++):</p>

<pre class="cpp">  <a class="hidden" href="rdsLockBlockData.htm" title="А.5.3.3. rdsLockBlockData &ndash; включение блокировки данных">rdsLockBlockData</a>(); <span class="rem">// Блокировка данных</span>
  <span class="kw">try</span>
    { <span class="rem">// .....</span>
      <span class="rem">// Действия с данными блока или вызов сервисных функций</span>
      <span class="rem">// .....</span>
    }
  <span class="kw">__finally</span>
    { <a class="hidden" href="rdsUnlockBlockData.htm" title="А.5.3.5. rdsUnlockBlockData &ndash; выключение блокировки данных">rdsUnlockBlockData</a>(); <span class="rem">// Снятие блокировки</span>
    }</pre>

<p>Немодальные окна чаще всего используются моделями блоков для постоянной индикации каких-либо параметров, 
которую невозможно или неудобно осуществлять в окне подсистемы (например, для вывода трехмерного изображения) и 
для предоставления пользователю возможности менять параметры блока в реальном времени. В таких случаях 
целесообразно блокировать данные только на время чтения параметров из внутренних структур блока и записи изменений, 
сделанных пользователем. Все остальное время данные не должны быть заблокированы, иначе поток расчета будет 
постоянно простаивать.</p>

<p><span id="ref6">Для</span>
удобства пользователя модель блока может зарегистрировать 
созданные ей немодальные окна в RDS при помощи сервисной функции 
<span id="light_ref6"><span class="cpp"><a href="rdsRegisterWindow.htm" title="А.5.2.31. rdsRegisterWindow &ndash; регистрация немодального окна">rdsRegisterWindow</a></span></span>, которая добавит название созданного окна в меню 
&laquo;<span class="menu">Окна</span>&raquo; и кнопку для вызова этого окна на панель окон в 
<a href="um_2_1.htm" title="&sect;2.1. Главное окно и главное меню">главном окне</a>
RDS. 
<span id="ref7">При этом</span> следует информировать RDS об активации зарегистрированного окна функцией 
<span id="light_ref7"><span class="cpp"><a href="rdsRegWinActivateNotify.htm" title="А.5.2.32. rdsRegWinActivateNotify &ndash; уведомление об активации зарегистрированного окна">rdsRegWinActivateNotify</a></span></span>.</p>

<p>Обычно открытие окон связывают с выбором каких-либо пунктов меню, созданных блоком, или с нажатием кнопок 
мыши или клавиш. Все эти действия выполняются в главном потоке RDS. Открывать окна из потока расчета 
(при вызове модели с параметром <span class="cpp"><a href="RDS_BFM_MODEL.htm" title="А.2.4.9. RDS_BFM_MODEL &ndash; выполнение такта расчета">RDS_BFM_MODEL</a></span>) не рекомендуется. Следует также помнить, что 
при удалении блока модель обязана уничтожить все открытые этим блоком окна.</p>

<p>Модальные окна обычно применяются для организации диалога с пользователем, ввода параметров блока и т.п. 
Поскольку при открытии модального окна управление возвращается вызвавшей программе только после закрытия этого окна, 
в вызове функций синхронизации <span class="cpp">rdsLockBlockData</span> и 
<span class="cpp">rdsUnlockBlockData</span> нет необходимости. Открытие модального окна происходит внутри функции 
модели блока, а перед вызовом модели данные блокируются автоматически. Таким образом, в процедуре модального окна 
можно в любой момент обращаться к данным блока и вызывать сервисные функции RDS. Это сильно упрощает написание 
процедуры модального окна, но порождает следующее ограничение: <span class="emph">крайне нежелательно 
открывать модальные окна в 
режиме расчета</span>, когда одновременно работают два потока. Поскольку на момент открытия окна данные уже заблокированы, 
второй поток, тоже попытавшийся обратиться к данным, будет простаивать до тех пор, пока окно не будет закрыто 
пользователем и функция модели, открывшая окно, не завершится, вернув управление RDS. В режимах моделирования 
и редактирования, в которых работает только один поток, открытие модальных окон не вызывает никаких проблем.</p>

<p>Если логика работы блока требует открытия модального окна в режиме расчета, и это окно не может быть 
заменено немодальным, можно воспользоваться механизмом вызова функции без блокировки данных. 
<span id="ref8">Для этого</span> нужно 
создать функцию специального вида, которая будет открывать модальное окно, после чего передать указатель на эту 
функцию сервисной функции RDS 
<span id="light_ref8"><span class="cpp"><a href="rdsUnlockAndCall.htm" title="А.5.3.4. rdsUnlockAndCall &ndash; вызвать функцию, сняв блокировку данных">rdsUnlockAndCall</a></span></span>. Эта функция снимет блокировку данных, после 
чего вызовет указанную функцию пользователя, по завершении которой блокировка будет восстановлена. Поскольку в этом 
случае на время открытия модального окна блокировка данных снимается, в процедуре окна, несмотря на его 
модальность, необходимо вызывать <span class="cpp">rdsLockBlockData</span> перед обращением к данным блока и 
<span class="cpp">rdsUnlockBlockData</span> после него. Пример использования функции приведен в 
<a href="pm_2_7_6.htm" title="&sect;2.7.6. Открытие модальных окон в режиме расчета">&sect;2.7.6</a>.</p>

<p>В потоке расчета, то есть при вызове модели с параметром <span class="cpp">RDS_BFM_MODEL</span> для 
выполнения одного 
<a href="pm_1_3.htm#ref3" title="Режим расчета">такта расчета</a> открывать модальные окна 
<span class="emph">недопустимо</span>. Независимо от способа синхронизации, функция модели, вызванная в потоке 
расчета, не получит обратно управления до закрытия модального окна, что приведет к остановке всего потока расчета.</p>

<p><span id="light_ref9">После закрытия модального окна</span>
управление возвращается функции, открывшей его, поэтому ни в коем случае нельзя допускать удаления блока 
или выгрузки DLL с моделью, пока окно не будет закрыто. Если это случится, после закрытия окна управление будет 
передано в освобожденную область памяти, что, вероятнее всего, приведет к ошибке общей защиты. DLL с функцией 
модели блока всегда выгружается при очистке всей схемы (например, перед загрузкой другой схемы или перед завершением 
RDS). Она также может быть выгружена при удалении блока или отключении его модели, если в схеме больше 
не осталось блоков, использующих эту модель.</p>

<p>Пока модальное окно открыто, пользователь не сможет ни загрузить другую схему, ни закрыть RDS, ни удалить 
какой-либо блок. Модальное окно блокирует доступ к другим окнам, включая главное окно RDS и окна подсистем, 
поэтому пользователь просто не сможет выполнить соответствующие действия. Может показаться, что выгрузка DLL 
с моделью блока, открывшего модальное окно, невозможна. Однако, загрузить схему или удалить блок может не только 
пользователь. Если RDS работает под управлением другого приложения (например, использующего библиотеку 
&laquo;<span class="file">RdsCtrl.dll</span>&raquo;, подробно описанную в 
<a href="pm_index.htm#light_htm:pm_2" title="Глава 2. Создание моделей блоков">главе 2</a>), это приложение может приказать RDS загрузить другую схему 
независимо от наличия открытых модальных окон. Открытое модальное окно также не может помешать какой-либо 
модели блока, вызванной по таймеру или в потоке расчета, загрузить другую схему или удалить блок при помощи 
соответствующих сервисных функций. Чтобы избежать катастрофических последствий из-за не вовремя выгруженной 
DLL, модель блока должна информировать RDS об открытии и закрытии модальных окон при помощи сервисных функций 
<span class="cpp"><span id="light_ref10"><a href="rdsBlockModalWinOpen.htm" title="А.5.2.8. rdsBlockModalWinOpen &ndash; сообщение об открытии модального окна">rdsBlockModalWinOpen</a></span></span> и <span class="cpp"><span id="light_ref11"><a href="rdsBlockModalWinClose.htm" title="А.5.2.7. rdsBlockModalWinClose &ndash; сообщение о закрытии модального окна">rdsBlockModalWinClose</a></span></span> соответственно 
(для слежения за парностью вызовов этих функций можно использовать конструкцию
<span class="cpp">try...finally</span>, но в приведенный ниже пример она не включена):</p>

<pre class="cpp">  <span class="rem">// Информация об открытии окна блоком Block</span>
  <a class="hidden" href="rdsBlockModalWinOpen.htm" title="А.5.2.8. rdsBlockModalWinOpen &ndash; сообщение об открытии модального окна">rdsBlockModalWinOpen</a>(Block); 
  <span class="rem">// ...</span>
  <span class="rem">// Открытие модального окна средствами Windows</span>
  <span class="rem">// ...</span>
  <span class="rem">// Информация о закрытии окна</span>
  <a class="hidden" href="rdsBlockModalWinClose.htm" title="А.5.2.7. rdsBlockModalWinClose &ndash; сообщение о закрытии модального окна">rdsBlockModalWinClose</a>(Block);</pre>

<p>Обе функции принимают единственный параметр &ndash; идентификатор блока, открывающего модальное окно (в примере 
&ndash; <span class="cpp">Block</span>). Если функция вызывается непосредственно из модели, можно вместо 
идентификатора блока указать <span class="cpp">NULL</span> &ndash; RDS самостоятельно определит, модель 
какого блока вызывается в данный момент. Если же модальное окно открывается из немодального (например, при нажатии 
какой-либо кнопки в окне), идентификатор блока указывать обязательно. Поскольку процедура немодального окна 
вызывается Windows в произвольные моменты времени без всякой синхронизации с вызовами моделей, RDS в этом 
случае не сможет определить, к какому именно блоку относится данное модальное окно.</p>

<p>Вызов функции <span class="cpp">rdsBlockModalWinOpen</span> сообщает RDS об открытии нового 
модального окна, которое будет считаться открытым до вызова функции <span class="cpp">rdsBlockModalWinClose</span>. 
В промежутке между этими двумя вызовами удаление блока, открывшего окно, будет запрещено. Если после вызова 
<span class="cpp">rdsBlockModalWinOpen</span> от управляющего приложения или от другой модели блока поступит 
команда загрузить другую схему, RDS попытается закрыть модальное окно, по очереди передавая в окна 
верхнего уровня стандартное сообщение Windows <span class="cpp">WM_CLOSE</span> до тех пор, пока данное окно 
не закроется (о закрытии окна RDS узнает, получив вызов <span class="cpp">rdsBlockModalWinClose</span>). 
Чтобы этот механизм сработал, все модальные окна, открываемые моделями блоков, должны принадлежать главному 
окну RDS (его дескриптор можно получить при помощи сервисной функции 
<span class="cpp"><span id="light_ref12"><a href="rdsGetAppWindowHandle.htm" title="А.5.2.18. rdsGetAppWindowHandle &ndash; дескриптор главного окна RDS">rdsGetAppWindowHandle</a></span></span>). Пример открытия модального окна средствами Windows с использованием 
сервисных функций <span class="cpp">rdsBlockModalWinOpen</span> и <span class="cpp">rdsBlockModalWinClose</span> 
приведен в <a href="pm_2_7_5.htm" title="&sect;2.7.5. Открытие модальных окон средствами Windows API">&sect;2.7.5</a>.</p>

<p>В некоторых случаях логика работы блока требует вывода запроса о необходимости сохранения введенных 
пользователем данных при закрытии модального окна. Обычно окно запроса содержит три кнопки: 
&laquo;<span class="menu">Да</span>&raquo;, &laquo;<span class="menu">Нет</span>&raquo; и &laquo;<span class="menu">Отмена</span>&raquo;, причем при нажатии кнопки 
&laquo;<span class="menu">Отмена</span>&raquo; модальное окно не закрывается. Написание процедуры модального окна в этом случае 
требует осторожности, поскольку механизм закрытия окон при помощи сообщения <span class="cpp">WM_CLOSE</span>, 
описанный выше, может привести к появлению бесконечного цикла: модальное окно получает сообщение 
<span class="cpp">WM_CLOSE</span> и выводит запрос о сохранении данных, окно запроса тоже получает сообщение 
<span class="cpp">WM_CLOSE</span> (что равносильно нажатию кнопки &laquo;<span class="menu">Отмена</span>&raquo;) и возвращает 
управление модальному окну, не закрывая его, модальное окно снова получает сообщение &laquo;<span class="menu">WM_CLOSE</span>&raquo; 
и т.д. Чтобы избежать этого цикла, перед выводом запроса следует вызвать сервисную функцию 
<span class="cpp"><span id="light_ref13"><a href="rdsModalWindowMustClose.htm" title="А.5.2.30. rdsModalWindowMustClose &ndash; проверка принудительного закрытия модальных окон">rdsModalWindowMustClose</a></span></span>, которая вернет значение <span class="cpp">TRUE</span>, 
если в данный момент идет принудительное закрытие модальных окон. В этом случае модальное окно необходимо 
закрыть, не выводя запросов пользователю.</p>

<p>Если модальные окна открываются не стандартными средствами Windows, а специальными сервисными функциями 
RDS (<span class="cpp"><a href="rdsMessageBox.htm" title="А.5.5.6. rdsMessageBox &ndash; вывод окна сообщения">rdsMessageBox</a></span>, <span class="cpp"><a href="rdsCallColorDialog.htm" title="А.5.5.1. rdsCallColorDialog &ndash; вызов диалога выбора цвета">rdsCallColorDialog</a></span>, 
<span class="cpp"><a href="rdsFORMShowModalEx.htm" title="А.5.28.6. rdsFORMShowModalEx &ndash; открыть окно с функцией обратного вызова">rdsFORMShowModalEx</a></span> и т.п.), в вызове функций <span class="cpp">rdsBlockModalWinOpen</span> 
и <span class="cpp">rdsBlockModalWinClose</span> нет необходимости. Сервисные функции, открывающие модальные 
окна, самостоятельно информируют RDS об их открытии и закрытии.</p>


</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="pm_1_7.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="pm_2_1.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="pm_index.htm#light_htm:pm_1_8">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
