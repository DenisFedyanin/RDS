<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;2.10.4. Панели блоков в окне подсистемы</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="pm_index.htm">Руководство программиста</a></p>
<div class="level"><p><a href="pm_index.htm#light_htm:pm_2">Глава 2. Создание моделей блоков</a></p>
<div class="level"><p><a href="pm_index.htm#light_htm:pm_2_10">&sect;2.10. Программное рисование внешнего вида блока</a></p>
<div class="level"><p>&sect;2.10.4. Панели блоков в окне подсистемы</p>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="pm_2_10_3.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="pm_2_11.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="pm_index.htm#light_htm:pm_2_10_4">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
<div class="right">
<span class="curtab">Текст</span>
<span class="tab"><a href="pm_2_10_4_c.htm">С++</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Руководство программиста</h1>
<h2 class="off">Глава 2. Создание моделей блоков</h2>
<h3 class="off">&sect;2.10. Программное рисование внешнего вида блока</h3>
<h4>&sect;2.10.4. Панели блоков в окне подсистемы</h4>
<p class="abstract">Рассматривается создание панелей &ndash; отдельных окон, принадлежащих блокам и находящихся
                внутри окна подсистемы. Такие панели нужны для размещения в них полей ввода или привязки к ним вывода
                внешних библиотек. Приводится пример блока, создающего пустую панель, которую пользователь может открывать,
                закрывать и перемещать. Затем этот пример модифицируется, и с панелью связывается область вывода
                трехмерной библиотеки OpenGL, а блок становится индикатором трех угловых координат, рисующим
                на панели поворачивающийся трехмерный объект.</p>


<p>Программное рисование модели блока с помощью функций API Windows или сервисных функций
RDS дает возможность строить сколь угодно сложные изображения в
<a href="um_2_3.htm" title="&sect;2.3. Элементы и меню окна подсистемы">окне подсистемы</a>. Однако, модель не имеет доступа к
самому окну подсистемы, и, поэтому, не может создавать внутри него свои собственные объекты (поля ввода,
элементы управления и т.п.) Проще говоря, модель блока не может средствами RDS получить дескриптор
(типа <span class="cpp"><span id="light_ref1"><a href="app_ids.htm#light_ref18" title="Дескриптор окна">HWND</a></span></span>) окна подсистемы и вмешиваться в его работу, добавляя в него
свои объекты. Технически, модель может получить этот идентификатор при помощи стандартной функции API Windows
<span class="cpp">WindowFromDC</span> и работать с ним, однако, разработчику модели лучше этого не делать из-за
возможных проблем с совместимостью &ndash; механизм взаимодействия RDS с моделями блоков на
это не рассчитан. Вместо этого модель блока, используя сервисные функции RDS, может создавать внутри окна
<a href="pm_1_2.htm#ref7" title="Родительская подсистема">родительской подсистемы</a>
специальные объекты &ndash; <span class="emph">панели</span>. Каждая такая панель
является оконным объектом Windows и имеет дескриптор <span class="cpp"><a class="hidden" href="app_ids.htm#light_ref18" title="Дескриптор окна">HWND</a></span>, который
RDS сообщает модели блока при создании панели. RDS также уведомляет модель об уничтожении оконного
объекта при закрытии окна подсистемы, о необходимости перерисовать содержимое панели, о перемещении или
изменении размера панели пользователем (если это разрешено) и т.д. Модель блока может создавать внутри панели
любые другие оконные объекты &ndash; главное, чтобы она удалила их при закрытии панели в ответ
на соответствующее сообщение от RDS. Следует помнить, что модель может создавать произвольное число
панелей, но только в окне родительской подсистемы. Создавать
панели в окнах других подсистем нельзя.</p>

<p>Общая процедура работы модели с панелями в окне подсистемы выглядит следующим образом:</p>

<ul>
  <li>Модель вызывает сервисную функцию <span class="cpp"><a href="rdsPANCreate.htm" title="А.5.31.1. rdsPANCreate &ndash; создать объект для работы с панелью">rdsPANCreate</a></span> для создания объекта-панели
  (это один из многих вспомогательных объектов RDS типа <span class="cpp"><a href="app_ids.htm#light_ref6" title="Идентификатор вспомогательного объекта">RDS_HOBJECT</a></span>). Независимо от того,
  открыто или закрыто в данный момент окно родительской подсистемы, RDS будет следить за данной подсистемой &ndash;
  как только окно будет открыто, внутри него будет создано дочернее окно-панель.</li>

  <li>Когда окно подсистемы открывается, RDS создает внутри него оконный объект с указанными моделью
  ранее параметрами и информирует об этом модель блока, передавая ей дескриптор <span class="cpp"><a class="hidden" href="app_ids.htm#light_ref18" title="Дескриптор окна">HWND</a></span>
  этого объекта. В этот момент модель может создать внутри указанного объекта все необходимые ей
  органы управления, поля ввода и т.п.</li>

  <li>Если при создании панели модель разрешила пользователю перемещать панель или изменять ее размеры,
  она будет получать уведомления об этих событиях. Также, если это было разрешено, RDS будет информировать ее
  о получении оконным объектом сообщения <span class="cpp"><span id="light_ref2">WM_PAINT</span></span>,
  то есть о необходимости перерисовки содержимого.</li>

  <li>При закрытии окна подсистемы RDS сообщит модели о том, что оконный объект сейчас будет уничтожен.
  В этот момент модель должна уничтожить все органы управления, которые она поместила туда при создании объекта.
  После закрытия окна RDS снова будет следить за подсистемой, чтобы при очередном открытии окна создать объект
  и передать модели его идентификатор.</li>

  <li>Если панель больше не нужна модели, она удаляет созданный вспомогательный объект функцией
  <span class="cpp"><a href="rdsDeleteObject.htm" title="А.5.22.4. rdsDeleteObject &ndash; удалить объект">rdsDeleteObject</a></span>, что автоматически приводит к удалению панели. После этого
  RDS перестает следить за окном подсистемы.</li>
</ul>

<p class="noindent">Модель блока также может скрывать и показывать панель, не удаляя вспомогательный
объект RDS. При скрытии панели связанный с ней оконный объект уничтожается (о чем, как обычно,
RDS сообщает модели блока), а при показе &ndash; снова создается. Часто бывает удобно создать
объект-панель в момент подключения модели к блоку (например, в конструкторе класса
<a href="pm_1_4.htm#ref8" title="Личная область данных блока">личной области данных</a>, если используется C++), но не показывать
эту панель немедленно &ndash; функция <span class="cpp"><a class="hidden" href="rdsPANCreate.htm" title="А.5.31.1. rdsPANCreate &ndash; создать объект для работы с панелью">rdsPANCreate</a></span> предоставляет такую возможность.
Панель будет показана пользователю позже, когда возникнет такая необходимость. Затем она может быть снова
скрыта, вновь показана и т.д. При этом все параметры панели (положение, размер и т.п.) сохраняются во
вспомогательном объекте, поэтому их не нужно устанавливать заново при каждом показе панели. Уничтожение
вспомогательного объекта в этом случае целесообразно производить в момент отключения модели от блока &ndash;
если панель в этот момент видима, она автоматически закроется.</p>

<p>Размещение стандартных органов управления Windows на панелях в окне подсистемы может показаться более удобным,
чем программное рисование этих же органов и реализация функций редактирования (если они нужны)
силами самой модели блока, однако, у этого метода есть и недостатки &ndash; при выводе подсистемы на
<a href="um_2_21_1.htm" title="&sect;2.21.1. Задание зоны печати подсистемы">печать</a> (или <a href="um_2_3.htm#ref13" title="Сохранение растрового рисунка">сохранении ее графического образа</a>
в виде растрового рисунка) панели, являющиеся отдельными оконными
объектами, изображаться не будут. Точно так же они не будут отображаться в
<a href="pm_3_6_1.htm" title="&sect;3.6.1. Общие принципы работы с портом вывода">портах вывода</a> при работе RDS под управлением внешнего приложения.</p>

<p><span id="ref3">В</span>
<span id="ref4">качестве</span>
примера рассмотрим <span id="light_ref3">блок, выводящий трехмерное изображение</span>
средствами
<a href="https://www.opengl.org/">библиотеки <span id="light_ref4">OpenGL</span></a>.
Для того, чтобы с ее помощью отображать трехмерные сцены в Windows,
нужно знать дескриптор окна, в которое будет осуществляться вывод. Конечно, модель блока может открыть отдельное
окно средствами Windows API и рисовать в нем трехмерные изображения, но при этом это окно не будет
привязано к подсистеме и будет перемещаться независимо от ее окна. Это будет не очень хорошо выглядеть,
если подсистема имитирует какой-либо пульт управления, а трехмерные изображения являются частью одного из
приборов. При перетаскивании окна такой подсистемы или изменении его масштаба пульт будет
&laquo;разваливаться&raquo; на отдельные окна. Чтобы избежать этого, будем выводить трехмерные сцены
на панель блока внутри окна подсистемы.</p>

<p>Для большей ясности примера сначала сделаем модель, которая создает панель в окне подсистемы, но ничего в
ней не рисует, а потом добавим в эту модель функции построения трехмерного изображения. Такая
&laquo;скелетная&raquo; модель позволит сосредоточиться на функциях работы с панелями и оставить пока
в стороне тонкости OpenGL.</p>

<p>Новую модель имеет смысл разместить в отдельной DLL, а не дописывать к уже имеющимся. В дальнейшем нам придется
включить дополнительные описания для работы с OpenGL, и нет смысла перегружать ими модели, не работающие с
трехмерными сценами. Главная функция DLL этой модели не будет отличаться от уже рассмотренных ранее:</p>

<pre class="cpp">  <span class="preproc">#include &lt;windows.h&gt;</span>
  <span class="preproc">#include &lt;RdsDef.h&gt;</span>
  <span class="rem">// Подготовка описаний сервисных функций</span>
  <a class="hidden" href="pm_2_2.htm#ref11" title="Использование RdsFunc.h"><span class="preproc">#define RDS_SERV_FUNC_BODY GetInterfaceFunctions</span></a>
  <span class="preproc">#include &lt;RdsFunc.h&gt;</span>
  <span class="rem">// Глобальная переменная для значения ошибки</span>
  <span class="kw">double</span> <a class="hidden" href="pm_2_5_1.htm#ref12" title="Проверка вещественного числа на признак ошибки">DoubleErrorValue</a>;
  <span class="rem">//========== </span><a class="hidden" href="pm_2_2.htm" title="&sect;2.2. Главная функция DLL и файлы заголовков"><span class="rem">Главная функция DLL</span></a><span class="rem"> ==========</span>
  <span class="kw">int</span> WINAPI <a class="hidden" href="pm_2_2.htm#ref8" title="Главная функция DLL">DllEntryPoint</a>(<a class="hidden" href="app_ids.htm#light_ref17" title="Дескриптор модуля">HINSTANCE</a> <span class="rem">/*hinst*/</span>,
                           <span class="kw">unsigned</span> <span class="kw">long</span> reason,
                           <span class="kw">void</span>* <span class="rem">/*lpReserved*/</span>)
  { <span class="kw">if</span>(reason==DLL_PROCESS_ATTACH) <span class="rem">// Загрузка DLL</span>
      { <span class="rem">// Получение доступа к функциям</span>
        <span class="kw">if</span>(!GetInterfaceFunctions())
          MessageBox(NULL,<span class="str">"Нет доступа к функциям"</span>,<span class="str">"Ошибка"</span>,MB_OK);
        <span class="kw">else</span>
          <a class="hidden" href="rdsGetHugeDouble.htm" title="А.5.2.22. rdsGetHugeDouble &ndash; получение значения-индикатора математической ошибки">rdsGetHugeDouble</a>(&amp;<a class="hidden" href="pm_2_5_1.htm#ref12" title="Проверка вещественного числа на признак ошибки">DoubleErrorValue</a>);
      }
    <span class="kw">return</span> <span class="const">1</span>;
  }
  <span class="rem">//========= Конец главной функции =========</span></pre>

<p>Поскольку в процессе работы модели блока будет создана панель, идентификатор этой панели, возвращаемый функцией
<span class="cpp"><a class="hidden" href="rdsPANCreate.htm" title="А.5.31.1. rdsPANCreate &ndash; создать объект для работы с панелью">rdsPANCreate</a></span>, нужно где-то хранить. Кроме того, для регулярного обновления панели
в процессе расчета потребуется <a href="pm_2_9_1.htm" title="&sect;2.9.1. Таймеры в RDS">таймер</a>
(в отличие от самого окна подсистемы,
<a href="um_2_11_4.htm#ref4" title="Обновление окна подсистемы">обновляемого при расчете</a>
с заданным интервалом, панели в ней автоматически не перерисовываются &ndash; модель блока должна делать
это сама при необходимости). Идентификатор панели и идентификатор таймера, который создаст модель,
будут храниться в личной области данных блока, которую мы оформим как класс C++:</p>

<pre class="cpp">  <span class="rem">//=================================================</span>
  <span class="rem">// Личная область данных блока</span>
  <span class="rem">//=================================================</span>
  <span class="kw">class</span> TOpenGLInstr
  { <span class="kw">private</span>:
      <span id="light_ref5"><a class="hidden" href="app_ids.htm#light_ref3" title="Идентификатор таймера">RDS_TIMERID</a></span> RefreshTimer; <span class="rem">// Таймер обновления</span>

    <span class="kw">public</span>:
      <a class="hidden" href="app_ids.htm#light_ref6" title="Идентификатор вспомогательного объекта">RDS_HOBJECT</a> Panel;        <span class="rem">// Объект-панель</span>

      <span class="rem">// Сохранение параметров блока</span>
      <span class="kw">void</span> SaveText(<span class="kw">void</span>);
      <span class="rem">// Загрузка параметров блока</span>
      <span class="kw">void</span> LoadText(<span class="kw">char</span> *text);

      <span class="rem">// Создание таймера обновления</span>
      <span class="kw">void</span> CreateRefreshTimer(<a class="hidden" href="app_ids.htm#light_ref1" title="Идентификатор блока">RDS_BHANDLE</a> parent);

      <span class="rem">// Конструктор класса</span>
      TOpenGLInstr(<span class="kw">void</span>);
      <span class="rem">// Деструктор класса</span>
      ~TOpenGLInstr();
  };
  <span class="rem">//=================================================</span></pre>

<p>В закрытой области класса (<span class="cpp">private</span>) размещаются поля и функции класса, к
которым не нужен доступ снаружи этого класса, то есть из функции модели блока. В данном случае это
идентификатор таймера обновления <span class="cpp">RefreshTimer</span>. В открытой области
(<span class="cpp">public</span>) расположено поле <span class="cpp">Panel</span> для хранения идентификатора
созданной панели, а также функции, которые будут вызываться непосредственно из модели блока. Чтобы
положение и размер панели, созданной блоком, не терялись при сохранении и последующей загрузке схемы,
будем записывать и загружать их функциями <span class="cpp">SaveText</span> и
<span class="cpp">LoadText</span> соответственно. Создание таймера обновления панели также вынесем в
отдельную функцию-член класса <span class="cpp">CreateRefreshTimer</span> (удаление
таймера будет происходить в деструкторе).</p>

<p>Создавать панель мы будем в конструкторе класса, то есть в момент присоединения модели к блоку
(при загрузке схемы или добавлении в схему блока с этой моделью из библиотеки блоков):</p>

<pre class="cpp">  <span class="rem">// Конструктор класса личной области данных</span>
  TOpenGLInstr::TOpenGLInstr(<span class="kw">void</span>)
  { <span class="rem">// Создаем панель в окне подсистемы</span>
    Panel=<span id="light_ref6"><a class="hidden" href="rdsPANCreate.htm" title="А.5.31.1. rdsPANCreate &ndash; создать объект для работы с панелью">rdsPANCreate</a></span>(<span class="const">0</span>,<span class="const">0</span>,<span class="const">0</span>,<span class="const">300</span>,<span class="const">300</span>,
                       <span id="light_ref7"><a class="hidden" href="rdsPANCreate.htm#light_ref8" title="RDS_PAN_F_SCALABLE">RDS_PAN_F_SCALABLE</a></span>|<span id="light_ref8"><a class="hidden" href="rdsPANCreate.htm#light_ref2" title="RDS_PAN_F_BORDER">RDS_PAN_F_BORDER</a></span>|
                       <span id="light_ref9"><a class="hidden" href="rdsPANCreate.htm#light_ref9" title="RDS_PAN_F_SIZEABLE">RDS_PAN_F_SIZEABLE</a></span>|<span id="light_ref10"><a class="hidden" href="rdsPANCreate.htm#light_ref5" title="RDS_PAN_F_MOVEABLE">RDS_PAN_F_MOVEABLE</a></span>|
                       <span id="light_ref11"><a class="hidden" href="rdsPANCreate.htm#light_ref3" title="RDS_PAN_F_CAPTION">RDS_PAN_F_CAPTION</a></span>|<span id="light_ref12"><a class="hidden" href="rdsPANCreate.htm#light_ref4" title="RDS_PAN_F_HIDDEN">RDS_PAN_F_HIDDEN</a></span>|
                       <span id="light_ref13"><a class="hidden" href="rdsPANCreate.htm#light_ref7" title="RDS_PAN_F_PAINTMSG">RDS_PAN_F_PAINTMSG</a></span>,
                       <span class="str">"Прибор"</span>);
    <span class="rem">// Инициализируем идентификатор еще не созданного таймера</span>
    RefreshTimer=NULL;
  }
  <span class="rem">//=================================================</span></pre>

<p>Первой же командой конструктора создается объект-панель, и его идентификатор присваивается полю класса
<span class="cpp">Panel</span>. Для создания объекта используется функция
<span class="cpp"><a class="hidden" href="rdsPANCreate.htm" title="А.5.31.1. rdsPANCreate &ndash; создать объект для работы с панелью">rdsPANCreate</a></span>:</p>

<pre class="cpp">  <a class="hidden" href="app_ids.htm#light_ref6" title="Идентификатор вспомогательного объекта">RDS_HOBJECT</a> <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> <a class="hidden" href="rdsPANCreate.htm" title="А.5.31.1. rdsPANCreate &ndash; создать объект для работы с панелью">rdsPANCreate</a>(
    <span class="kw">int</span> order,        <span class="rem">// Близость панели к переднему плану</span>
    <span class="kw">int</span> left,<span class="kw">int</span> top, <span class="rem">// Верхний левый угол панели</span>
    <span class="kw">int</span> width,        <span class="rem">// Ширина панели</span>
    <span class="kw">int</span> height,       <span class="rem">// Высота панели</span>
    <span class="kw">int</span> flags,        <span class="rem">// Флаги</span>
    <a class="hidden" href="app_ids.htm#light_ref20" title="Указатель на строку (char*)">LPSTR</a> caption     <span class="rem">// Заголовок панели</span>
  );</pre>

<p>Параметр <span class="cpp">order</span> определяет близость панели к переднему плану &ndash; панели одного
и того же блока с большим значением <span class="cpp">order</span> будут перекрывать панели с
меньшим значением. Перекрытие панелей разных блоков определяется взаимным расположением самих блоков,
то есть если блок A расположен в окне подсистемы ближе к переднему плану, чем блок B, все панели блока A
будут перекрывать панели блока B, независимо от того, с каким значением параметра <span class="cpp">order</span>
эти панели были созданы. При этом панели блока A с <span class="cpp">order=10</span> будут перекрывать панели
этого же блока со значением <span class="cpp">order=5</span>. Если блок создает единственную панель,
как в нашем случае, значение параметра <span class="cpp">order</span> может быть любым, поскольку от
него ничего не зависит.</p>

<p>Параметры <span class="cpp">left</span>, <span class="cpp">top</span>, <span class="cpp">width</span> и
<span class="cpp">height</span> задают положение левого верхнего угла панели и ее размеры в
координатах рабочей области подсистемы. Значения ширины и высоты указываются для масштаба 100%. Будет
ли размер панели изменяться в соответствии с масштабом окна подсистемы, или ее размер в точках экрана
будет оставаться неизменным, определяется одним из флагов в параметре <span class="cpp">flags</span>.</p>

<p>Параметр <span class="cpp">flags</span> содержит один или несколько битовых флагов, определяющих
внешний вид и поведение панели:</p>

<ul>
  <li><span class="cpp"><a href="rdsPANCreate.htm#light_ref8" title="RDS_PAN_F_SCALABLE">RDS_PAN_F_SCALABLE</a></span> &ndash; если указан этот флаг, размер панели будет
  меняться синхронно с изменением масштаба в окне подсистемы. Это удобно для блоков, выводящих на панель
  какую-либо абстрактную графику (как в нашем случае), но, обычно, нежелательно для блоков, размещающих
  в панели какие-либо поля ввода и органы управления. Как правило, размер поля ввода должен
  оставаться постоянным, иначе оно может стать слишком мелким для комфортной работы с ним. Если
  размер панели с полем ввода будет меняться, а размер самого поля &ndash; нет, в мелких масштабах
  поле просто не уместится в панель, а в крупных поле займет только верхний левый угол панели,
  большая часть которой будет закрывать рабочее поле окна безо всякого смысла.</li>

  <li><span class="cpp"><a href="rdsPANCreate.htm#light_ref2" title="RDS_PAN_F_BORDER">RDS_PAN_F_BORDER</a></span> &ndash; если указать этот флаг, панель будет иметь вокруг
  себя рельефную рамку. Панель с рамкой визуально выделяется на рабочем поле системы, что, как правило,
  и требуется. Однако, если необходимо создать сложное изображение, разместив рядом несколько панелей и блоков,
  рамку лучше не включать, чтобы панели, расположенные рядом, воспринимались как единое целое. При
  одинаковых размерах, панель с рамкой имеет несколько меньшую площадь, доступную блоку, чем панель без рамки,
  поскольку параметры <span class="cpp">width</span> и <span class="cpp">height</span> задают внешние, с
  учетом рамки, размеры панели. Следует также помнить, что RDS поддерживает перемещение панели пользователем
  и изменение ее размеров только для панелей с рамками. Если необходимо дать пользователю возможность
  перемещать панель без рамки, разработчик модели блока должен заложить такую возможность самостоятельно,
  например, разместив на панели собственный оконный объект Windows и реагируя на перемещения курсора в
  его пределах.</li>

  <li><span class="cpp"><a href="rdsPANCreate.htm#light_ref3" title="RDS_PAN_F_CAPTION">RDS_PAN_F_CAPTION</a></span> &ndash; флаг указывает на наличие у панели заголовка с
  названием в стиле окон Windows. Текст названия панели при этом задается параметром <span class="cpp">caption</span>.
  Заголовок могут иметь только панели с рамкой. Он также используется для перемещения панели пользователем,
  если это разрешено (пользователь &laquo;перетаскивает&raquo; панель за заголовок левой кнопкой мыши,
  как обычное окно Windows), поэтому, если необходимо дать пользователю возможность перемещать панель,
  заголовок нужно включить.</li>

  <li><span class="cpp"><a href="rdsPANCreate.htm#light_ref5" title="RDS_PAN_F_MOVEABLE">RDS_PAN_F_MOVEABLE</a></span> &ndash; панель может перемещаться пользователем (только
  при наличии у нее рамки и заголовка). При этом модель блока уведомляется о новом положении панели.</li>

  <li><span class="cpp"><a href="rdsPANCreate.htm#light_ref9" title="RDS_PAN_F_SIZEABLE">RDS_PAN_F_SIZEABLE</a></span> &ndash; размер панели может изменяться пользователем (только
  при наличии у нее рамки). Изменение размера панели производится точно так же, как и обычного окна Windows
  &ndash; перетаскивается один из углов или одна из сторон рамки. Модель блока при этом уведомляется о
  новом размере панели.</li>

  <li><span class="cpp"><span id="light_ref14"><a href="rdsPANCreate.htm#light_ref6" title="RDS_PAN_F_NOBUTTON">RDS_PAN_F_NOBUTTON</a></span></span> &ndash; в заголовке панели нет кнопки закрытия.
  По умолчанию эта кнопка, как и в обычных окнах Windows, расположена в крайней правой части полосы
  заголовка, нажатие на нее приводит к закрытию панели. Естественно, у панелей без заголовка этой кнопки нет,
  и пользователь не может самостоятельно закрыть их &ndash; соответствующие функции должна обеспечить модель
  блока.</li>

  <li><span class="cpp"><a href="rdsPANCreate.htm#light_ref4" title="RDS_PAN_F_HIDDEN">RDS_PAN_F_HIDDEN</a></span> &ndash; панель скрыта от пользователя. Если указан этот флаг,
  функция <span class="cpp"><a class="hidden" href="rdsPANCreate.htm" title="А.5.31.1. rdsPANCreate &ndash; создать объект для работы с панелью">rdsPANCreate</a></span> создаст внутренний объект RDS для работы с панелью,
  но сама панель в окне подсистемы не появится до тех пор, пока модель блока не скомандует показать ее,
  вызвав одну из сервисных функций.</li>

  <li><span class="cpp"><a href="rdsPANCreate.htm#light_ref7" title="RDS_PAN_F_PAINTMSG">RDS_PAN_F_PAINTMSG</a></span> &ndash; модель блока получает уведомления о необходимости перерисовки
  содержимого панели. Если на панели размещены какие-либо объекты Windows, в этом нет необходимости &ndash;
  таким объектам не нужно сообщать о перерисовке, они сами получают сообщение Windows
  <span class="cpp">WM_PAINT</span> и могут отреагировать на него. В нашем же случае мы не будем размещать
  что-либо на панели, вместо этого, мы свяжем с ней область вывода OpenGL. Поскольку оконный объект,
  связанный с панелью, создается и обслуживается RDS, модель не может вмешаться в его работу и перехватить
  поступившее ему от операционной системы сообщение о перерисовке. Вместо этого она может указать при создании
  панели флаг <span class="cpp"><a class="hidden" href="rdsPANCreate.htm#light_ref7" title="RDS_PAN_F_PAINTMSG">RDS_PAN_F_PAINTMSG</a></span>, и RDS будет транслировать ей эти сообщения.</li>
</ul>

<p class="noindent">В этом примере в вызове <span class="cpp"><a class="hidden" href="rdsPANCreate.htm" title="А.5.31.1. rdsPANCreate &ndash; создать объект для работы с панелью">rdsPANCreate</a></span> указаны все флаги, кроме
<span class="cpp"><a class="hidden" href="rdsPANCreate.htm#light_ref6" title="RDS_PAN_F_NOBUTTON">RDS_PAN_F_NOBUTTON</a></span>. Модель создает скрытую панель с рамкой, заголовком
&laquo;прибор&raquo; и кнопкой закрытия, причем размер и положение панели пользователь сможет, при
желании, изменять. Модель блока будет получать уведомления о необходимости перерисовки панели.</p>

<p>В конце конструктора полю класса <span class="cpp">RefreshTimer</span>, предназначенному для хранения
идентификатора таймера для обновления панели в процессе расчета, присваивается нулевое значение &ndash;
таймер пока не нужен, он будет создан позднее. </p>

<p>Деструктор класса будет включать всего два вызова: удаление созданного объекта-панели функцией
<span class="cpp"><a href="rdsDeleteObject.htm" title="А.5.22.4. rdsDeleteObject &ndash; удалить объект">rdsDeleteObject</a></span> и удаление таймера обновления панели (если он был создан в процессе
работы блока) функцией <span class="cpp"><a href="rdsDeleteBlockTimer.htm" title="А.5.12.1. rdsDeleteBlockTimer &ndash; удалить таймер">rdsDeleteBlockTimer</a></span>:</p>

<pre class="cpp">  <span class="rem">// Деструктор класса личной области данных</span>
  TOpenGLInstr::~TOpenGLInstr()
  { <span class="rem">// Удаление панели</span>
    <span class="kw">if</span>(Panel)
      <span class="cpp"><span id="light_ref15"><a class="hidden" href="rdsDeleteObject.htm" title="А.5.22.4. rdsDeleteObject &ndash; удалить объект">rdsDeleteObject</a></span></span>(Panel);
    <span class="rem">// Удаление таймера</span>
    <span class="kw">if</span>(RefreshTimer)
      <span class="cpp"><span id="light_ref16"><a class="hidden" href="rdsDeleteBlockTimer.htm" title="А.5.12.1. rdsDeleteBlockTimer &ndash; удалить таймер">rdsDeleteBlockTimer</a></span></span>(RefreshTimer);
  }
  <span class="rem">//=================================================</span></pre>

<p>Теперь напишем функцию <span class="cpp">CreateRefreshTimer</span>, которая будет создавать таймер для
обновления панели или настраивать его параметры, если таймер уже создан (почему мы не создаем таймер
в конструкторе блока, будет объяснено
<a href="#ref51" title="Почему тайсер не создается в конструкторе">позднее</a>). Эта функция будет вызываться при запуске расчета.
Пока расчет не запущен, у нас нет необходимости обновлять панель с заданной частотой &ndash;
если панель будет перекрыта другим окном, а потом снова появится на переднем плане, Windows автоматически
пошлет ей сообщение о необходимости перерисовки, которое будет передано в модель блока, поскольку
при создании панели был указан флаг <span class="cpp"><a class="hidden" href="rdsPANCreate.htm#light_ref7" title="RDS_PAN_F_PAINTMSG">RDS_PAN_F_PAINTMSG</a></span>. Если же не обновлять
панель во время расчета, изображение блока никак не будет реагировать на изменение входных переменных &ndash;
пока панель не перекрыта другими окнами и не изменяет свой размер, никаких сообщений о перерисовке
она не получает. Можно, конечно, обновлять панель при каждом срабатывании модели блока, но это
было бы неоправданной тратой вычислительных ресурсов. Перерисовка окон &ndash; одна из самых длительных
процедур, и выполнение ее в каждом
такте <a href="pm_1_3.htm#ref3" title="Режим расчета">расчета</a> приведет к существенному замедлению работы всей системы.
Тем более, что такое частое обновление просто не нужно &ndash; обычно для достижения вполне приемлемого качества
мультипликации достаточно перерисовывать изображение не чаще десяти раз в секунду.</p>

<p>В данном случае в момент запуска расчета мы средствами RDS создадим таймер, который с заданной
периодичностью будет вызывать модель блока в режиме
<span class="cpp"><span id="light_ref17"><a href="RDS_BFM_WINREFRESH.htm" title="А.2.6.21. RDS_BFM_WINREFRESH &ndash; обновление окон блока">RDS_BFM_WINREFRESH</a></span></span>. Этот режим вызова специально предназначен для того,
чтобы сообщать блоку о необходимости перерисовки всех окон и панелей, которыми он владеет. В реакции на
этот вызов мы, со временем, будем перерисовывать трехмерное изображение на панели. В качестве интервала
срабатывания таймера возьмем интервал автоматического обновления окна подсистемы, в которой находится блок.
Это логично &ndash; панель будет находиться в этом же окне, и будет обновляться с той же
частотой, что и содержимое этого окна. Таким образом, функция создания таймера будет иметь вид:</p>

<pre class="cpp">  <span class="rem">// Создание таймера обновления панели</span>
  <span class="kw">void</span> TOpenGLInstr::CreateRefreshTimer(<a class="hidden" href="app_ids.htm#light_ref1" title="Идентификатор блока">RDS_BHANDLE</a> parent)
  { <span class="rem">// Структура для получения параметров окна подсистемы</span>
    <span id="light_ref18"><a class="hidden" href="RDS_EDITORPARAMETERS.htm#ref1" title="Структура RDS_EDITORPARAMETERS">RDS_EDITORPARAMETERS</a></span> WinParams;
    <span class="rem">// Определение интервала обновления окна подсистемы</span>
    WinParams.servSize=<span class="kw">sizeof</span>(<a class="hidden" href="RDS_EDITORPARAMETERS.htm#ref1" title="Структура RDS_EDITORPARAMETERS">RDS_EDITORPARAMETERS</a>);
    rdsGetEditorParameters(parent,&WinParams);
    <span class="rem">// Интервал - в WinParams.RefreshDelay</span>

    <span class="rem">// Создание таймера</span>
    RefreshTimer=<span id="light_ref19"><a class="hidden" href="rdsSetBlockTimer.htm" title="А.5.12.4. rdsSetBlockTimer &ndash; создать таймер">rdsSetBlockTimer</a></span>(RefreshTimer, <span class="rem">// Идентификатор</span>
                   WinParams.RefreshDelay,      <span class="rem">// Интервал</span>
                   <span id="light_ref20"><a class="hidden" href="RDS_TIMERDESCRIPTION.htm#light_ref4" title="RDS_TIMERM_LOOP">RDS_TIMERM_LOOP</a></span> | <span id="light_ref21"><a class="hidden" href="RDS_TIMERDESCRIPTION.htm#light_ref9" title="RDS_TIMERS_WINREF">RDS_TIMERS_WINREF</a></span> |
                   <span id="light_ref22"><a class="hidden" href="RDS_TIMERDESCRIPTION.htm#light_ref11" title="RDS_TIMERF_FIXFREQ">RDS_TIMERF_FIXFREQ</a></span>,          <span class="rem">// Режим и флаги</span>
                   TRUE);                       <span class="rem">// Запустить таймер</span>
  }
  <span class="rem">//=================================================</span></pre>

<p>В функцию передается единственный параметр &ndash; идентификатор родительской подсистемы блока <span class="cpp">parent</span>,
интервал обновления которой будет использован при создании таймера. Этот идентификатор содержится в
структуре <span class="cpp"><a class="hidden" href="RDS_BLOCKDATA.htm#ref3" title="Структура RDS_BLOCKDATA">RDS_BLOCKDATA</a></span>, указатель на которую передается в модель
блока при каждом вызове, поэтому получение его внутри модели не представляет трудностей. Интервал обновления
можно получить вместе с другими параметрами окна подсистемы сервисной функцией
<span class="cpp"><a href="rdsGetEditorParameters.htm" title="А.5.8.6. rdsGetEditorParameters &ndash; получить описание окна подсистемы">rdsGetEditorParameters</a></span>. В эту функцию передается идентификатор подсистемы
(<span class="cpp">parent</span>) и указатель на структуру типа
<span class="cpp"><a href="RDS_EDITORPARAMETERS.htm#ref1" title="Структура RDS_EDITORPARAMETERS">RDS_EDITORPARAMETERS</a></span>, в которую функция записывает все параметры окна указанной
подсистемы. Как и большинство сервисных функций RDS, работающих со структурами, функция
<span class="cpp"><a class="hidden" href="rdsGetEditorParameters.htm" title="А.5.8.6. rdsGetEditorParameters &ndash; получить описание окна подсистемы">rdsGetEditorParameters</a></span> проверяет соответствие поля <span class="cpp">servSize</span>
переданной структуры ожидаемому размеру этой структуры, и отказывается работать в случае, если ожидаемый
размер окажется больше. Это, в большинстве случаев, позволяет предотвратить фатальные сбои и ошибки общей защиты
при ошибке разработчика модели, передавшего в функцию неправильный указатель. Таким образом, чтобы функция
<span class="cpp"><a class="hidden" href="rdsGetEditorParameters.htm" title="А.5.8.6. rdsGetEditorParameters &ndash; получить описание окна подсистемы">rdsGetEditorParameters</a></span> сработала, перед ее вызовом неободимо присвоить полю
<span class="cpp">servSize</span> передаваемой структуры размер этой структуры, то есть
<span class="cpp">sizeof(<a class="hidden" href="RDS_EDITORPARAMETERS.htm#ref1" title="Структура RDS_EDITORPARAMETERS">RDS_EDITORPARAMETERS</a>)</span>. После вызова функции
структура будет заполнена различными параметрами подсистемы &ndash; размерами и положением окна, числом слоев,
цветами и т.п., но нас будет интересовать только поле <span class="cpp">RefreshDelay</span> &ndash; интервал
автоматического обновления окна в миллисекундах. Этот параметр и используется при вызове функции
<span class="cpp"><a href="rdsSetBlockTimer.htm" title="А.5.12.4. rdsSetBlockTimer &ndash; создать таймер">rdsSetBlockTimer</a></span> для создания таймера. Таймер будет циклическим
(константа <span class="cpp"><a href="RDS_TIMERDESCRIPTION.htm#light_ref4" title="RDS_TIMERM_LOOP">RDS_TIMERM_LOOP</a></span>), вызывать модель в режиме
<span class="cpp"><a class="hidden" href="RDS_BFM_WINREFRESH.htm" title="А.2.6.21. RDS_BFM_WINREFRESH &ndash; обновление окон блока">RDS_BFM_WINREFRESH</a></span> (константа <span class="cpp"><a href="RDS_TIMERDESCRIPTION.htm#light_ref9" title="RDS_TIMERS_WINREF">RDS_TIMERS_WINREF</a></span>) и его
частота не будет снижаться при слишком больших задержках обновления окна (константа
<span class="cpp"><a href="RDS_TIMERDESCRIPTION.htm#light_ref11" title="RDS_TIMERF_FIXFREQ">RDS_TIMERF_FIXFREQ</a></span>), поскольку сейчас для нас плавность анимации важнее экономии
вычислительных ресурсов. Таймер сразу создается активным (последний параметр функции &ndash;
<span class="cpp">TRUE</span>), но считать он будет только в режиме расчета. Можно заметить, что первый
параметр функции &ndash; идентификатор таймера <span class="cpp">RefreshTimer</span>, а не
<span class="cpp">NULL</span>, как в  моделях с таймерами, рассмотренных
<a href="pm_2_9_2.htm#ref1" title="Пример мигающего блока">ранее</a>. Это сделано для того, чтобы функцию
<span class="cpp">CreateRefreshTimer</span> можно было вызывать и в том случае, если таймер уже создан.
Если таймера еще нет, поле класса <span class="cpp">RefreshTimer</span> будет иметь значение <span class="cpp">NULL</span>,
и функция создаст новый таймер. Если же таймер уже создан, <span class="cpp">RefreshTimer</span> будет содержать его
идентификатор, и вызов <span class="cpp"><a class="hidden" href="rdsSetBlockTimer.htm" title="А.5.12.4. rdsSetBlockTimer &ndash; создать таймер">rdsSetBlockTimer</a></span> изменит параметры существующего таймера.
Таким образом, перед вызовом функции <span class="cpp">CreateRefreshTimer</span> не обязательно удалять таймер &ndash;
это упрощает программу и предохраняет от возможных ошибок.</p>

<p>Разобравшись с созданием таймера, напишем функции сохранения и загрузки положения и размера панели.
Будем хранить данные блока в
<a href="pm_2_8_5.htm" title="&sect;2.8.5. Сохранение параметров блока в формате INI-файла">формате INI-файла</a> Windows, то есть в виде строк
&laquo;<i>ключевое_слово</i>=<i>значение</i>&raquo;. Начнем с функции сохранения параметров:</p>

<pre class="cpp">  <span class="rem">// Функция сохранения параметров блока</span>
  <span class="kw">void</span> TOpenGLInstr::SaveText(<span class="kw">void</span>)
  { <a class="hidden" href="app_ids.htm#light_ref6" title="Идентификатор вспомогательного объекта">RDS_HOBJECT</a> ini; <span class="rem">// Идентификатор вспомогательного объекта</span>

    <span class="rem">// При сохранении блока в отдельный файл на диске параметры</span>
    <span class="rem">// панели записывать не нужно</span>
    <span class="kw">if</span>(<span id="light_ref23"><a class="hidden" href="rdsGetSystemInt.htm" title="А.5.2.24. rdsGetSystemInt &ndash; получить целый системный параметр">rdsGetSystemInt</a></span>(<span id="light_ref24"><a class="hidden" href="rdsGetSystemInt.htm#light_ref6" title="RDS_GSISAVELOADACTION">RDS_GSISAVELOADACTION</a></span>)==<span id="light_ref25"><a class="hidden" href="rdsGetSystemInt.htm#light_ref20" title="RDS_LS_SAVETOFILE">RDS_LS_SAVETOFILE</a></span>)
      <span class="kw">return</span>;

    <span class="rem">// Создание вспомогательного объекта для работы с данными</span>
    ini=<span id="light_ref26"><a class="hidden" href="rdsINICreateTextHolder.htm" title="А.5.27.1. rdsINICreateTextHolder &ndash; создать объект для работы с текстом">rdsINICreateTextHolder</a></span>(TRUE);

    <span class="rem">// Параметры записываются в секцию "[Window]"</span>
    <span id="light_ref27"><a class="hidden" href="rdsSetObjectStr.htm" title="А.5.22.12. rdsSetObjectStr &ndash; установить строку">rdsSetObjectStr</a></span>(ini,<span id="light_ref28"><a class="hidden" href="RDS_HINI_CREATESECTION.htm" title="А.5.27.10. Команда RDS_HINI_CREATESECTION &ndash; создать секцию">RDS_HINI_CREATESECTION</a></span>,<span class="const">0</span>,<span class="str">"Window"</span>);

    <span class="rem">// Получение параметров панели и запись их в объект</span>
    <span id="light_ref29"><a class="hidden" href="rdsINIWriteInt.htm" title="А.5.27.8. rdsINIWriteInt &ndash; установить целое значение параметра">rdsINIWriteInt</a></span>(ini,<span class="str">"Left"</span>,<span id="light_ref30"><a class="hidden" href="rdsGetObjectInt.htm" title="А.5.22.8. rdsGetObjectInt &ndash; получить целое число">rdsGetObjectInt</a></span>(Panel,<span id="light_ref31"><a class="hidden" href="RDS_PAN_LEFT.htm" title="А.5.31.8. Команда RDS_PAN_LEFT &ndash; горизонтальная координата панели">RDS_PAN_LEFT</a></span>,<span class="const">0</span>));
    <a class="hidden" href="rdsINIWriteInt.htm" title="А.5.27.8. rdsINIWriteInt &ndash; установить целое значение параметра">rdsINIWriteInt</a>(ini,<span class="str">"Top"</span>,<a class="hidden" href="rdsGetObjectInt.htm" title="А.5.22.8. rdsGetObjectInt &ndash; получить целое число">rdsGetObjectInt</a>(Panel,<span id="light_ref32"><a class="hidden" href="RDS_PAN_TOP.htm" title="А.5.31.13. Команда RDS_PAN_TOP &ndash; вертикальная координата панели">RDS_PAN_TOP</a></span>,<span class="const">0</span>));
    <a class="hidden" href="rdsINIWriteInt.htm" title="А.5.27.8. rdsINIWriteInt &ndash; установить целое значение параметра">rdsINIWriteInt</a>(ini,<span class="str">"Width"</span>,<a class="hidden" href="rdsGetObjectInt.htm" title="А.5.22.8. rdsGetObjectInt &ndash; получить целое число">rdsGetObjectInt</a>(Panel,<span id="light_ref33"><a class="hidden" href="RDS_PAN_WIDTH.htm" title="А.5.31.15. Команда RDS_PAN_WIDTH &ndash; общая ширина панели">RDS_PAN_WIDTH</a></span>,<span class="const">0</span>));
    <a class="hidden" href="rdsINIWriteInt.htm" title="А.5.27.8. rdsINIWriteInt &ndash; установить целое значение параметра">rdsINIWriteInt</a>(ini,<span class="str">"Height"</span>,<a class="hidden" href="rdsGetObjectInt.htm" title="А.5.22.8. rdsGetObjectInt &ndash; получить целое число">rdsGetObjectInt</a>(Panel,<span id="light_ref34"><a class="hidden" href="RDS_PAN_HEIGHT.htm" title="А.5.31.7. Команда RDS_PAN_HEIGHT &ndash; общая высота панели">RDS_PAN_HEIGHT</a></span>,<span class="const">0</span>));
    <a class="hidden" href="rdsINIWriteInt.htm" title="А.5.27.8. rdsINIWriteInt &ndash; установить целое значение параметра">rdsINIWriteInt</a>(ini,<span class="str">"Visible"</span>,<a class="hidden" href="rdsGetObjectInt.htm" title="А.5.22.8. rdsGetObjectInt &ndash; получить целое число">rdsGetObjectInt</a>(Panel,<span id="light_ref35"><a class="hidden" href="RDS_PAN_VISIBLE.htm" title="А.5.31.14. Команда RDS_PAN_VISIBLE &ndash; видимость панели">RDS_PAN_VISIBLE</a></span>,<span class="const">0</span>));

    <span class="rem">// Сохранение получившегося текста в файл, в который в данный</span>
    <span class="rem">// момент идет запись</span>
    <span id="light_ref36"><a class="hidden" href="rdsCommandObject.htm" title="А.5.22.2. rdsCommandObject &ndash; команда объекту">rdsCommandObject</a></span>(ini,<span id="light_ref37"><a class="hidden" href="RDS_HINI_SAVEBLOCKTEXT.htm" title="А.5.27.16. Команда RDS_HINI_SAVEBLOCKTEXT &ndash; передать текст параметров блока в RDS">RDS_HINI_SAVEBLOCKTEXT</a></span>);

    <span class="rem">// Удаление вспомогательного объекта</span>
    <a class="hidden" href="rdsDeleteObject.htm" title="А.5.22.4. rdsDeleteObject &ndash; удалить объект">rdsDeleteObject</a>(ini);
  }
  <span class="rem">//=================================================</span></pre>

<p>Перед тем, как записывать параметры панели, функция проверяет, из-за чего происходит сохранение блока.
Если блок сохраняется в составе системы, или копируется в буфер обмена (что тоже вызывает сохранение его
параметров), пользователь ожидает, что после загрузки схемы или вставки блока панель появится на
том же самом месте, на котором она находилась раньше. Поэтому в этих случаях положение, размер и
видимость панели необходимо сохранять. Если же блок записывается в отдельный файл, например, при создании
библиотеки блоков, он, вероятнее всего, будет загружен в совершенно другую систему. В этом случае сохранять
параметры панели бессмысленно &ndash; возможно, ее текущее положение вообще находится за пределами рабочей области
подсистемы, в которую будет вставлен блок.</p>

<p>Для получения информации о том, куда в данный момент сохраняется блок, используется сервисная функция
<span class="cpp"><a href="rdsGetSystemInt.htm" title="А.5.2.24. rdsGetSystemInt &ndash; получить целый системный параметр">rdsGetSystemInt</a></span> с параметром <span class="cpp"><a href="rdsGetSystemInt.htm#light_ref6" title="RDS_GSISAVELOADACTION">RDS_GSISAVELOADACTION</a></span>. Эта функция
предназначена для получения различных глобальных параметров RDS, в данном случае она возвращает целое
число, характеризующее выполняющуюся в данный момент операцию сохранения или загрузки. Нас интересует
сохранение блока в файл, поэтому возвращаемое значение сравнивается с константой
<span class="cpp"><a href="rdsGetSystemInt.htm#light_ref20" title="RDS_LS_SAVETOFILE">RDS_LS_SAVETOFILE</a></span>, и, в случае равенства, функция завершается &ndash;
ничего сохранять не надо. В противном случае функцией <span class="cpp"><a href="rdsINICreateTextHolder.htm" title="А.5.27.1. rdsINICreateTextHolder &ndash; создать объект для работы с текстом">rdsINICreateTextHolder</a></span>
(см. пример в <a href="pm_2_8_5.htm#ref1" title="Пример сохранения параметров блока в формате INI-файла">&sect;2.8.5</a>) создается вспомогательный объект RDS
для работы с текстом, после чего в нем создается секция &laquo;Window&raquo;. Далее функциями
<span class="cpp"><a href="rdsINIWriteInt.htm" title="А.5.27.8. rdsINIWriteInt &ndash; установить целое значение параметра">rdsINIWriteInt</a></span> в эту секцию записываются пять целых параметров: координаты
левого верхнего угла панели, ее ширина, высота и видимость (1 &ndash; для видимой панели, 0
&ndash; для скрытой). Параметры читаются непосредственно из объекта-панели <span class="cpp">Panel</span>,
который был создан в конструкторе личной области данных блока, при помощи функций
<span class="cpp"><a href="rdsGetObjectInt.htm" title="А.5.22.8. rdsGetObjectInt &ndash; получить целое число">rdsGetObjectInt</a></span> с соответствующими параметрами. Независимо от того, видима ли
панель в окне подсистемы и открыто ли вообще окно этой подсистемы, объект будет хранить параметры панели,
и их можно считывать и устанавливать стандартными функциями для взаимодействия со вспомогательными объектами
RDS. После того, как текст с параметрами панели сформирован во вспомогательном объекте,
он сбрасывается туда, куда в данный момент идет запись (в файл, буфер обмена и т.д.), после чего
объект уничтожается и функция завершается.</p>

<p>Функция загрузки параметров <span class="cpp">LoadText</span> будет зеркальным отражением функции сохранения
(разумеется, без проверки причины загрузки &ndash; если в загружаемом тексте есть параметры, их необходимо
считать и установить в любом случае).</p>

<pre class="cpp">  <span class="rem">// Функция загрузки параметров блока</span>
  <span class="kw">void</span> TOpenGLInstr::LoadText(<span class="kw">char</span> *text)
  { <a class="hidden" href="app_ids.htm#light_ref6" title="Идентификатор вспомогательного объекта">RDS_HOBJECT</a> ini; <span class="rem">// Идентификатор вспомогательного объекта</span>

    <span class="rem">// Создание вспомогательного объекта для работы с данными</span>
    ini=<a class="hidden" href="rdsINICreateTextHolder.htm" title="А.5.27.1. rdsINICreateTextHolder &ndash; создать объект для работы с текстом">rdsINICreateTextHolder</a>(TRUE);

    <span class="rem">// Запись в объект полученного от RDS текста с параметрами блока</span>
    <a class="hidden" href="rdsSetObjectStr.htm" title="А.5.22.12. rdsSetObjectStr &ndash; установить строку">rdsSetObjectStr</a>(ini,<span id="light_ref38"><a class="hidden" href="RDS_HINI_SETTEXT.htm" title="А.5.27.18. Команда RDS_HINI_SETTEXT &ndash; занести текст в объект">RDS_HINI_SETTEXT</a></span>,<span class="const">0</span>,text);

    <span class="rem">// Установка "[Window]" в качестве текущей секции и чтение</span>
    <span class="rem">// из нее пяти целых параметров</span>
    <span class="kw">if</span>(<span id="light_ref39"><a class="hidden" href="rdsINIOpenSection.htm" title="А.5.27.2. rdsINIOpenSection &ndash; установить текущую секцию">rdsINIOpenSection</a></span>(ini,<span class="str">"Window"</span>))
      { <span id="light_ref40"><a class="hidden" href="rdsSetObjectInt.htm" title="А.5.22.11. rdsSetObjectInt &ndash; установить целое число">rdsSetObjectInt</a></span>(Panel,<a class="hidden" href="RDS_PAN_LEFT.htm" title="А.5.31.8. Команда RDS_PAN_LEFT &ndash; горизонтальная координата панели">RDS_PAN_LEFT</a>,<span class="const">0</span>,<span id="light_ref41"><a class="hidden" href="rdsINIReadInt.htm" title="А.5.27.5. rdsINIReadInt &ndash; получить целое значение параметра">rdsINIReadInt</a></span>(ini,<span class="str">"Left"</span>,<span class="const">0</span>));
        <a class="hidden" href="rdsSetObjectInt.htm" title="А.5.22.11. rdsSetObjectInt &ndash; установить целое число">rdsSetObjectInt</a>(Panel,<a class="hidden" href="RDS_PAN_TOP.htm" title="А.5.31.13. Команда RDS_PAN_TOP &ndash; вертикальная координата панели">RDS_PAN_TOP</a>,<span class="const">0</span>,<a class="hidden" href="rdsINIReadInt.htm" title="А.5.27.5. rdsINIReadInt &ndash; получить целое значение параметра">rdsINIReadInt</a>(ini,<span class="str">"Top"</span>,<span class="const">0</span>));
        <a class="hidden" href="rdsSetObjectInt.htm" title="А.5.22.11. rdsSetObjectInt &ndash; установить целое число">rdsSetObjectInt</a>(Panel,<a class="hidden" href="RDS_PAN_WIDTH.htm" title="А.5.31.15. Команда RDS_PAN_WIDTH &ndash; общая ширина панели">RDS_PAN_WIDTH</a>,<span class="const">0</span>,<a class="hidden" href="rdsINIReadInt.htm" title="А.5.27.5. rdsINIReadInt &ndash; получить целое значение параметра">rdsINIReadInt</a>(ini,<span class="str">"Width"</span>,<span class="const">0</span>));
        <a class="hidden" href="rdsSetObjectInt.htm" title="А.5.22.11. rdsSetObjectInt &ndash; установить целое число">rdsSetObjectInt</a>(Panel,<a class="hidden" href="RDS_PAN_HEIGHT.htm" title="А.5.31.7. Команда RDS_PAN_HEIGHT &ndash; общая высота панели">RDS_PAN_HEIGHT</a>,<span class="const">0</span>,<a class="hidden" href="rdsINIReadInt.htm" title="А.5.27.5. rdsINIReadInt &ndash; получить целое значение параметра">rdsINIReadInt</a>(ini,<span class="str">"Height"</span>,<span class="const">0</span>));
        <a class="hidden" href="rdsSetObjectInt.htm" title="А.5.22.11. rdsSetObjectInt &ndash; установить целое число">rdsSetObjectInt</a>(Panel,<a class="hidden" href="RDS_PAN_VISIBLE.htm" title="А.5.31.14. Команда RDS_PAN_VISIBLE &ndash; видимость панели">RDS_PAN_VISIBLE</a>,<span class="const">0</span>,<a class="hidden" href="rdsINIReadInt.htm" title="А.5.27.5. rdsINIReadInt &ndash; получить целое значение параметра">rdsINIReadInt</a>(ini,<span class="str">"Visible"</span>,<span class="const">0</span>));
      }
    <span class="rem">// Удаление вспомогательного объекта</span>
    <a class="hidden" href="rdsDeleteObject.htm" title="А.5.22.4. rdsDeleteObject &ndash; удалить объект">rdsDeleteObject</a>(ini);
  }
  <span class="rem">//=================================================</span></pre>

<p>Внутри функции создается вспомогательный объект <span class="cpp">ini</span> для работы с текстом,
в этот объект записывается текст для загрузки, полученный моделью из RDS (функция
<span class="cpp">LoadText</span> получает его как параметр), в объекте выбирается секция
&laquo;Window&raquo;, и, если она существует, из нее в объект-панель читаются пять тех же
целых параметров окна. Каждый параметр считывается из текста функцией <span class="cpp"><a href="rdsINIReadInt.htm" title="А.5.27.5. rdsINIReadInt &ndash; получить целое значение параметра">rdsINIReadInt</a></span>
и передается в панель функцией <span class="cpp"><a href="rdsSetObjectInt.htm" title="А.5.22.11. rdsSetObjectInt &ndash; установить целое число">rdsSetObjectInt</a></span>. После считывания параметров объект <span class="cpp"></span>
уничтожается.</p>

<p>Теперь можно написать функцию модели. Структуру переменных блока пока определять не будем &ndash;
сейчас мы создаем простую модель, умеющую создавать панель в окне подсистемы и обновлять ее по таймеру, но
не выводящую на эту панель никаких изображений. В модель будет включена реакция на таймер и на
действия пользователя с панелью, но эти реакции пока останутся пустыми.</p>

<pre class="cpp">  <span class="rem">// Модель блока с панелью</span>
  <span class="kw">extern</span> <span class="str">"C"</span> <span class="kw">__declspec</span>(<span class="kw">dllexport</span>) <span class="kw">int</span> <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> OpenGLInstr(
        <span class="kw">int</span> CallMode,
        <a class="hidden" href="RDS_BLOCKDATA.htm#ref2" title="Указатель на RDS_BLOCKDATA">RDS_PBLOCKDATA</a> BlockData,
        <a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> ExtParam)
  { <span class="rem">// Указатель на личную область, приведенный к нужному типу</span>
    TOpenGLInstr *data=(TOpenGLInstr*)(BlockData-&gt;BlockData);
    <span class="rem">// </span><span id="ref42"><span class="rem">Вспомогательная</span></span><span class="rem"> – указатель на структуру параметров при</span>
    <span class="rem">// действиях с панелью (будет использована в реакциях)</span>
    <span id="light_ref42"><a class="hidden" href="RDS_BFM_BLOCKPANEL.htm#ref2" title="Указатель на RDS_PANOPERATION">RDS_PPANOPERATION</a> param;</span>

    <span class="kw">switch</span>(CallMode)
      { <span class="rem">// Инициализация блока</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_INIT.htm" title="А.2.4.7. RDS_BFM_INIT &ndash; инициализация блока">RDS_BFM_INIT</a>:
          <span class="rem">// Создание личной области данных</span>
          <span class="rem">// (при этом в конструкторе будет создана панель)</span>
          BlockData-&gt;BlockData=data=<span class="kw">new</span> TOpenGLInstr();
          <span class="kw">break</span>;

        <span class="rem">// Очистка данных блока</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_CLEANUP.htm" title="А.2.4.3. RDS_BFM_CLEANUP &ndash; очистка данных блока">RDS_BFM_CLEANUP</a>:
          <span class="rem">// В деструкторе класса панель будет уничтожена</span>
          <span class="kw">delete</span> data;
          <span class="kw">break</span>;

        <span class="rem">// Запуск расчета</span>
        <span class="kw">case</span> <span id="light_ref43"><a class="hidden" href="RDS_BFM_STARTCALC.htm" title="А.2.4.14. RDS_BFM_STARTCALC &ndash; запуск расчета">RDS_BFM_STARTCALC</a></span>:
          <span class="rem">// Создание таймера обновления</span>
          data-&gt;CreateRefreshTimer(BlockData-&gt;Parent);
          <span class="kw">break</span>;

        <span class="rem">// Вызов функции настройки или двойной щелчок</span>
        <span class="rem">// левой кнопки мыши</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_SETUP.htm" title="А.2.6.13. RDS_BFM_SETUP &ndash; вызов функции настройки блока">RDS_BFM_SETUP</a>:
        <span class="kw">case</span> <span id="light_ref44"><a class="hidden" href="RDS_BFM_MOUSEDBLCLICK.htm" title="А.2.6.8. RDS_BFM_MOUSEDBLCLICK &ndash; двойной щелчок мыши">RDS_BFM_MOUSEDBLCLICK</a></span>:
          <span class="rem">// Показать панель</span>
          <a class="hidden" href="rdsSetObjectInt.htm" title="А.5.22.11. rdsSetObjectInt &ndash; установить целое число">rdsSetObjectInt</a>(data-&gt;Panel,<a class="hidden" href="RDS_PAN_VISIBLE.htm" title="А.5.31.14. Команда RDS_PAN_VISIBLE &ndash; видимость панели">RDS_PAN_VISIBLE</a>,<span class="const">0</span>,<span class="const">1</span>);
          <span class="kw">break</span>;

        <span class="rem">// Сохранение параметров блока</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_SAVETXT.htm" title="А.2.5.7. RDS_BFM_SAVETXT &ndash; запись данных блока в текстовом формате">RDS_BFM_SAVETXT</a>:
          data-&gt;SaveText();
          <span class="kw">break</span>;

        <span class="rem">// Загрузка параметров блока</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_LOADTXT.htm" title="А.2.5.5. RDS_BFM_LOADTXT &ndash; загрузка данных блока в текстовом формате">RDS_BFM_LOADTXT</a>:
          data-&gt;LoadText((<span class="kw">char</span>*)ExtParam);
          <span class="kw">break</span>;

        <span class="rem">// Действия с панелью</span>
        <span class="kw">case</span> <span id="light_ref45"><a class="hidden" href="RDS_BFM_BLOCKPANEL.htm" title="А.2.6.1. RDS_BFM_BLOCKPANEL &ndash; уведомление от панели блока в подсистеме">RDS_BFM_BLOCKPANEL</a></span>:
          <span class="rem">// Приведение указателя на структуру, переданного в</span>
          <span class="rem">// ExtParam, к нужному типу</span>
          param=(<a class="hidden" href="RDS_BFM_BLOCKPANEL.htm#ref2" title="Указатель на RDS_PANOPERATION">RDS_PPANOPERATION</a>)ExtParam;
          <span class="rem">// Разные действия в зависимости от операции с панелью</span>
          <span class="kw">switch</span>(param-&gt;Operation)
            { <span class="rem">// Создание оконного объекта для панели</span>
              <span class="kw">case</span> <span id="light_ref46"><a class="hidden" href="RDS_BFM_BLOCKPANEL.htm#light_ref3" title="RDS_PANOP_CREATE">RDS_PANOP_CREATE</a></span>:
                <span class="rem">// Здесь будет инициализация рисования на панели</span>
                <span class="kw">break</span>;
              <span class="rem">// Уничтожение оконного объекта панели</span>
              <span class="kw">case</span> <span id="light_ref47"><a class="hidden" href="RDS_BFM_BLOCKPANEL.htm#light_ref4" title="RDS_PANOP_DESTROY">RDS_PANOP_DESTROY</a></span>:
                <span class="rem">// Здесь будет очистка инициализированного</span>
                <span class="kw">break</span>;
              <span class="rem">// Размер панели изменен</span>
              <span class="kw">case</span> <span id="light_ref48"><a class="hidden" href="RDS_BFM_BLOCKPANEL.htm#light_ref5" title="RDS_PANOP_RESIZED">RDS_PANOP_RESIZED</a></span>:
                <span class="rem">// Здесь будет реакция на изменение размера</span>
                <span class="rem">// и перерисовка панели</span>
                <span class="kw">break</span>;
              <span class="rem">// Необходимо перерисовать изображение</span>
              <span class="kw">case</span> <span id="light_ref49"><a class="hidden" href="RDS_BFM_BLOCKPANEL.htm#light_ref7" title="RDS_PANOP_PAINT">RDS_PANOP_PAINT</a></span>:
                <span class="rem">// Здесь будет перерисовка панели</span>
                <span class="kw">break</span>;
            }
          <span class="kw">break</span>;

       <span class="rem">// Необходимо обновить окна блока (вызывается таймером)</span>
       <span class="kw">case</span> <span id="light_ref50"><a class="hidden" href="RDS_BFM_WINREFRESH.htm" title="А.2.6.21. RDS_BFM_WINREFRESH &ndash; обновление окон блока">RDS_BFM_WINREFRESH</a></span>:
          <span class="rem">// Здесь будет перерисовка панели</span>
          <span class="kw">break</span>;
      }
    <span class="kw">return</span> <a class="hidden" href="app_a_2_1.htm#ref2" title="Возврат RDS_BFR_DONE">RDS_BFR_DONE</a>;
  }
  <span class="rem">//=================================================</span></pre>

<p>При инициализации блока (<span class="cpp"><a href="RDS_BFM_INIT.htm" title="А.2.4.7. RDS_BFM_INIT &ndash; инициализация блока">RDS_BFM_INIT</a></span>) и очистке его данных
(<span class="cpp"><a href="RDS_BFM_CLEANUP.htm" title="А.2.4.3. RDS_BFM_CLEANUP &ndash; очистка данных блока">RDS_BFM_CLEANUP</a></span>) , как обычно, создается и удаляется личная область. В
момент ее создания (в конструкторе класса) будет создан объект для панели в окне подсистемы, при
этом сама панель в окне не появится, даже если окно подсистемы уже создано, поскольку объект
в конструкторе создается с флагом <span class="cpp"><a class="hidden" href="rdsPANCreate.htm#light_ref4" title="RDS_PAN_F_HIDDEN">RDS_PAN_F_HIDDEN</a></span>. В деструкторе класса,
соответственно, этот объект уничтожается, и, если панель видима, она тоже исчезнет из окна.</p>

<p>При запуске расчета (<span class="cpp"><a href="RDS_BFM_STARTCALC.htm" title="А.2.4.14. RDS_BFM_STARTCALC &ndash; запуск расчета">RDS_BFM_STARTCALC</a></span>) вызывается функция
<span class="cpp">CreateRefreshTimer</span>, которая либо создает таймер, если это первый ее вызов,
либо задает для таймера новый интервал обновления, если таймер уже существует. В функцию передается
идентификатор родительской подсистемы блока <span class="cpp">BlockData-&gt;Parent</span>, чтобы она
считала из параметров этой подсистемы интервал обновления окна и установила для таймера такой
же. <span id="ref51">В</span>
отличие от рассматривавшихся ранее моделей с таймерами, в этой модели таймер создается
не при инициализации блока (в конструкторе класса), а позже, при запуске расчета.
<span id="light_ref51">Дело в том</span>, что в режиме
<a href="pm_1_3.htm#ref1" title="Режим редактирования">редактирования</a>
пользователь может изменить
<a href="um_2_11_4.htm#ref4" title="Обновление окна подсистемы">частоту обновления окна подсистемы</a>, и единственный способ отследить это
&ndash; заново считывать интервал обновления каждый раз при входе в режим
<a href="pm_1_3.htm#ref2" title="Режим моделирования">моделирования</a> или расчета. В данном случае выбран именно режим расчета, поскольку
таймер, создаваемый в функции <span class="cpp">CreateRefreshTimer</span>, работает именно в этом режиме.</p>

<p>В конструкторе блока панель создается скрытой, поэтому необходимо дать пользователю возможность открыть ее.
Поскольку у данного блока нет каких-либо настраиваемых пользователем параметров, логично использовать функцию
настройки, предусмотренную интерфейсом RDS (<span class="cpp"><a href="RDS_BFM_MOUSEDBLCLICK.htm" title="А.2.6.8. RDS_BFM_MOUSEDBLCLICK &ndash; двойной щелчок мыши">RDS_BFM_MOUSEDBLCLICK</a></span>). Разумеется, чтобы все это работало, необходимо в параметрах блока
указать наличие функции настройки (при этом лучше изменить ее название на &laquo;открыть окно&raquo; или
&laquo;показать панель&raquo;) и включить реакцию на мышь
(<a href="#pic1" title="Параметры блока, создающего панель">рис.&nbsp;65</a>).
Если еще установить в параметрах блока флаг
&laquo;<span class="menu">двойной щелчок &ndash; вызывает функцию настройки</span>&raquo;
(см. <a href="pm_1_4.htm#pic1" title="Параметры блока &ndash; общие">рис.&nbsp;5</a>),
панель будет вызываться на экран по двойному щелчку независимо от режима RDS.</p>

<div class="pic"><div class="container" id="pic1">
<img src="../img/OpenGlInstr_DllSetup.png" width="534" height="406" alt="Параметры блока, создающего панель" />
<p id="light_pic1">Рис.&nbsp;65. Параметры блока, создающего панель</p>
</div></div>


<p>Для показа панели в функцию модели введена одинаковая реакция на вызовы
<span class="cpp"><a class="hidden" href="RDS_BFM_SETUP.htm" title="А.2.6.13. RDS_BFM_SETUP &ndash; вызов функции настройки блока">RDS_BFM_SETUP</a></span> и <span class="cpp"><a class="hidden" href="RDS_BFM_MOUSEDBLCLICK.htm" title="А.2.6.8. RDS_BFM_MOUSEDBLCLICK &ndash; двойной щелчок мыши">RDS_BFM_MOUSEDBLCLICK</a></span>. В ней при
помощи функции <span class="cpp"><a class="hidden" href="rdsSetObjectInt.htm" title="А.5.22.11. rdsSetObjectInt &ndash; установить целое число">rdsSetObjectInt</a></span>, передающей целое число объекту
<span class="cpp">data-&gt;Panel</span>, параметру объекта <span class="cpp"><a href="RDS_PAN_VISIBLE.htm" title="А.5.31.14. Команда RDS_PAN_VISIBLE &ndash; видимость панели">RDS_PAN_VISIBLE</a></span>
устанавливается значение 1. Это приведет к появлению панели в окне подсистемы и созданию для нее
оконного объекта Windows. Если панель уже видима, никаких действий выполнено не будет.</p>

<p>Далее в функции модели следуют реакции на сохранение и загрузку параметров блока, в которых
вызываются написанные ранее функции <span class="cpp">SaveText</span> и <span class="cpp">LoadText</span>. Функция
<span class="cpp">LoadText</span> устанавливает все параметры панели, включая видимость, согласно ранее
записанным значениям, поэтому, если сохранить схему с открытой панелью, при загрузке этой схемы панель
будет открыта автоматически.</p>

<p>Для реакции на различные события, связанные с панелями блока, RDS вызывает функцию модели в режиме
<span class="cpp"><a href="RDS_BFM_BLOCKPANEL.htm" title="А.2.6.1. RDS_BFM_BLOCKPANEL &ndash; уведомление от панели блока в подсистеме">RDS_BFM_BLOCKPANEL</a></span>, при этом в параметре <span class="cpp">ExtParam</span> передается указатель
на структуру типа <span class="cpp"><a href="RDS_BFM_BLOCKPANEL.htm#ref1" title="Структура RDS_PANOPERATION">RDS_PANOPERATION</a></span> (именно для работы с этой структурой в функции
модели объявлена вспомогательная переменная <span class="cpp">param</span>). В поле
<span class="cpp">Operation</span> этой структуры содержится целый идентификатор события, произошедшего с
панелью, в поле <span class="cpp">Panel</span> &ndash; указатель на структуру описания самой панели. Структура
описания панели, в свою очередь, содержит большой набор параметров панели: идентификатор, положение и
размер, флаги, заголовок и т.п. Важнее всего то, что она содержит дескриптор оконного объекта Windows,
связанного с панелью &ndash; поле Handle типа <span class="cpp"><a class="hidden" href="app_ids.htm#light_ref18" title="Дескриптор окна">HWND</a></span>. Не зная этого дескриптора,
нельзя создавать внутри панели дочерние окна, привязывать к панели область вывода трехмерных изображений OpenGL и
т.п. Пока мы пишем &laquo;скелет&raquo; модели, поэтому в данный момент она никак не реагирует на
различные события панели. Однако, в модель уже включен оператор <span class="cpp">switch</span>, анализирующий
поле <span class="cpp">Opeation</span> переданной структуры. Пока внутри него расставлены комментарии,
поясняющие, как будет реагировать модель на события, позднее мы заменим их настоящими реакциями.</p>

<p>Всего модель может реагировать на пять действий с панелью, таким образом, поле
<span class="cpp">Operation</span> структуры <span class="cpp"><a class="hidden" href="RDS_BFM_BLOCKPANEL.htm#ref1" title="Структура RDS_PANOPERATION">RDS_PANOPERATION</a></span> может
принимать одно из следующих значений:</p>

<ul>
  <li><span class="cpp"><a href="RDS_BFM_BLOCKPANEL.htm#light_ref3" title="RDS_PANOP_CREATE">RDS_PANOP_CREATE</a></span> &ndash; для панели создан оконный объект Windows.
  Модель должна выполнить необходимые действия для создания дочерних оконных объектов, их инициализации и т.п.;</li>

  <li><span class="cpp"><a href="RDS_BFM_BLOCKPANEL.htm#light_ref4" title="RDS_PANOP_DESTROY">RDS_PANOP_DESTROY</a></span> &ndash; оконный объект панели сейчас будет уничтожен.
  Все созданные дочерние объекты, созданные моделью, должны быть уничтожены в этой реакции;</li>

  <li><span class="cpp"><a href="RDS_BFM_BLOCKPANEL.htm#light_ref5" title="RDS_PANOP_RESIZED">RDS_PANOP_RESIZED</a></span> &ndash; размер панели изменен. Модель может, при необходимости,
  перестроить дочерние окна так, чтобы они уложились в панель, изменить размер области вывода и т.п.;</li>

  <li><span class="cpp"><span id="light_ref52"><a href="RDS_BFM_BLOCKPANEL.htm#light_ref6" title="RDS_PANOP_MOVED">RDS_PANOP_MOVED</a></span></span> &ndash; панель перемещена. Как правило, от модели
  в этом случае не требуется каких-либо действий, но, при необходимости, она может отреагировать и на это;</li>

  <li><span class="cpp"><a href="RDS_BFM_BLOCKPANEL.htm#light_ref7" title="RDS_PANOP_PAINT">RDS_PANOP_PAINT</a></span> &ndash; панель необходимо перерисовать. Этот вызов производится только
  для панелей, созданных с флагом <span class="cpp"><a class="hidden" href="rdsPANCreate.htm#light_ref7" title="RDS_PAN_F_PAINTMSG">RDS_PAN_F_PAINTMSG</a></span>, как в нашем случае.</li>
</ul>

<p class="noindent">Наша модель будет реагировать на все действия с панелью, кроме <span class="cpp"><a class="hidden" href="RDS_BFM_BLOCKPANEL.htm#light_ref6" title="RDS_PANOP_MOVED">RDS_PANOP_MOVED</a></span>.</p>

<p>Наконец, последняя в нашей модели &ndash; реакция на обновление окон
<span class="cpp"><a href="RDS_BFM_WINREFRESH.htm" title="А.2.6.21. RDS_BFM_WINREFRESH &ndash; обновление окон блока">RDS_BFM_WINREFRESH</a></span>. Она будет вызываться в режиме расчета при срабатывании таймера обновления
панели. Сейчас эта реакция пуста, но позже там будет вызов функции, перерисовывающей трехмерное изображение.</p>

<p>Итак, мы получили модель, которая умеет открывать пустую панель в окне подсистемы
(<a href="#pic2" title="Блок с пустой панелью">рис.&nbsp;66</a>),
дает пользователю перемещать эту панель, закрывать ее и изменять ее размеры, может обновлять панель по
таймеру (хотя пока ничего в ней не рисует), а также сохраняет положение и размер панели при сохранении схемы и
восстанавливает их при загрузке. Теперь заставим ее строить на панели трехмерное изображение.</p>

<div class="pic"><div class="container" id="pic2">
<img src="../img/OpenGlInstr_EmptyPanel.png" width="484" height="354" alt="Блок с пустой панелью" />
<p id="light_pic2">Рис.&nbsp;66. Блок с пустой панелью</p>
</div></div>


<p>Сделаем из нашего блока индикатор, который будет наглядно отображать три угловых координаты какого-либо
объекта. Используя морскую терминологию, назовем эти координаты курсом, дифферентом и креном
(<a href="#pic3" title="Угловые координаты объекта">рис.&nbsp;67</a>).</p>

<div class="pic"><div class="container" id="pic3">
<img src="../img/ObjectAngles.png" width="767" height="280" alt="Угловые координаты объекта" />
<p id="light_pic3">Рис.&nbsp;67. Угловые координаты объекта</p>
</div></div>


<p>Блок будет иметь три вещественных входа: &laquo;<span class="rdsvar">Dir</span>&raquo; (курс), &laquo;<span class="rdsvar">List</span>&raquo; (крен) и
&laquo;<span class="rdsvar">Pitch</span>&raquo; (дифферент). В зависимости от их значений будем поворачивать внутри панели какой-нибудь
трехмерный объект на соответствующие углы по трем координатам. Чтобы не усложнять пример, возьмем в
качестве объекта-индикатора неправильную треугольную пирамиду, грани которой раскрашены в разные цвета
(<a href="#pic4" title="Центральный объект блока">рис.&nbsp;68</a>, <a href="#pic5" title="Внешний вид панели блока">рис.&nbsp;69</a>).
Нижнюю плоскость пирамиды (треугольник P<sub>1</sub>-P<sub>2</sub>-P<sub>3</sub>) будем считать
горизонтальной плоскостью объекта, при этом точка P<sub>1</sub> будет соответствовать носовой части объекта,
а отрезок P<sub>2</sub>-P<sub>3</sub> &ndash; его корме.</p>

<div class="pic"><div class="container" id="pic4">
<img src="../img/ObjectSize.png" width="424" height="292" alt="Центральный объект блока" />
<p id="light_pic4">Рис.&nbsp;68. Центральный объект блока</p>
</div>
<div class="container" id="pic5">
<img src="../img/ObjectLayout.png" width="289" height="292" alt="Внешний вид панели блока" />
<p id="light_pic5">Рис.&nbsp;69. Внешний вид панели блока</p>
</div>
</div>


<p>Левая грань пирамиды
(P<sub>1</sub>-P<sub>2</sub>-P<sub>4</sub>) будет раскрашена в красный цвет, правая
(P<sub>1</sub>-P<sub>4</sub>-P<sub>3</sub>) &ndash; в зеленый, задняя
(P<sub>2</sub>-P<sub>3</sub>-P<sub>4</sub>) и нижняя
(P<sub>1</sub>-P<sub>3</sub>-P<sub>2</sub>) &ndash; в белый. Для большей наглядности изображения
будем строить его со включенным расчетом освещенности от одного точечного источника (без расчета освещенности
трехмерные фигуры с заполненными гранями не выглядят объемными). Точкой &laquo;O&raquo; на
<a href="#pic4" title="Центральный объект блока">рис.&nbsp;68</a> обозначен центр объекта, вокруг этой точки
он будет вращаться при изменении угловых координат. Вокруг треугольной пирамиды будут также изображаться
две окружности: одна будет лежать в плоскости
P<sub>1</sub>-P<sub>2</sub>-P<sub>3</sub> (и, соответственно, поворачиваться вместе с объектом), а вторая,
большего диаметра, в горизонтальной плоскости внешней (&laquo;мировой&raquo;) системы координат.
По взаимному расположению этих окружностей будет легче оценить углы поворота объекта. Точка наблюдения (место
расположения условной камеры, через которую пользователь видит трехмерную сцену) будет выбрана так, чтобы
объект при нулевом курсе и дифференте был виден сверху с кормы
(<a href="#pic5" title="Внешний вид панели блока">рис.&nbsp;69</a>).</p>

<p>Поскольку данная модель будет работать с функциями библиотеки OpenGL, в ее текст необходимо включить файлы
заголовков
&laquo;<span class="file"><span id="light_ref53">gl.h</span></span>&raquo; и
&laquo;<span class="file"><span id="light_ref54">glu.h</span></span>&raquo;. Кроме того, нам
потребуются некоторые математические функции, поэтому подключим еще и файл
&laquo;<span class="file"><span id="light_ref55">math.h</span></span>&raquo; (добавления выделены
<span class="changes">цветом</span>):</p>

<pre class="cpp">  <span class="preproc">#include &lt;windows.h&gt;</span>
<span class="changes">  <span class="preproc">#include &lt;math.h&gt;    </span></span>
<span class="changes">  <span class="preproc">#include &lt;gl/gl.h&gt;   </span></span>
<span class="changes">  <span class="preproc">#include &lt;gl/glu.h&gt;  </span></span>
  <span class="preproc">#include &lt;RdsDef.h&gt;</span>
  <span class="rem">// Подготовка описаний сервисных функций</span>
  <a class="hidden" href="pm_2_2.htm#ref11" title="Использование RdsFunc.h"><span class="preproc">#define RDS_SERV_FUNC_BODY GetInterfaceFunctions</span></a>
  <span class="rem">// &hellip;</span></pre>

<p>В главную функцию DLL этой модели никаких изменений вносить не будем.</p>

<p>Класс личной области данных блока нужно дополнить несколькими полями и функциями. Во-первых, для рисования
нам потребуется контекст рисования OpenGL. Во-вторых, действия по настройке OpenGL и рисованию трехмерной фигуры
лучше всего вынести в отдельные функции. Класс личной области данных будет иметь следующий вид
(изменения выделены <span class="changes">цветом</span>):</p>

<pre class="cpp">  <span class="rem">//=================================================</span>
  <span class="rem">// Личная область данных блока</span>
  <span class="rem">//=================================================</span>
  <span class="kw">class</span> TOpenGLInstr
  { <span class="kw">private</span>:
<div class="changes">      <span id="light_ref56">HGLRC</span> Hrc;                 <span class="rem">// Контекст OpenGL</span></div>
      <a class="hidden" href="app_ids.htm#light_ref3" title="Идентификатор таймера">RDS_TIMERID</a> RefreshTimer;  <span class="rem">// Таймер обновления</span>

<div class="changes">      <span class="rem">// Служебная функция – настройка параметров OpenGL</span>
      <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> <a class="hidden" href="#ref78" title="Функция настройки параметров OpenGL">SetupGLParams</a>(<a class="hidden" href="app_ids.htm#light_ref16" title="Контекст устройства Windows">HDC</a> *pHdc);</div>
    <span class="kw">public</span>:
      <a class="hidden" href="app_ids.htm#light_ref6" title="Идентификатор вспомогательного объекта">RDS_HOBJECT</a> Panel;         <span class="rem">// Объект-панель</span>

<div class="changes">      <span class="rem">// Настройка вывода изображения на панель</span>
      <span class="kw">void</span> <a class="hidden" href="#ref69" title="Настройка вывода изображения на панель">InitWindow</a>(<a class="hidden" href="app_ids.htm#light_ref18" title="Дескриптор окна">HWND</a> window);
      <span class="rem">// Отключение OpenGL</span>
      <span class="kw">void</span> <a class="hidden" href="#ref77" title="Функция отключения OpenGL">Clear</a>(<span class="kw">void</span>);
      <span class="rem">// Рисование трехмерной сцены</span>
      <span class="kw">void</span> <a class="hidden" href="#ref81" title="Функция рисования трехмерной сцены">RenderScene</a>(<span class="kw">double</span> Dir,<span class="kw">double</span> List,<span class="kw">double</span> Pitch);</div>
      <span class="rem">// Сохранение параметров блока</span>
      <span class="kw">void</span> SaveText(<span class="kw">void</span>);
      <span class="rem">// Загрузка параметров блока</span>
      <span class="kw">void</span> LoadText(<span class="kw">char</span> *text);

      <span class="rem">// Создание таймера обновления</span>
      <span class="kw">void</span> CreateRefreshTimer(<a class="hidden" href="app_ids.htm#light_ref1" title="Идентификатор блока">RDS_BHANDLE</a> parent);

      <span class="rem">// Конструктор класса</span>
      TopenGLInstr(<span class="kw">void</span>);
      <span class="rem">// Деструктор класса</span>
      ~TOpenGLInstr();
  };
  <span class="rem">//=================================================</span></pre>

<p>В закрытую область класса (<span class="cpp">private</span>) добавлен контекст OpenGL
<span class="cpp">Hrc</span> (он будет использоваться в функциях-членах класса, отвечающих за рисование)
и служебная функция <span class="cpp"><a href="#ref78" title="Функция настройки параметров OpenGL">SetupGLParams</a></span> для настройки области рисования, освещения и прочих
параметров OpenGL (эти настройки выделены в отдельную функцию для улучшения читаемости примера). В открытую
область (<span class="cpp">public</span>) добавлено несколько функций, которые будут вызываться  непосредственно
из модели блока для настройки оконного объекта, его уничтожения, и для рисования изображения.</p>

<p>Кроме внесения изменений в класс личной области, введем еще несколько служебных функций, которые помогут в
геометрических расчетах и в построении трехмерного объекта. Можно было бы также сделать их членами
класса личной области данных блока, но, поскольку им не нужен доступ к каким-либо данным блока,
логичнее сделать их отдельными функциями.</p>

<p>Начнем с функции вычисления вектора, перпендикулярного плоскости треугольника с заданными координатами
вершин. Такие векторы единичной длины, называемые <i>нормалями</i>, используются в
OpenGL для расчета освещения. Поскольку центральный объект блока будет состоять из четырех треугольников,
эта функция пригодится при их построении. Для определения нормали будем вычислять векторное произведение
векторов, составляющих две стороны треугольника, а потом приводить получившийся вектор к единичной длине.</p>

<pre class="cpp">  <span class="rem">// </span><span id="ref57"><span class="rem">Вычисление</span></span><span class="rem"> нормали к треугольнику</span>
  <span class="rem">// p1,p2,p3 – массивы координат вершин {x,y,z}</span>
  <span class="rem">// norm – массив, в котором возвращаются вычисленные</span>
  <span class="rem">// координаты нормали</span>
  <span class="kw">void</span> <span id="light_ref57">NormalToTriangle</span>(GLfloat *p1,GLfloat *p2,
                                   GLfloat *p3,GLfloat *norm)
  { <span class="kw">double</span> m[<span class="const">3</span>],a[<span class="const">3</span>],b[<span class="const">3</span>],R; <span class="rem">// Вспомогательные переменные</span>

    <span class="rem">// Символические имена для координат векторов</span>
    <span class="preproc">#define x 0</span>
    <span class="preproc">#define y 1</span>
    <span class="preproc">#define z 2</span>

    <span class="rem">// Вычисляем векторное произведение векторов</span>
    <span class="rem">// a (p1-&gt;p2) и b (p1-&gt;p3)</span>
    <span class="kw">for</span>(<span class="kw">int</span> i=<span class="const">0</span>;i&lt;<span class="const">3</span>;i++)
      { a[i]=p2[i]-p1[i];
        b[i]=p3[i]-p1[i];
      }
    m[x]=a[y]*b[z]-a[z]*b[y];
    m[y]=a[z]*b[x]-a[x]*b[z];
    m[z]=a[x]*b[y]-a[y]*b[x];

    <span class="rem">// Длина получившегося вектора</span>
    R=sqrt(m[x]*m[x]+m[y]*m[y]+m[z]*m[z]);

    <span class="rem">// Приводим вектор к единичной длине</span>
    <span class="kw">for</span>(<span class="kw">int</span> i=<span class="const">0</span>;i&lt;<span class="const">3</span>;i++)
      norm[i]=(GLfloat)(m[i]/R);

    <span class="rem">// Отмена макроопределений символических имен координат</span>
    <span class="preproc">#undef x</span>
    <span class="preproc">#undef y</span>
    <span class="preproc">#undef z</span>
  }
  <span class="rem">//=================================================</span></pre>

<p>Координаты вершин треугольника передаются в функцию в виде трех массивов <span class="cpp">p1</span>,
<span class="cpp">p2</span> и <span class="cpp">p3</span>, содержащих координаты вершин. Каждый массив
содержит три элемента типа <span class="cpp">GLfloat</span> &ndash; вещественного типа, используемого в
библиотеке OpenGL. Координата <i>x</i> хранится в первом элементе массива, <i>y</i> &ndash; во втором,
<i>z</i> &ndash; в третьем. Вычисленные координаты вектора нормали записываются в массив <span class="cpp">norm</span>
с точно такой же структурой. Для большей ясности текста функции внутри нее введены символические имена
<span class="cpp">x</span>, <span class="cpp">y</span> и <span class="cpp">z</span> для индексов массивов координат
0, 1 и 2 соответственно &ndash; <span class="cpp">p1[x]</span> выглядит гораздо понятнее, чем
<span class="cpp">p1[0]</span>. Для работы с координатами выбраны именно массивы, а не структуры с полями
<span class="cpp">x</span>, <span class="cpp">y</span> и <span class="cpp">z</span>, поскольку функции OpenGL
могут работать именно с такими массивами. Внутри функции вычисляется векторное произведение сторон
треугольника <span class="cpp">p1</span>-<span class="cpp">p2</span> и <span class="cpp">p1</span>-<span class="cpp">p3</span>
и длина <span class="cpp">R</span> получившегося вектора, после чего все компоненты вектора делятся на его длину.
В результате получается вектор единичной длины, перпендикулярный поверхности треугольника. Следует помнить,
что многоугольники в OpenGL &ndash; ориентированные, то есть имеют &laquo;лицевую&raquo; и
&laquo;изнаночную&raquo; стороны. При рисовании объемных фигур чаще всего изображается только лицевая
сторона всех многоугольников, изнаночная считается внутренней, и на ее рисование ресурсы не тратятся.
Для правильного расчета освещенности вектор нормали каждой грани объемной фигуры должен быть направлен наружу,
поэтому при вызове функции <span class="cpp"><a class="hidden" href="#ref57" title="Функция вычисления нормали к треугольнику">NormalToTriangle</a></span> точки треугольника необходимо задавать в
правильном порядке, чтобы векторное произведение
<span class="cpp">p1</span>-<span class="cpp">p2</span> и <span class="cpp">p1</span>-<span class="cpp">p3</span>
также было направлено наружу фигуры. Например, для вычисления нормали к левому переднему (красному) треугольнику
P<sub>1</sub>-P<sub>2</sub>-P<sub>4</sub> необходимо сделать вызов</p>

<pre class="cpp">  <a class="hidden" href="#ref57" title="Функция вычисления нормали к треугольнику">NormalToTriangle</a>(p2,p4,p1,norm);</pre>

<p>Теперь, имея возможность вычислять нормаль к грани объемной фигуры, напишем функцию, которая будет строить
треугольник по трем точкам при помощи команд OpenGL. Будем считать, что библиотека OpenGL уже инициализирована,
вывод на панель в окне подсистемы настроен, и все необходимые режимы рисования уже установлены &ndash;
все это будет рассмотрено позднее. Функция будет достаточно простой:</p>

<pre class="cpp">  <span class="rem">// </span><span id="ref58"><span class="rem">Построение</span></span><span class="rem"> треугольника p1-p2-p3</span>
  <span class="kw">void</span> <span id="light_ref58">DrawTriangleGL</span>(GLfloat *p1,GLfloat *p2,GLfloat *p3)
  { GLfloat norm[<span class="const">3</span>]; <span class="rem">// Массив для вычисления нормали</span>

    <span class="rem">// Вычислить нормаль</span>
    <a class="hidden" href="#ref57" title="Функция вычисления нормали к треугольнику">NormalToTriangle</a>(p1,p2,p3,norm);
    <span class="rem">// Установить нормаль в OpenGL</span>
    <span id="light_ref59">glNormal3fv</span>(norm);
    <span class="rem">// Задать три точки треугольника</span>
    <span id="light_ref60">glVertex3fv</span>(p1);
    glVertex3fv(p2);
    glVertex3fv(p3);
  }
  <span class="rem">//=================================================</span></pre>

<p>Как и в функцию <span class="cpp"><a href="#ref57" title="Функция вычисления нормали к треугольнику">NormalToTriangle</a></span>, в новую функцию
<span class="cpp"><a class="hidden" href="#ref58" title="Функция построения треугольника">DrawTriangleGL</a></span> координаты вершин треугольника передаются в трех трехэлементных массивах
<span class="cpp">p1</span>, <span class="cpp">p2</span> и <span class="cpp">p3</span>. Функция вычисляет
вектор нормали к заданному треугольнику и записывает его координаты во вспомогательный массив
<span class="cpp">norm</span>, после чего эти координаты передаются библиотеке OpenGL функцией
<span class="cpp">glNormal3fv</span> (суффикс &laquo;<span class="cpp">3fv</span>&raquo; во всех функциях OpenGL указывает на то,
что данная функция принимает в качестве входного параметра массив из трех элементов
<span class="cpp">Glfloat</span>, именно поэтому во всех написанных нами функциях для хранения координат будут
использоваться такие массивы). Затем функцией <span class="cpp">glVertex3fv</span> в библиотеку передаются
координаты точек <span class="cpp">p1</span>, <span class="cpp">p2</span> и <span class="cpp">p3</span>. На
самом деле, перед установкой координат вершин треугольника и нормалей, необходимо указать библиотеке, что
передаваемые точки являются именно вершинами треугольника, а не точками ломаной линии, концами отрезка, и т.п.
Для этого служат специальные функции OpenGL <span class="cpp">glBegin</span> и <span class="cpp">glEnd</span>,
которые будут вызываться во внешней функции, строящей всю объемную фигуру и вызывающей <span class="cpp"><a class="hidden" href="#ref58" title="Функция построения треугольника">DrawTriangleGL</a></span>.</p>

<p>В OpenGL в каждой точке многоугольника может быть задана своя нормаль (это позволяет более реалистично
отображать кривые поверхности, аппроксимированные многоугольниками), но, в данном случае, для всех точек
треугольника будет использован один и тот же вектор нормали, вычисленный в массиве <span class="cpp">norm</span>.
Именно поэтому на три вызова <span class="cpp">glVertex3fv</span> в функции приходится всего один вызов
<span class="cpp">glNormal3fv</span>. Задав нормаль один раз, можно не повторять задание для каждой
очередной точки многоугольника.</p>

<p>Обычно &laquo;лицевой&raquo; стороной многоугольника считается та, при взгляде на которую вершины
следуют друг за другом против часовой стрелки. В связи с этим, при вызове функции
<span class="cpp"><a class="hidden" href="#ref58" title="Функция построения треугольника">DrawTriangleGL</a></span> важно передавать ей точки треугольника в правильном порядке.
Функция написана так, что этот порядок совпадает с порядком аргументов функции <span class="cpp"><a class="hidden" href="#ref57" title="Функция вычисления нормали к треугольнику">NormalToTriangle</a></span>.
Например, для построения треугольника
P<sub>1</sub>-P<sub>2</sub>-P<sub>4</sub> необходимо сделать следующий вызов:</p>

<pre class="cpp">  <span class="cpp"><a class="hidden" href="#ref58" title="Функция построения треугольника">DrawTriangleGL</a></span>(p2,p4,p1);</pre>

<p>Еще одна дополнительная функция, которая потребуется для рисования &ndash; это функция построения окружности.
Изображаемый объект содержит две окружности: подвижную и неподвижную, эти окружности разного диаметра и,
для улучшения восприятия, лучше всего их окрасить в разные цвета. Таким образом, функция должна иметь
возможность строить окружность произвольного радиуса и произвольного цвета. Для определенности, будем
строить окружность в плоскости <i>XY</i> (поворот подвижной окружности будет осуществляться преобразованиями
системы координат перед ее построением, это одно из удобств, предоставляемых библиотекой OpenGL). Окружность
будет аппроксимироваться замкнутой ломаной линией с числом звеньев <span class="cpp">N</span>.</p>

<pre class="cpp">  <span class="rem">// </span><span id="ref61"><span class="rem">Рисование</span></span><span class="rem"> окружности в OpenGL</span>
  <span class="kw">void</span> <span id="light_ref61">DrawCircleGL</span>(GLfloat R,<span class="kw">int</span> N,GLfloat cR,GLfloat cG,GLfloat cB)
  { <span class="kw">double</span> aStep=(<span class="const">2.0</span>*M_PI)/N; <span class="rem">// Шаг ломаной по углу, радиан</span>
    <span class="rem">// Массивы для задания материала</span>
    GLfloat MaterialAmbDiff[<span class="const">4</span>],
            MaterialSpecular[<span class="const">4</span>]={<span class="const">1.0</span>,<span class="const">1.0</span>,<span class="const">1.0</span>,<span class="const">1.0</span>};
    <span class="rem">// Запись цвета материала в массив</span>
    MaterialAmbDiff[<span class="const">0</span>]=cR;
    MaterialAmbDiff[<span class="const">1</span>]=cG;
    MaterialAmbDiff[<span class="const">2</span>]=cB;
    MaterialAmbDiff[<span class="const">3</span>]=<span class="const">1.0</span>; <span class="rem">// Непрозрачный</span>
    <span class="rem">// Установка отражающих свойств (материала) фигуры</span>
    <span id="light_ref62">glMaterialfv</span>(GL_FRONT_AND_BACK,GL_AMBIENT_AND_DIFFUSE,MaterialAmbDiff);
    <span id="light_ref63">glMaterialf</span>(GL_FRONT_AND_BACK,GL_SHININESS, <span class="const">50.0</span>);
    glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,MaterialSpecular);
    <span class="rem">// Нормаль – по оси Z (окружность в плоскости XY)</span>
    glNormal3f(<span class="const">0</span>.<span class="const">0</span>,<span class="const">0</span>.<span class="const">0</span>,<span class="const">1.0</span>);
    <span class="rem">// Рисуем замкнутую ломаную линию</span>
    <span id="light_ref64">glBegin</span>(<span id="light_ref65">GL_LINE_LOOP</span>);
      <span class="kw">for</span>(<span class="kw">int</span> j=<span class="const">0</span>;j&lt;N;j++) <span class="rem">// Цикл по углу</span>
        { <span class="kw">double</span> a=aStep*j; <span class="rem">// Угол</span>
          <span class="kw">double</span> x=R*cos(a),y=R*sin(a); <span class="rem">// Координаты точки</span>
          glVertex3f((GLfloat)x,(GLfloat)y,<span class="const">0</span>);
        }
    <span id="light_ref66">glEnd</span>();
  }
  <span class="rem">//=================================================</span></pre>

<p>В функцию передаются радиус окружности <span class="cpp">R</span>, число звеньев ломаной <span class="cpp">N</span>
и три компоненты цвета окружности <span class="cpp"></span>, <span class="cpp">cG</span> и <span class="cpp">cB</span>
(красный, зеленый и синий соответственно). При задании компонент цвета вещественными числами (например, типа
<span class="cpp">GLfloat</span>, как в данном случае) считается, что интенсивность компоненты изменяется от 0
(минимум) до 1 (максимальная интенсивность). Поскольку мы используем при построении фигур расчет освещенности,
для трехмерных объектов недостаточно простого задания цветов их точек и поверхностей. Необходимо задать отражающие
свойства этих поверхностей, в терминологии OpenGL &ndash; параметры <i>материала</i>. Фактически эти свойства аналогичны
цвету: например, если материал отражает зеленый цвет на 100%, а красный и синий &ndash; на 0%, то при
освещении белым светом он будет выглядеть зеленым. Кроме того, может задаваться степень прозрачности материала,
также изменяющаяся от 0 (полностью прозрачный) до 1 (непрозрачный). В OpenGL задается несколько
параметров материала для разных типов освещения (окружающего, рассеянного и т.п.). Целью данного примера не
является подробный разбор особенностей библиотеки OpenGL, поэтому не будем подробно останавливаться на
принципах расчета освещенности (все это подробно описано, например, в
&laquo;OpenGL Programming Guide&raquo;).</p>

<p>В начале функции вычисляется угол <span class="cpp">aStep</span> между условными линиями, соединяющими
соседние точки ломаной, изображающей окружность, и ее центр (при числе сегментов ломаной
<span class="cpp">N</span> он будет равен 2&pi;/<span class="cpp">N</span>) и отводятся два вспомогательных
массива, которые будут использованы для задания свойств материала окружности. Далее в первые три
элемента массива <span class="cpp">MaterialAmbDiff</span> записываются переданные компоненты цвета окружности
<span class="cpp">cR</span>, <span class="cpp">cG</span> и <span class="cpp">cB</span>. В четвертый элемент
записывается число 1, указывающее на непрозрачность данного объекта. После этого занесенные в массивы
параметры устанавливаются в качестве текущего материала для разных типов освещения функциями
<span class="cpp">glMaterialfv</span> и <span class="cpp">glMaterialf</span>. Теперь все точки
многоугольников будут получать эти параметры материала.</p>

<p>Затем функцией <span class="cpp">glNormal3f</span> устанавливается нормаль к окружности. В отличие от
функции <span class="cpp">glNormal3fv</span>, использовавшейся ранее, функция принимает координаты не в
массиве, а в трех отдельных параметрах <span class="cpp">GLfloat</span>, о чем говорит суффикс
&laquo;<span class="cpp">3f</span>&raquo;  Окружность строится в плоскости <i>XY</i>, поэтому нормаль будем считать направленной
вдоль оси <i>Z</i>, то есть координаты единичного вектора будут (0,0,1).</p>

<p>Далее начинаем строить ломаную линию. Необходимо указать библиотеке OpenGL, что последовательно передаваемые ей
координаты точек должны быть соединены отрезками, причем последняя переданная точка должна соединяться с первой,
то есть линия должна быть замкнутой. Построение любой геометрической фигуры в OpenGL начинается с вызова функции
<span class="cpp">glBegin</span>, в параметре которой указывается тип фигуры. В данном случае это константа
<span class="cpp">GL_LINE_LOOP</span>, обозначающая замкнутую ломаную линию. Завершает построение фигуры вызов
функции <span class="cpp">glEnd</span>. Между этими вызовами находится цикл, в котором координаты <i>x</i> и
<i>y</i> точек окружности радиусом <span class="cpp">R</span> последовательно вычисляются тригонометрическими функциями
и передаются в библиотеку вызовом <span class="cpp">glVertex3f</span>. Для точки окружности с номером
<span class="cpp">i</span> угол <span class="cpp">a</span> к этой точке будет равен
<span class="cpp">i*aStep</span>, а ее координаты <i>x</i> и <i>y</i> будут равны
<span class="cpp">R*cos(a)</span> и <span class="cpp">R*sin(a)</span> соответственно. Поскольку окружность лежит
в плоскости <i>XY</i>, координата <i>z</i> для всех точек равна нулю. При вызове
<span class="cpp">glBegin</span> был указан параметр <span class="cpp">GL_LINE_LOOP</span>, поэтому в
момент вызова <span class="cpp">glEnd</span> последняя переданная точка
будет соединена отрезком с первой.</p>

<p>Наконец, напишем функцию, которая будет строить центральный объект блока согласно
<a href="#pic4" title="Центральный объект блока">рис.&nbsp;68</a>. Все параметры, указанные на рисунке
(<i>R</i>, <i>b</i>, <i>l</i>, <i>w</i>, <i>h</i>) будут параметрами этой функции. Нижний треугольник объекта
P<sub>1</sub>-P<sub>3</sub>-P<sub>2</sub> будет находиться в плоскости <i>XY</i>, причем точка
P<sub>1</sub> будет лежать на оси <i>Y</i>, а отрезок
P<sub>2</sub>-P<sub>3</sub> будет параллелен оси <i>X</i>. Точка <i>O</i> будет совпадать с началом координат.
В этой функции точки объекта не будут пересчитываться при изменении углов курса, дифферента и крена
&ndash; этим будет заниматься преобразование координат OpenGL. Функция будет иметь следующий вид:</p>

<pre class="cpp">  <span class="rem">// </span><span id="ref67"><span class="rem">Рисование</span></span><span class="rem"> центрального объекта блока</span>
  <span class="kw">void</span> <span id="light_ref67">DrawArrowGL</span>(<span class="kw">double</span> R,<span class="kw">double</span> l,<span class="kw">double</span> w,<span class="kw">double</span> h,<span class="kw">double</span> b)
  { <span class="rem">// Массивы для координат точек фигуры</span>
    GLfloat p1[<span class="const">3</span>],p2[<span class="const">3</span>],p3[<span class="const">3</span>],p4[<span class="const">3</span>];
    <span class="rem">// Материал – дно и корма (белый цвет)</span>
    GLfloat MaterialBack[]  = {<span class="const">1.0</span>, <span class="const">1.0</span>, <span class="const">1.0</span>, <span class="const">1.0</span>};
    <span class="rem">// Материал – левый борт (красный цвет)</span>
    GLfloat MaterialLeft[]  = {<span class="const">1.0</span>, <span class="const">0</span>.<span class="const">5</span>, <span class="const">0</span>.<span class="const">5</span>, <span class="const">1.0</span>};
    <span class="rem">// Материал – правый борт (зеленый цвет)</span>
    GLfloat MaterialRight[] = {<span class="const">0</span>.<span class="const">5</span>, <span class="const">1.0</span>, <span class="const">0</span>.<span class="const">5</span>, <span class="const">1.0</span>};

    <span class="rem">// Символические имена для координат точек</span>
    <span class="preproc">#define x 0</span>
    <span class="preproc">#define y 1</span>
    <span class="preproc">#define z 2</span>

    <span class="rem">// Вычисление координат точек фигуры</span>
    p1[x]=<span class="const">0</span>;  p1[y]=R;       p1[z]=<span class="const">0</span>;
    p2[x]=-w; p2[y]=R-l;     p2[z]=<span class="const">0</span>;
    p3[x]=w;  p3[y]=p2[y];   p3[z]=<span class="const">0</span>;
    p4[x]=<span class="const">0</span>;  p4[y]=p2[y]+b; p4[z]=h;

    <span class="rem">// Построение граней</span>
    glBegin(<span id="light_ref68">GL_TRIANGLES</span>);
      <span class="rem">// Свойства материала – общие для всех</span>
      glMaterialf(GL_FRONT,GL_SHININESS,<span class="const">20.0</span>);
      <span class="rem">// Свойства материала – корма и дно</span>
      glMaterialfv(GL_FRONT,GL_AMBIENT_AND_DIFFUSE,MaterialBack);
      glMaterialfv(GL_FRONT,GL_SPECULAR,MaterialBack);
      <span class="rem">// Нижний треугольник (дно)</span>
      <a class="hidden" href="#ref58" title="Функция построения треугольника">DrawTriangleGL</a>(p1,p3,p2);
      <span class="rem">// Задний треугольник (корма)</span>
      <a class="hidden" href="#ref58" title="Функция построения треугольника">DrawTriangleGL</a>(p2,p3,p4);
      <span class="rem">// Свойства материала – левый борт</span>
      glMaterialfv(GL_FRONT,GL_AMBIENT_AND_DIFFUSE,MaterialLeft);
      glMaterialfv(GL_FRONT,GL_SPECULAR,MaterialLeft);
      <span class="rem">// Левый передний треугольник</span>
      <a class="hidden" href="#ref58" title="Функция построения треугольника">DrawTriangleGL</a>(p2,p4,p1);
      <span class="rem">// Свойства материала – правый борт</span>
      glMaterialfv(GL_FRONT,GL_AMBIENT_AND_DIFFUSE,MaterialRight);
      glMaterialfv(GL_FRONT,GL_SPECULAR,MaterialRight);
      <span class="rem">// Правый передний треугольник</span>
      <a class="hidden" href="#ref58" title="Функция построения треугольника">DrawTriangleGL</a>(p4,p3,p1);
    glEnd();

    <span class="rem">// Отмена макроопределений символических имен координат</span>
    <span class="preproc">#undef x</span>
    <span class="preproc">#undef y</span>
    <span class="preproc">#undef z</span>
  }
  <span class="rem">//=================================================</span></pre>

<p>Для всех четырех точек фигуры в начале функции отводятся трехэлементные массивы вещественных чисел
<span class="cpp">p1</span>, <span class="cpp">p2</span>, <span class="cpp">p3</span> и <span class="cpp">p4</span> &ndash;
в этих массивах будут храниться вычисленные координаты точек, они же буду передаваться в функцию
<span class="cpp"><a class="hidden" href="#ref58" title="Функция построения треугольника">DrawTriangleGL</a></span> для построения граней фигуры. Кроме того, описываются три
четырехэлементных массива параметров материала: <span class="cpp">MaterialBack</span> для дна и кормы объекта,
<span class="cpp">MaterialLeft</span> для левого борта и <span class="cpp">MaterialRight</span> для правого.
Эти массивы сразу заполняются значениями, соответствующими белому, красному и зеленому цветам. Далее, как
и в уже описанной функции <span class="cpp"><a class="hidden" href="#ref57" title="Функция вычисления нормали к треугольнику">NormalToTriangle</a></span>, вводятся макроопределения для индексов
массивов координат, и, согласно значениям  <i>R</i>, <i>l</i>, <i>w</i>, <i>h</i> и <i>b</i>, в массивах
<span class="cpp">p1</span>, <span class="cpp">p2</span>, <span class="cpp">p3</span> и <span class="cpp">p4</span>
вычисляются координаты всех четырех точек фигуры.</p>

<p>Теперь, когда координаты вычислены, можно приступать к построению граней. Сначала вызывается функция
<span class="cpp">glBegin</span> с параметром <span class="cpp">GL_TRIANGLES</span>, указывающим на то,
что следующие за этим вызовом тройки точек будут описывать отдельные треугольники. Далее поочередно
устанавливаются параметры материала каждой грани и вызывается функция
<span class="cpp"><a class="hidden" href="#ref58" title="Функция построения треугольника">DrawTriangleGL</a></span>, описанная выше. Каждый ее вызов передает библиотеке тройку
точек, которые интерпретируются как вершины треугольника соответствующей грани. После того, как все четыре
грани построены, вызывается функция <span class="cpp">glEnd</span>.</p>

<p>Все описанные выше функции были вспомогательными, они не относились к классу личной области данных блока.
Теперь займемся функциями-членами класса, и начнем с функции настройки вывода OpenGL на панель:</p>

<pre class="cpp">  <span class="rem">// </span><span id="ref69"><span class="rem">Настройка</span></span><span class="rem"> вывода изображения на панель</span>
  <span class="kw">void</span> <span id="light_ref69">TOpenGLInstr::InitWindow</span>(<a class="hidden" href="app_ids.htm#light_ref18" title="Дескриптор окна">HWND</a> window)
  { <span id="light_ref70"><a class="hidden" href="app_ids.htm#light_ref16" title="Контекст устройства Windows">HDC</a></span> Hdc; <span class="rem">// Контекст устройства Windows</span>
    <span class="rem">// Структура для установки формата изображения</span>
    <span id="light_ref71">PIXELFORMATDESCRIPTOR</span> pfd = {
    <span class="kw">sizeof</span>(PIXELFORMATDESCRIPTOR),<span class="rem">// Размер структуры</span>
      <span class="const">1</span>,                          <span class="rem">// Номер версии</span>
      PFD_DRAW_TO_WINDOW |        <span class="rem">// Вывод в окно</span>
        PFD_SUPPORT_OPENGL |      <span class="rem">// Поддержка OpenGL</span>
        PFD_DOUBLEBUFFER,         <span class="rem">// Двойная буферизация</span>
      PFD_TYPE_RGBA,              <span class="rem">// Формат цвета – RGBA</span>
      <span class="const">24</span>,                         <span class="rem">// Глубина цвета – 24 бита</span>
      <span class="const">0</span>,<span class="const">0</span>,<span class="const">0</span>,<span class="const">0</span>,<span class="const">0</span>,<span class="const">0</span>,                <span class="rem">// (здесь не используется)</span>
      <span class="const">0</span>,<span class="const">0</span>,<span class="const">0</span>,<span class="const">0</span>,<span class="const">0</span>,<span class="const">0</span>,<span class="const">0</span>,              <span class="rem">// (здесь не используется)</span>
      <span class="const">32</span>,                         <span class="rem">// Z-буфер - 32 бита</span>
      <span class="const">0</span>,<span class="const">0</span>,                        <span class="rem">// (здесь не используется)</span>
      PFD_MAIN_PLANE,             <span class="rem">// Главный слой</span>
      <span class="const">0</span>,                          <span class="rem">// Зарезервировано</span>
      <span class="const">0</span>,<span class="const">0</span>,                        <span class="rem">// Маски слоев (не исп.)</span>
      };
    <span class="kw">int</span> PixelFormat;

    <span class="rem">// Получение контекста оконного объекта</span>
    Hdc=<span id="light_ref72">GetDC</span>(window);

    <span class="rem">// Установка формата изображения по структуре pfd</span>
    PixelFormat=<span id="light_ref73">ChoosePixelFormat</span>ChoosePixelFormat(Hdc,&amp;pfd);
    <span id="light_ref74">SetPixelFormat</span>SetPixelFormat(Hdc,PixelFormat,&amp;pfd);

    <span class="rem">// Создание контекста OpenGL</span>
    Hrc=<span id="light_ref75">wglCreateContext</span>(Hdc);

    <span class="rem">// Установка этого контекста в качестве текущего</span>
    <span id="light_ref76">wglMakeCurrent</span>(Hdc,Hrc);
  }
  <span class="rem">//=================================================</span></pre>

<p>Эта функция получает в качестве параметра дескриптор оконного объекта, созданного RDS для панели.
Прежде чем выводить что-либо в это окно при помощи OpenGL, необходимо настроить формат изображения окна, а
для этого необходимо предварительно получить контекст рисования этого окна при помощи функции
<span class="cpp">GetDC</span>. Контекст записывается в локальную переменную <span class="cpp">Hdc</span>
(хотя этот контекст нам и потребуется позже в других функциях, лучше каждый раз получать его вызовом
<span class="cpp">GetDC</span> для оконного объекта панели). Теперь для полученного контекста можно установить
формат изображения при помощи функций Windows API <span class="cpp">ChoosePixelFormat</span> и
<span class="cpp">SetPixelFormat</span>, при этом сами параметры изображения задаются в структуре
<span class="cpp">pfd</span> типа <span class="cpp">PIXELFORMATDESCRIPTOR</span> (подробные
описания функций и структуры см. в Windows API). В данном случае важно, что мы запрашиваем поддержку OpenGL
(флаг <span class="cpp">PFD_SUPPORT_OPENGL</span>), двойную буферизацию (флаг
<span class="cpp">PFD_DOUBLEBUFFER</span>), двадцатичетырехбитный цвет формата RGBA (то
есть цвет каждого цветового канала задается отдельно одни байтом) и тридцатидвухбитный Z-буфер.
Двойная буферизация позволяет иметь два буфера изображения: в одном, невидимом, производится рисование, а
другой в это время изображается на экране. Когда изображение нарисовано полностью, буферы меняются местами &ndash;
новое изображение появляется на экране, а буфер со старым изображением становится невидимым и в нем можно
готовить к показу следующий кадр. Такой режим работы существенно улучшает анимацию, убирая мигания изображения
при перерисовке, т.к. она производится в невидимом буфере.</p>

<p>В Z-буфере для каждой точки изображения хранится &laquo;глубина&raquo; &ndash; третья координата,
перпендикулярная плоскости проекции. Этот буфер используется для отсечения частей трехмерных объектов,
перекрытых другими объектами. Перед записью очередной точки объекта в буфер изображения ее
глубина сравнивается с уже записанной в Z-буфере. Если новая точка располагается дальше от переднего плана,
чем уже записанная, она отбрасывается, если ближе &ndash; записывается в буфер изображения и ее глубина
записывается в Z-буфер. Чем выше разрядность Z-буфера, тем точнее будут сравниваться точки по глубине,
и тем правильнее будет происходить рисование перекрывающихся (особенно, близко расположенных или пересекающихся)
объектов. Тридцати двух бит хватит для большинства случаев, тем более, для такого простого изображения,
как наше.</p>

<p>После того, как формат изображения в контексте рисования установлен, при помощи функции
<span class="cpp">wglCreateContext</span> создается контекст OpenGL, который записывается в поле
класса <span class="cpp">Hrc</span> &ndash; он нам понадобится в функциях рисования. Все функции рисования OpenGL
работают с текущим контекстом, поэтому, перед их вызовом, необходимо установить какой-либо контекст рисования
в качестве текущего. В конце этой функции мы делаем текущим только что созданный контекст.</p>

<p>Перед завершением работы с трехмерной графикой необходимо уничтожить созданный контекст OpenGL. Для
этого напишем функцию <span class="cpp">Clear</span> и будем вызывать ее из модели перед уничтожением
оконного объекта:</p>

<pre class="cpp">  <span class="rem">// </span><span id="ref77"><span class="rem">Настройка</span></span><span class="rem"> OpenGL</span>
  <span class="kw">void</span> <span id="light_ref77">TOpenGLInstr::Clear</span>(<span class="kw">void</span>)
  { <span class="rem">// Отключение текущего контекста OpenGL</span>
    wglMakeCurrent(NULL,NULL);
    <span class="rem">// Уничтожение созданного контекста</span>
    wglDeleteContext(Hrc);
  }
  <span class="rem">//=================================================</span></pre>

<p>В этой функции всего два вызова: сначала при помощи
<span class="cpp">wglMakeCurrent</span> с параметром <span class="cpp">NULL</span> отключается текущий контекст
(чтобы не удалить выбранный), а затем функцией <span class="cpp">wglDeleteContext</span> созданный ранее в
<span class="cpp"><a href="#ref69" title="Настройка вывода изображения на панель">InitWindow</a></span> контекст удаляется.</p>

<p>Теперь запишем служебную функцию, которая будет выполнять настройки OpenGL перед рисованием:</p>

<pre class="cpp">  <span class="rem">// </span><span id="ref78"><span class="rem">Служебная</span></span><span class="rem"> функция – настройка параметров OpenGL</span>
  <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> <span id="light_ref78">TOpenGLInstr::SetupGLParams</span>(<a class="hidden" href="app_ids.htm#light_ref16" title="Контекст устройства Windows">HDC</a> *pHdc)
  { <span class="rem">// Параметры перспективной проекции</span>
    <span class="kw">const</span> GLfloat zNear=<span class="const">0</span>.<span class="const">1</span>;   <span class="rem">// Ближняя плоскость отсечения</span>
    <span class="kw">const</span> GLfloat zFar=<span class="const">1000.0</span>; <span class="rem">// Дальняя плоскость отсечения</span>
    <span class="kw">const</span> GLfloat vAngle=<span class="const">30.0</span>; <span class="rem">// Угол зрения</span>

    <a class="hidden" href="app_ids.htm#light_ref16" title="Контекст устройства Windows">HDC</a> Hdc;	<span class="rem">// Контекст устройства (окна) Windows</span>

    <span class="rem">// Расположение источника освещения</span>
    <span class="kw">const</span> <span class="kw">double</span> lightDistance=<span class="const">500.0</span>; <span class="rem">// Расстояние до объекта</span>
    <span class="kw">const</span> <span class="kw">double</span> lightRotation=-<span class="const">55.0</span>; <span class="rem">// Азимут в градусах</span>
    <span class="kw">const</span> <span class="kw">double</span> lightPitch=<span class="const">45.0</span>;     <span class="rem">// Угол места в градусах</span>

    <span class="rem">// Вспомогательные переменные</span>
    <span id="light_ref79"><a class="hidden" href="RDS_PANDESCRIPTION.htm#ref1" title="Структура RDS_PANDESCRIPTION">RDS_PANDESCRIPTION</a></span> descr;
    <span class="kw">int</span> width,height;
    GLfloat array[<span class="const">4</span>];
    <span class="kw">double</span> l_r,l_p;

    <span class="rem">// Получение описания панели и дескриптора ее окна</span>
    descr.servSize=<span class="kw">sizeof</span>(<a class="hidden" href="RDS_PANDESCRIPTION.htm#ref1" title="Структура RDS_PANDESCRIPTION">RDS_PANDESCRIPTION</a>);
    <span class="kw">if</span>(!<span id="light_ref80"><a class="hidden" href="rdsPANGetDescr.htm" title="А.5.31.2. rdsPANGetDescr &ndash; получить описание панели">rdsPANGetDescr</a></span>(Panel,&amp;descr)) <span class="rem">// Не удалось</span>
      <span class="kw">return</span> FALSE;
    <span class="kw">if</span>(descr.Handle==NULL) <span class="rem">// Нет оконного объекта</span>
      <span class="kw">return</span> FALSE;
    <span class="rem">// Проверка высоты и ширины панели</span>
    <span class="kw">if</span>(descr.Height==<span class="const">0</span> || descr.Width==<span class="const">0</span>)
      <span class="kw">return</span> FALSE; <span class="rem">// Негде рисовать</span>

    <span class="rem">// Получение контекста окна и передача в вызвавшую функцию</span>
    <span class="rem">// его через параметр-указатель</span>
    Hdc=GetDC(descr.Handle);
    <span class="kw">if</span>(pHdc) *pHdc=Hdc;

    <span class="rem">// Установка контекста Hrc, созданного при инициализации,</span>
    <span class="rem">// в качестве текущего</span>
    <span class="kw">if</span>(!wglMakeCurrent(Hdc,Hrc))
      <span class="kw">return</span> FALSE; <span class="rem">// Не удалось</span>

    <span class="rem">// Уcтановка различных параметров, влияющих на качество рисования</span>
    <span class="rem">// и способ закраски многоугольников</span>
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_CULL_FACE);
    glHint(GL_POLYGON_SMOOTH_HINT,GL_FASTEST);
    glEnable(GL_POINT_SMOOTH);
    glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);

    glClearColor(<span class="const">0</span>.0f,<span class="const">0</span>.0f,<span class="const">0</span>.0f,<span class="const">1.0</span>f); <span class="rem">// Цвет фона - черный</span>
    glClearDepth(<span class="const">1.0</span>); <span class="rem">// Значение для очистки Z-буфера</span>

    <span class="rem">//----------- Установка освещения ----------</span>
    <span class="rem">// Общее рассеянное освещение</span>
    array[<span class="const">0</span>]=array[<span class="const">1</span>]=array[<span class="const">2</span>]=<span class="const">0</span>.<span class="const">5</span>; <span class="rem">// Белый, интенсивность 0.5</span>
    array[<span class="const">3</span>]=<span class="const">1.0</span>;
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT,array);
    <span class="rem">// Вычисление координат источника света</span>
    l_r=(lightRotation*M_PI)/<span class="const">180.0</span>;
    l_p=(lightPitch*M_PI)/<span class="const">180.0</span>;
    array[<span class="const">0</span>]=(GLfloat)(lightDistance*cos(l_p)*sin(l_r)); <span class="rem">// X</span>
    array[<span class="const">1</span>]=(GLfloat)(lightDistance*sin(l_p));          <span class="rem">// Y</span>
    array[<span class="const">2</span>]=(GLfloat)(lightDistance*cos(l_p)*cos(l_r)); <span class="rem">// Z</span>
    array[<span class="const">3</span>]=<span class="const">0</span>.<span class="const">0</span>;
    glLightfv(GL_LIGHT0,GL_POSITION,array);
    <span class="rem">// Рассеянное освещение от источника отсутствует</span>
    array[<span class="const">0</span>]=array[<span class="const">1</span>]=array[<span class="const">2</span>]=<span class="const">0</span>.<span class="const">0</span>; <span class="rem">// Отсутствует - интенсивность 0</span>
    array[<span class="const">3</span>]=<span class="const">1.0</span>;
    glLightfv(GL_LIGHT0,GL_AMBIENT,array);
    <span class="rem">// Другие виды освещения – белый цвет</span>
    array[<span class="const">0</span>]=array[<span class="const">1</span>]=array[<span class="const">2</span>]=<span class="const">0</span>.<span class="const">5</span>; <span class="rem">// Белый, интенсивность 0.5</span>
    glLightfv(GL_LIGHT0,GL_DIFFUSE,array);
    glLightfv(GL_LIGHT0,GL_SPECULAR,array);
    <span class="rem">// Включение источника света</span>
    glEnable(GL_LIGHT0);
    <span class="rem">// Разрешение расчета освещения</span>
    glEnable(GL_LIGHTING);
    <span class="rem">// Режим расчета “затенения"</span>
    glShadeModel(GL_SMOOTH);
    <span class="rem">// Способ расчета освещения</span>
    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE);
    <span class="rem">//------------------------------------------</span>

    <span class="rem">// Установка области окна для рисования</span>
    glViewport(<span class="const">0</span>,<span class="const">0</span>,descr.Width,descr.Height);

    <span class="rem">// Настройка перспективной проекции на эту область</span>
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(vAngle,
      (GLfloat)descr.Width/(GLfloat)descr.Height,
      zNear,zFar);

    <span class="rem">// Переключение на матрицу моделей (для рисования объектов)</span>
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    <span class="kw">return</span> TRUE; <span class="rem">// Установка параметров успешно завершена</span>
  }
  <span class="rem">//=================================================</span></pre>

<p>Функция принимает единственный параметр &ndash; указатель на контекст устройства Windows.
Через него она вернет в вызвавшую функцию контекст окна панели, на которой будет рисоваться трехмерное
изображение. В вызвавшей функции, конечно, можно было бы получить этот контекст при помощи вызова
<span class="cpp">GetDC</span>, но, поскольку <span class="cpp"><a class="hidden" href="#ref78" title="Функция настройки параметров OpenGL">SetupGLParams</a></span> все равно его
получает, можно этим воспользоваться. Возвращает эта функция логическое значение, указывающее на
успешность установки параметров. Если параметры установить не удалось (например, при невидимой панели,
не имеющей связанного оконного объекта), пытаться что-либо рисовать бессмысленно.</p>

<p>Большая часть функции состоит из вызовов OpenGL для установки режимов, настройки освещения и
перспективной проекции и т.п. Короткие пояснения к этим вызовам вставлены непосредственно в текст функции,
мы не будем разбирать их более подробно. Исчерпывающая информация по этим функциям находится в описании
OpenGL. Детально рассмотрим только привязку области вывода OpenGL к оконному объекту панели.</p>

<p>Сразу после описаний вспомогательных переменных вызывается сервисная функция RDS
<span class="cpp"><a href="rdsPANGetDescr.htm" title="А.5.31.2. rdsPANGetDescr &ndash; получить описание панели">rdsPANGetDescr</a></span>, которая записывает описание панели <span class="cpp">Panel</span> в структуру
<span class="cpp">descr</span> типа <span class="cpp"><a href="RDS_PANDESCRIPTION.htm#ref1" title="Структура RDS_PANDESCRIPTION">RDS_PANDESCRIPTION</a></span>. В этой структуре много полей,
соответствующих различным параметрам панели, но нас будут интересовать только три: дескриптор окна
<span class="cpp">Handle</span>, ширина окна <span class="cpp">Width</span> и его высота
<span class="cpp">Height</span>. Прежде всего, мы сравниваем полученный дескриптор с <span class="cpp">NULL</span>
&ndash; если дескриптор нулевой, окно для панели еще не создано, и настраивать OpenGL и рисовать что-либо
бессмысленно (функция возвращает <span class="cpp">FALSE</span>). В противном случае высота и ширина оконного
объекта также сравниваются с нулем &ndash; если хотя бы один из размеров окна нулевой, рисовать будет негде.
Следует помнить, что для панелей с рамкой создаваемый внутри них оконный объект меньше самой панели
на размер рамки, при этом <span class="cpp">Width</span> и <span class="cpp">Height</span> в структуре
<span class="cpp"><a class="hidden" href="RDS_PANDESCRIPTION.htm#ref1" title="Структура RDS_PANDESCRIPTION">RDS_PANDESCRIPTION</a></span> всегда указывают именно размер оконного объекта, а не
самой панели. Вызов <span class="cpp">glViewport</span>, устанавливающий область рисования в окне,
задает в качестве верхнего левого угла прямоугольной области точку (0,0), а в качестве правого нижнего
&ndash; (<span class="cpp">descr.Width</span>,<span class="cpp">descr.Height</span>). Это полный размер
внутреннего оконного объекта панели.</p>

<p>Последняя функция-член класса личной области данных блока, которую мы опишем &ndash; функция построения
трехмерного изображения (часто называемого &laquo;сценой&raquo;) <span class="cpp">RenderScene</span>:</p>

<pre class="cpp">  <span class="rem">// </span><span id="ref81"><span class="rem">Рисование</span></span><span class="rem"> трехмерной сцены</span>
  <span class="kw">void</span> <span id="light_ref81">TOpenGLInstr::RenderScene</span>(<span class="kw">double</span> Dir,<span class="kw">double</span> List,<span class="kw">double</span> Pitch)
  { <a class="hidden" href="app_ids.htm#light_ref16" title="Контекст устройства Windows">HDC</a> Hdc; <span class="rem">// Контекст устройства Windows</span>
    <span class="rem">// Угол места камеры в градусах</span>
    <span class="kw">const</span> GLfloat Camera_Pitch=-<span class="const">50.0</span>;
    <span class="rem">// Расстояние до камеры</span>
    <span class="kw">const</span> GLfloat Camera_Distance=<span class="const">300.0</span>;

    <span class="rem">// Настройка параметров OpenGL и получение контекста окна</span>
    <span class="kw">if</span>(!<a class="hidden" href="#ref78" title="Функция настройки параметров OpenGL">SetupGLParams</a>(&amp;Hdc))
      <span class="kw">return</span>;

    <span class="rem">// Очистка буфера изображения и Z-буфера</span>
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    <span class="rem">// Записать матрицу трансформаций в стек</span>
    glPushMatrix();
    <span class="rem">// Трансформации камеры</span>
    glTranslatef(<span class="const">0</span>.<span class="const">0</span>,<span class="const">0</span>.<span class="const">0</span>,-Camera_Distance); <span class="rem">// Отодвигаем от камеры</span>
    glRotatef(Camera_Pitch,<span class="const">1</span>,<span class="const">0</span>,<span class="const">0</span>);          <span class="rem">// Поворачиваем</span>
    <span class="rem">// Рисование неподвижной зеленой (0,1,0) окружности</span>
    <a class="hidden" href="#ref61" title="Функция рисования окружности">DrawCircleGL</a>(<span class="const">60</span>,<span class="const">100</span>,<span class="const">0</span>.<span class="const">0</span>,<span class="const">1.0</span>,<span class="const">0</span>.<span class="const">0</span>);

    <span class="kw">if</span>(Dir!=<a class="hidden" href="pm_2_5_1.htm#ref12" title="Проверка вещественного числа на признак ошибки">DoubleErrorValue</a> &amp;&amp;
       List!=<a class="hidden" href="pm_2_5_1.htm#ref12" title="Проверка вещественного числа на признак ошибки">DoubleErrorValue</a> &amp;&amp;
       Pitch!=<a class="hidden" href="pm_2_5_1.htm#ref12" title="Проверка вещественного числа на признак ошибки">DoubleErrorValue</a>) <span class="rem">// Можно рисовать</span>
      { <span class="rem">// Поворот на угол курса</span>
        <span class="kw">if</span>(Dir!=<span class="const">0</span>.<span class="const">0</span>)
          glRotatef(Dir,<span class="const">0</span>,<span class="const">0</span>,<span class="const">1</span>);
        <span class="rem">// Поворот на угол дифферента</span>
        <span class="kw">if</span>(Pitch!=<span class="const">0</span>.<span class="const">0</span>)
          glRotatef(Pitch,<span class="const">1</span>,<span class="const">0</span>,<span class="const">0</span>);
        <span class="rem">// Поворот на угол крена</span>
        <span class="kw">if</span>(List!=<span class="const">0</span>.<span class="const">0</span>)
          glRotatef(-List,<span class="const">0</span>,<span class="const">1</span>,<span class="const">0</span>);

        <span class="rem">// Рисование подвижной белой (1,1,1) окружности</span>
        <a class="hidden" href="#ref61" title="Функция рисования окружности">DrawCircleGL</a>(<span class="const">55</span>,<span class="const">100</span>,<span class="const">1.0</span>,<span class="const">1.0</span>,<span class="const">1.0</span>);
        <span class="rem">// Рисование центрального объекта</span>
        <a class="hidden" href="#ref67" title="Функция рисования центрального объекта блока">DrawArrowGL</a>(<span class="const">50</span>,<span class="const">80</span>,<span class="const">30</span>,<span class="const">10</span>,<span class="const">10</span>);
      }
    <span class="rem">// Восстановить матрицу трансформаций из стека</span>
    glPopMatrix();
    <span class="rem">// Завершить незавершенное рисование, если нужно</span>
    glFlush();
    <span class="rem">// Поменять местами видимый и рабочий буферы</span>
    SwapBuffers(Hdc);
  }
  <span class="rem">//=================================================</span></pre>

<p>Функция принимает три вещественных параметра: <span class="cpp">Dir</span> (курс),
<span class="cpp">List</span> (крен) и <span class="cpp">Pitch</span> (дифферент), они используются для
поворота центрального объекта при рисовании. Внутри функции прежде всего вызывается
<span class="cpp"><a href="#ref78" title="Функция настройки параметров OpenGL">SetupGLParams</a></span>, настраивающая параметры OpenGL и
устанавливающая текущий контекст рисования. Если параметры настроить не удалось, функция вернет
<span class="cpp">FALSE</span>, и
<span class="cpp">RenderScene</span> немедленно завершится. Конечно, можно было бы не настраивать все
параметры OpenGL при каждом рисовании, но целью этого примера является демонстрация принципиальной возможности работы
с OpenGL на панелях в окне подсистемы, а не оптимизация рисования. К тому же, без этой оптимизации
модель блока будет значительно проще, что сделает пример более понятным.</p>

<p>Сразу после настройки функция очищает рабочий буфер изображения и Z-буфер, заполняя их значениями по
умолчанию. Эти значения задаются в <span class="cpp"><a class="hidden" href="#ref78" title="Функция настройки параметров OpenGL">SetupGLParams</a></span>: для
буфера изображения &ndash; черный цвет, для Z-буфера &ndash; максимально возможная дальность (1.0).
После этого рабочая матрица OpenGL (в данный момент &ndash; матрица, определяющая трансформации системы
координат) помещается в стек функцией <span class="cpp">glPushMatrix</span>. Стек матриц &ndash;
удобная возможность OpenGL, позволяющая быстро возвращаться к исходной системе координат. Например, если
нужно нарисовать какой-то повернутый объект в стороне от начала текущей системы координат, можно поместить
матрицу в стек, затем передвинуть систему координат, повернуть ее, нарисовать объект в начале координат
(он будет смещенным и повернутым), а затем, вместо того, чтобы поворачивать и перемещать систему
координат обратно, можно просто извлечь матрицу из стека, что приведет к немедленному возврату к
старой системе координат. Помещая исходную систему координат в стек перед различными трансформациями,
мы получаем возможность быстро вернуться к исходной.</p>

<p>Первыми выполняются трансформации &laquo;камеры&raquo;, то есть точки наблюдения. Функция
<span class="cpp"><a href="#ref67" title="Функция рисования центрального объекта блока">DrawArrowGL</a></span>, которую мы написали ранее, строит объект в начале
координат, поэтому, если систему координат не переместить, точка наблюдения (начало координат)
будет находиться внутри объекта. Чтобы наблюдать объект со стороны, мы перемещаем систему координат на
расстояние <span class="cpp">Camera_Distance</span> вдоль оси <i>Z</i> в отрицательном направлении функцией
OpenGL <span class="cpp">glTranslatef</span>, а затем поворачиваем ее на угол
<span class="cpp">Camera_Pitch</span> вокруг оси <i>X</i> функцией
<span class="cpp">glRotatef</span> (<span class="cpp">Camera_Distance</span> и
<span class="cpp">Camera_Pitch</span> &ndash; константы, описанные в начале функции). Теперь
&laquo;камера&raquo; смотрит на начало координат, где будет построен объект, сзади и немного сверху.</p>

<p>Далее вызовом <span class="cpp"><a href="#ref61" title="Функция рисования окружности">DrawCircleGL</a></span> строится неподвижная окружность зеленого
цвета (красный и синий компоненты цвета &ndash; нулевые, зеленый &ndash; единица) радиусом 60. Эта
окружность лежит в горизонтальной плоскости и не поворачивается вместе с объектом, поэтому для
нее никаких трансформаций не требуется.</p>

<p>Теперь нужно нарисовать объект и подвижную окружность, повернутые согласно трем заданным
угловым координатам. Прежде всего, нужно сравнить полученные функцией значения углов со
специальным значением, сигнализирующим об ошибке вычислений. Это значение получено из
RDS в главной функции DLL и помещено в глобальную переменную
<span class="cpp"><a href="pm_2_5_1.htm#ref12" title="Проверка вещественного числа на признак ошибки">DoubleErrorValue</a></span>. Такие проверки, как уже не раз отмечалось,
нужно выполнять для всех значений, которые передаются из других блоков. Если все три значения углов
&ndash; допустимые, можно приступать к рисованию.</p>

<p>Для поворота системы координат, в которой будут строиться объект и окружность, используются функции OpenGL
<span class="cpp">glRotatef</span>. Каждый из трех поворотов выполняется вокруг определенной оси координат &ndash;
координаты вектора оси поворота задают три последних параметра функции. Поворот на угол курса выполняется
вокруг оси <i>Z</i>, на угол дифферента &ndash; вокруг оси <i>X</i>, на угол крена &ndash; вокруг оси
<i>Y</i>, это в точности соответствует
рис. 67.
После поворотов вызывается функция <span class="cpp"><a class="hidden" href="#ref61" title="Функция рисования окружности">DrawCircleGL</a></span> для построения
белой окружности радиусом 55, и <span class="cpp"><a class="hidden" href="#ref67" title="Функция рисования центрального объекта блока">DrawArrowGL</a></span> для построения
центрального объекта (размеры объекта, как и радиусы окружностей и расстояние до точки наблюдения,
подобраны вручную).</p>

<p>После того, как изображение построено, мы возвращаемся к исходной системе координат, извлекая ее
из стека функцией <span class="cpp">glPopMatrix</span>, завершаем все незавершенные операции рисования функцией
<span class="cpp">glFlush</span> и меняем местами рабочий буфер с отображаемым буфером функцией
<span class="cpp">SwapBuffers</span>. После этого то, что мы только что нарисовали, будет изображаться
на панели. Старое изображение, показывавшееся до этого, оказывается в рабочем буфере &ndash;
оно будет стерто и заменено новым кадром при следующем вызове.</p>

<p>Теперь все функции класса написаны &ndash; можно добавить в модель блока их вызовы. Но прежде
нужно добавить в блок входы, через которые он будет получать значения курса, дифферента и крена:</p>

<div class="tablecenter"><div class="tcont">
<table>

  <tr>
    <th>Смещение</th>
    <th>Имя</th>
    <th>Тип</th>
    <th>Размер</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr><tr><td class="center">0</td>
<td class="vcenter">Start</td>
<td class="center">Сигнал</td>
<td class="center">1</td>
<td class="center">Вход</td>
<td class="center">&checkmark;</td>
<td class="center">0</td>
</tr>
<tr><td class="center">1</td>
<td class="vcenter">Ready</td>
<td class="center">Сигнал</td>
<td class="center">1</td>
<td class="center">Выход</td>
<td></td>
<td class="center">0</td>
</tr>
<tr><td class="center">2</td>
<td class="vcenter">Dir</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Вход</td>
<td></td>
<td class="center">0</td>
</tr>
<tr><td class="center">10</td>
<td class="vcenter">List</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Вход</td>
<td></td>
<td class="center">0</td>
</tr>
<tr><td class="center">18</td>
<td class="vcenter">Pitch</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Вход</td>
<td></td>
<td class="center">0</td>
</tr>


</table>
</div></div>

<p>Теперь добавим в функцию модели новые вызовы и переменные. Изменения, как всегда, выделены
<span class="changes">цветом</span>:</p>
<pre class="cpp">  <span class="rem">// Модель блока с панелью</span>
  <span class="kw">extern</span> <span class="str">"C"</span> <span class="kw">__declspec</span>(<span class="kw">dllexport</span>) <span class="kw">int</span> <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> OpenGLInstr(
        <span class="kw">int</span> CallMode,
        <a class="hidden" href="RDS_BLOCKDATA.htm#ref2" title="Указатель на RDS_BLOCKDATA">RDS_PBLOCKDATA</a> BlockData,
        <a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> ExtParam)
  {
<div class="changes">  <span class="rem">// </span><a class="hidden" href="pm_2_5_1.htm#light_ref9" title="Макросы для статических переменных блока"><span class="rem">Макроопределения для статических переменных</span></a>
  <span class="preproc">#define pStart ((char *)(BlockData-&gt;VarData))</span>
  <span class="preproc">#define Start (*((char *)(pStart)))</span>
  <span class="preproc">#define Ready (*((char *)(pStart+1)))</span>
  <span class="preproc">#define Dir   (*((double *)(pStart+2)))</span>
  <span class="preproc">#define List  (*((double *)(pStart+10)))</span>
  <span class="preproc">#define Pitch (*((double *)(pStart+18)))</span></div>
    <span class="rem">// Указатель на личную область, приведенный к нужному типу</span>
    TOpenGLInstr *data=(TOpenGLInstr*)(BlockData-&gt;BlockData);
    <span class="rem">// Вспомогательная – указатель на структуру параметров при</span>
    <span class="rem">// действиях с панелью (будет использована в реакциях)</span>
    <a class="hidden" href="RDS_BFM_BLOCKPANEL.htm#ref2" title="Указатель на RDS_PANOPERATION">RDS_PPANOPERATION</a> param;

    <span class="kw">switch</span>(CallMode)
      { <span class="rem">// Инициализация блока</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_INIT.htm" title="А.2.4.7. RDS_BFM_INIT &ndash; инициализация блока">RDS_BFM_INIT</a>:
          <span class="rem">// Создание личной области данных</span>
          <span class="rem">// (при этом в конструкторе будет создана панель)</span>
          BlockData-&gt;BlockData=data=<span class="kw">new</span> TOpenGLInstr();
          <span class="kw">break</span>;

        <span class="rem">// Очистка данных блока</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_CLEANUP.htm" title="А.2.4.3. RDS_BFM_CLEANUP &ndash; очистка данных блока">RDS_BFM_CLEANUP</a>:
          <span class="rem">// В деструкторе класса панель будет уничтожена</span>
          <span class="kw">delete</span> data;
          <span class="kw">break</span>;

<div class="changes">        <span class="rem">// Проверка типа переменных</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_VARCHECK.htm" title="А.2.4.18. RDS_BFM_VARCHECK &ndash; проверка допустимости структуры статических переменных блока">RDS_BFM_VARCHECK</a>:
          <span class="kw">if</span>(strcmp((<span class="kw">char</span>*)ExtParam,<span class="str">"{SSDDD}"</span>))
            <span class="kw">return</span> <a class="hidden" href="RDS_BFM_VARCHECK.htm#light_ref3" title="Возврат RDS_BFR_BADVARSMSG">RDS_BFR_BADVARSMSG</a>;
          <span class="kw">return</span> <a class="hidden" href="app_a_2_1.htm#ref2" title="Возврат RDS_BFR_DONE">RDS_BFR_DONE</a>;</div>
        <span class="rem">// Запуск расчета</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_STARTCALC.htm" title="А.2.4.14. RDS_BFM_STARTCALC &ndash; запуск расчета">RDS_BFM_STARTCALC</a>:
          <span class="rem">// Создание таймера обновления</span>
          data-&gt;CreateRefreshTimer(BlockData-&gt;Parent);
          <span class="kw">break</span>;

        <span class="rem">// Вызов функции настройки или двойной щелчок</span>
        <span class="rem">// левой кнопки мыши</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_SETUP.htm" title="А.2.6.13. RDS_BFM_SETUP &ndash; вызов функции настройки блока">RDS_BFM_SETUP</a>:
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_MOUSEDBLCLICK.htm" title="А.2.6.8. RDS_BFM_MOUSEDBLCLICK &ndash; двойной щелчок мыши">RDS_BFM_MOUSEDBLCLICK</a>:
          <span class="rem">// Показать панель</span>
          <a class="hidden" href="rdsSetObjectInt.htm" title="А.5.22.11. rdsSetObjectInt &ndash; установить целое число">rdsSetObjectInt</a>(data-&gt;Panel,<a class="hidden" href="RDS_PAN_VISIBLE.htm" title="А.5.31.14. Команда RDS_PAN_VISIBLE &ndash; видимость панели">RDS_PAN_VISIBLE</a>,<span class="const">0</span>,<span class="const">1</span>);
          <span class="kw">break</span>;

        <span class="rem">// Сохранение параметров блока</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_SAVETXT.htm" title="А.2.5.7. RDS_BFM_SAVETXT &ndash; запись данных блока в текстовом формате">RDS_BFM_SAVETXT</a>:
          data-&gt;SaveText();
          <span class="kw">break</span>;

        <span class="rem">// Загрузка параметров блока</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_LOADTXT.htm" title="А.2.5.5. RDS_BFM_LOADTXT &ndash; загрузка данных блока в текстовом формате">RDS_BFM_LOADTXT</a>:
          data-&gt;LoadText((<span class="kw">char</span>*)ExtParam);
          <span class="kw">break</span>;

        <span class="rem">// Действия с панелью</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_BLOCKPANEL.htm" title="А.2.6.1. RDS_BFM_BLOCKPANEL &ndash; уведомление от панели блока в подсистеме">RDS_BFM_BLOCKPANEL</a>:
          <span class="rem">// Приведение указателя на структуру, переданного в</span>
          <span class="rem">// ExtParam, к нужному типу</span>
          param=(<a class="hidden" href="RDS_BFM_BLOCKPANEL.htm#ref2" title="Указатель на RDS_PANOPERATION">RDS_PPANOPERATION</a>)ExtParam;
          <span class="rem">// Разные действия в зависимости от операции с панелью</span>
          <span class="kw">switch</span>(param-&gt;Operation)
            { <span class="rem">// Создание оконного объекта для панели</span>
              <span class="kw">case</span> <a class="hidden" href="RDS_BFM_BLOCKPANEL.htm#light_ref3" title="RDS_PANOP_CREATE">RDS_PANOP_CREATE</a>:
              <span class="changes">  <span class="rem">// Настройка вывода изображения на панель      </span></span>
              <span class="changes">  data-&gt;<a class="hidden" href="#ref69" title="Настройка вывода изображения на панель">InitWindow</a>(param-&gt;Panel-&gt;Handle);        </span>
                <span class="kw">break</span>;
              <span class="rem">// Уничтожение оконного объекта панели</span>
              <span class="kw">case</span> <a class="hidden" href="RDS_BFM_BLOCKPANEL.htm#light_ref4" title="RDS_PANOP_DESTROY">RDS_PANOP_DESTROY</a>:
              <span class="changes">  <span class="rem">// Отключение OpenGL                           </span></span>
              <span class="changes">  data-&gt;<a class="hidden" href="#ref77" title="Функция отключения OpenGL">Clear</a>();                                 </span>
                <span class="kw">break</span>;
              <span class="rem">// Размер панели изменен</span>
              <span class="kw">case</span> <a class="hidden" href="RDS_BFM_BLOCKPANEL.htm#light_ref5" title="RDS_PANOP_RESIZED">RDS_PANOP_RESIZED</a>:
              <span class="changes">  <span class="rem">// При изменении размера – просто перерисовка  </span></span>
              <span class="changes">  data-&gt;<a class="hidden" href="#ref81" title="Функция рисования трехмерной сцены">RenderScene</a>(Dir,List,Pitch);             </span>
                <span class="kw">break</span>;
              <span class="rem">// Необходимо перерисовать изображение</span>
              <span class="kw">case</span> <a class="hidden" href="RDS_BFM_BLOCKPANEL.htm#light_ref7" title="RDS_PANOP_PAINT">RDS_PANOP_PAINT</a>:
              <span class="changes">  data-&gt;<a class="hidden" href="#ref81" title="Функция рисования трехмерной сцены">RenderScene</a>(Dir,List,Pitch);             </span>
                <span class="kw">break</span>;
            }
          <span class="kw">break</span>;

       <span class="rem">// Необходимо обновить окна блока (вызывается таймером)</span>
       <span class="kw">case</span> <a class="hidden" href="RDS_BFM_WINREFRESH.htm" title="А.2.6.21. RDS_BFM_WINREFRESH &ndash; обновление окон блока">RDS_BFM_WINREFRESH</a>:
        <span class="changes">  <span class="rem">// Перерисовка изображения          </span></span>
        <span class="changes">  data-&gt;<a class="hidden" href="#ref81" title="Функция рисования трехмерной сцены">RenderScene</a>(Dir,List,Pitch);  </span>
          <span class="kw">break</span>;
      }
    <span class="kw">return</span> <a class="hidden" href="app_a_2_1.htm#ref2" title="Возврат RDS_BFR_DONE">RDS_BFR_DONE</a>;

<div class="changes">  <span class="rem">// Отмена макроопределений</span>
  <span class="preproc">#undef Pitch</span>
  <span class="preproc">#undef List</span>
  <span class="preproc">#undef Dir</span>
  <span class="preproc">#undef Ready</span>
  <span class="preproc">#undef Start</span>
  <span class="preproc">#undef pStart</span></div>
  }
  <span class="rem">//=================================================</span></pre>

<p>Теперь, когда у блока появились статические переменные, в его модель добавлена обычная реакция на
вызов в режиме <span class="cpp"><a href="RDS_BFM_VARCHECK.htm" title="А.2.4.18. RDS_BFM_VARCHECK &ndash; проверка допустимости структуры статических переменных блока">RDS_BFM_VARCHECK</a></span> для проверки допустимости их типа. Изменения также
произошли в реакциях на вызовы <span class="cpp"><a href="RDS_BFM_BLOCKPANEL.htm" title="А.2.6.1. RDS_BFM_BLOCKPANEL &ndash; уведомление от панели блока в подсистеме">RDS_BFM_BLOCKPANEL</a></span> и <span class="cpp"><a href="RDS_BFM_WINREFRESH.htm" title="А.2.6.21. RDS_BFM_WINREFRESH &ndash; обновление окон блока">RDS_BFM_WINREFRESH</a></span>.</p>

<p>В режиме <span class="cpp"><a class="hidden" href="RDS_BFM_BLOCKPANEL.htm" title="А.2.6.1. RDS_BFM_BLOCKPANEL &ndash; уведомление от панели блока в подсистеме">RDS_BFM_BLOCKPANEL</a></span> (при получении от RDS сообщения об
операции с панелью) модель теперь выполняет следующие действия:</p>

<ul>
  <li>при создании окна внутри панели (<span class="cpp"><a href="RDS_BFM_BLOCKPANEL.htm#light_ref3" title="RDS_PANOP_CREATE">RDS_PANOP_CREATE</a></span>) вызывается функция
  <span class="cpp"><a href="#ref69" title="Настройка вывода изображения на панель">InitWindow</a></span>, настраивающая формат изображения в окне и
  создающая для окна контекст OpenGL;</li>

  <li>перед уничтожением окна (<span class="cpp"><a href="RDS_BFM_BLOCKPANEL.htm#light_ref4" title="RDS_PANOP_DESTROY">RDS_PANOP_DESTROY</a></span>) вызывается функция
  <span class="cpp"><a href="#ref77" title="Функция отключения OpenGL">Clear</a></span>, уничтожающая ранее созданный контекст OpenGL;</li>

  <li>при изменении размеров панели (<span class="cpp"><a href="RDS_BFM_BLOCKPANEL.htm#light_ref5" title="RDS_PANOP_RESIZED">RDS_PANOP_RESIZED</a></span>) и получении сообщения о необходимости
  перерисовки (<span class="cpp"><a href="RDS_BFM_BLOCKPANEL.htm#light_ref7" title="RDS_PANOP_PAINT">RDS_PANOP_PAINT</a></span>) вызывается функция рисования изображения
  <span class="cpp"><a href="#ref81" title="Функция рисования трехмерной сцены">RenderScene</a></span>, в параметрах которой передаются входы блока.</li>
</ul>

<p>В режиме <span class="cpp"><a href="RDS_BFM_WINREFRESH.htm" title="А.2.6.21. RDS_BFM_WINREFRESH &ndash; обновление окон блока">RDS_BFM_WINREFRESH</a></span> (при срабатывании таймера в режиме расчета)
снова вызывается функция <span class="cpp"><a class="hidden" href="#ref81" title="Функция рисования трехмерной сцены">RenderScene</a></span> с входами блока
в качестве параметров.</p>

<p>Таким образом, в режиме расчета получившийся блок постоянно отображает три угловые координаты,
поступающие ему на входы, поворачивая треугольную пирамиду и окружность относительно неподвижной
&laquo;камеры&raquo; (<a href="#pic6" title="Работающий блок-индикатор">рис.&nbsp;70</a>).</p>

<div class="pic"><div class="container" id="pic6">
<img src="../img/OpenGL_obj_1.png" width="312" height="390" alt="Работающий блок-индикатор" />
<p id="light_pic6">Рис.&nbsp;70. Работающий блок-индикатор</p>
</div></div>



</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="pm_2_10_3.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="pm_2_11.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="pm_index.htm#light_htm:pm_2_10_4">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
