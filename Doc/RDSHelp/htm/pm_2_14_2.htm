<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;2.14.2. Сброс подсистемы в начальное состояние</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="pm_index.htm">Руководство программиста</a></p>
<div class="level"><p><a href="pm_index.htm#light_htm:pm_2">Глава 2. Создание моделей блоков</a></p>
<div class="level"><p><a href="pm_index.htm#light_htm:pm_2_14">&sect;2.14. Программное управление расчетом</a></p>
<div class="level"><p>&sect;2.14.2. Сброс подсистемы в начальное состояние</p>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="pm_2_14_1.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="pm_2_14_3.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="pm_index.htm#light_htm:pm_2_14_2">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
<div class="right">
<span class="curtab">Текст</span>
<span class="tab"><a href="pm_2_14_2_c.htm">С++</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Руководство программиста</h1>
<h2 class="off">Глава 2. Создание моделей блоков</h2>
<h3 class="off">&sect;2.14. Программное управление расчетом</h3>
<h4>&sect;2.14.2. Сброс подсистемы в начальное состояние</h4>
<p class="abstract">Описывается программный сброс расчета, то есть способ возврата какой-либо подсистемы или всей
                схемы в начальное состояние. Рассматриваются два примера, использующих программный сброс расчета: поиск
                угла возвышения метательной машины, при котором снаряд летит на заданную дальность, и построение
                графика зависимости дальности полета снаряда от угла возвышения этой машины.</p>


<p><a href="um_1_3.htm#ref9" title="Сброс расчета">Сброс расчета</a> &ndash; совершенно необходимая операция при работе с
некоторыми видами схем. Например, если схема моделирует какой-либо протяженный во времени процесс, перед
его расчетом с новыми параметрами следует сбросить все блоки в начальное состояние. Часто возникают задачи,
в которых необходимо многократно повторять расчет для получения нужного результата. К таким задачам относятся,
например, задачи оптимизации, в которых требуется подобрать такие параметры схемы, при которых она ведет
себя наилучшим образом. Что такое &laquo;вести себя наилучшим образом&raquo; обычно формально задается при
помощи вычисления некоторого критерия, позволяющего оценить качество поведения системы. Многократно повторяя расчет
с разными значениями параметров, находят такой их набор, при котором значение этого критерия будет
минимальным (или максимальным &ndash; все зависит от того, как задать критерий). Другой пример задачи,
требующей многократного моделирования &ndash; построение графика зависимости установившегося значения на
выходе схемы от одного из ее параметров. Поскольку значение на выходе схемы устанавливается не сразу,
для каждого значения параметра нужно запускать расчет на некоторое время, затем фиксировать очередную
точку графика, сбрасывать расчет, менять параметр, снова запускать расчет на некоторое время и т.д.
Естественно, проводить все эти сбросы и перезапуски вручную было бы слишком трудоемко, такие процессы необходимо
автоматизировать.</p>

<p>RDS позволяет программно вернуть всю схему или отдельную ее
<a href="pm_1_2.htm#light_ref4" title="Подсистема">подсистему</a>
в начальное состояние вызовом
сервисной функции <span class="cpp"><span id="light_ref1"><a href="rdsResetSystemState.htm" title="А.5.7.3. rdsResetSystemState &ndash; сбросить состояние блока или подсистемы">rdsResetSystemState</a></span></span>. При этом все
<a href="pm_1_5.htm" title="&sect;1.5. Статические переменные блоков, входы и выходы">статические переменные</a> блоков
вернутся к своим <a href="um_1_4.htm#ref22" title="Значение переменной по умолчанию">значениям по умолчанию</a>
и модели всех блоков подсистемы вызовутся в режиме <span class="cpp"><span id="light_ref2"><a href="RDS_BFM_RESETCALC.htm" title="А.2.4.12. RDS_BFM_RESETCALC &ndash; сброс расчета">RDS_BFM_RESETCALC</a></span></span>.
<a href="pm_2_6_1.htm" title="&sect;2.6.1. Использование динамических переменных">Динамические переменные</a> сброшены не будут &ndash;
если сбрасывать их необходимо, это должна сделать она из моделей блоков. Как и
<a href="pm_2_14_1.htm" title="&sect;2.14.1. Запуск и остановка расчета">функции запуска и остановки</a>
расчета, функция сброса обычно срабатывает не мгновенно &ndash; при работающем расчете она будет ждать
завершения очередного такта.</p>

<p>Для иллюстрации применения этой функции сделаем модель метательной машины, которая выпускает
цилиндрический снаряд известной массы и диаметра под углом к горизонту с некоторой начальной скоростью.
Необходимо найти такой угол возвышения (то есть угол между горизонтальной плоскостью и осью канала ствола
или направляющей нашей метательной машины), при котором снаряд упадет на землю как можно ближе к точке,
находящейся на заданном расстоянии от машины. Поскольку уравнения, описывающие полет снаряда с учетом
сопротивления воздуха, не решаются аналитически, нам необходимо будет сделать блок, который, многократно запуская
расчет, подберет такой угол возвышения, при котором дальность полета снаряда будет как можно ближе к заданной.</p>

<p>Для решения этой задачи нам потребуется создать два блока: модель полета снаряда (расчет внешней
баллистики) и блок, который будет подбирать угол возвышения для заданной дальности полета снаряда.
Сначала займемся блоком, который будет моделировать полет снаряда, выпущенного метательной машиной.
В этом примере мы не будем глубоко вдаваться в тонкости баллистики: будем считать, что угол возвышения и
угол бросания совпадают, и опустим некоторые другие детали, не особенно существенные для данного примера.
Чтобы рассчитать траекторию полета снаряда, нам необходимо получить дифференциальные уравнения, описывающие
ее, и численно проинтегрировать их.</p>

<p>Пусть наша метательная машина имеет ствол, который может поворачиваться относительно горизонтальной оси,
расположенной на высоте <i>h</i><sub>0</sub> от поверхности земли
(<a href="#pic1" title="Метательная машина в системе координат">рис.&nbsp;94</a>).</p>

<div class="pic"><div class="container" id="pic1">
<img src="../img/Ballistics_Coords.png" width="547" height="236" alt="Метательная машина в системе координат" />
<p id="light_pic1">Рис.&nbsp;94. Метательная машина в системе координат</p>
</div></div>


<p>Расстояние от оси вращения ствола до его конца (точки вылета снаряда) назовем
<i>l</i><sub>0</sub>. Полет снаряда мы будем рассматривать в двумерной системе координат
&laquo;высота-дальность&raquo;, как на рисунке: ось <i>x</i> будет лежать на поверхности земли, а ось
<i>y</i> будет направлена вертикально вверх, проходя через точку поворота ствола. Будем считать, что при
любом угле возвышения &alpha; наша метательная машина обеспечивает снаряду при вылете из ствола заданную
начальную скорость <i>v</i><sub>0</sub>, которая не зависит от угла возвышения. Таким образом, в точке
вылета (<i>x</i><sub>0</sub>,<i>y</i><sub>0</sub>) снаряд будет иметь скорость
<i>v</i><sub>0</sub>, вектор которой направлен под углом &alpha; к горизонту. Координаты точки вылета можно
вычислить следующим образом:</p>

<p class="center"><img class="formula" src="../img/Form_ball_1.png" width="194" height="81" alt="x0=l0*cos(alpha); y0=h0+l0*sin(alpha)" /></p>

<p>С момента вылета из ствола на снаряд будут действовать всего две силы: сила тяжести <i>mg</i>,
направленная вертикально вниз (<i>m</i> &ndash; масса снаряда), и сила сопротивления воздуха <i>F</i>,
направленная против вектора мгновенной скорости снаряда <i>v</i>
(<a href="#pic2" title="Силы, действующие на снаряд в полете">рис.&nbsp;95</a>).</p>

<div class="pic"><div class="container" id="pic2">
<img src="../img/Ballistics_Forces.png" width="472" height="262" alt="Силы, действующие на снаряд в полете" />
<p id="light_pic2">Рис.&nbsp;95. Силы, действующие на снаряд в полете</p>
</div></div>


<p><span id="ref3">Величина</span>
силы сопротивления воздуха <i>F</i> зависит от модуля вектора скорости снаряда. Для
ее вычисления мы будем пользоваться <span id="light_ref3">формулой, полученной Н. А. Забудским</span>:</p>

<p class="center"><img class="formula" src="../img/Form_ball_2.png" width="257" height="66" alt="F=A(v)*pi*R^2*(Delta/Delta0)*v^(n(v))" />,</p>

<p class="noindent">где</p>
<ul>
  <li><i>R</i>&nbsp;&ndash;&nbsp;радиус поперечного сечения снаряда (м),</li>
  <li>&Delta;&nbsp;&ndash;&nbsp;плотность воздуха в момент выстрела,</li>
  <li>&Delta;<sub>0</sub>&nbsp;&ndash;&nbsp;плотность воздуха при температуре 15&deg;С и давлении 760 мм.рт.ст.,</li>
  <li><i>v</i>&nbsp;&ndash;&nbsp;скорость снаряда (м/с),</li>
  <li><i>A</i>, <i>n</i>&nbsp;&ndash;&nbsp;параметры, зависящие от скорости снаряда следующим образом:</li>
</ul>

  <div class="tablecenter"><div class="tcont">
  <table>
    <tr>
      <th>Диапазон v, м/с</th>
      <th>A</th>
      <th>n</th>
    </tr>
    <tr>
      <td class="center">0&hellip;240</td>
      <td class="right">0.014</td>
      <td class="right">2</td>
    </tr>
    <tr>
      <td class="center">240&hellip;295</td>
      <td class="right">0.0000583</td>
      <td class="right">3</td>
    </tr>
    <tr>
      <td class="center">295&hellip;375</td>
      <td class="right">0.00000000067</td>
      <td class="right">5</td>
    </tr>
    <tr>
      <td class="center">375&hellip;419</td>
      <td class="right">0.000094</td>
      <td class="right">3</td>
    </tr>
    <tr>
      <td class="center">419&hellip;550</td>
      <td class="right">0.0394</td>
      <td class="right">2</td>
    </tr>
    <tr>
      <td class="center">550&hellip;800</td>
      <td class="right">0.2616</td>
      <td class="right">1.7</td>
    </tr>
    <tr>
      <td class="center">800&hellip;1000</td>
      <td class="right">0.713</td>
      <td class="right">1.55</td>
    </tr>
  </table>
  </div></div>

<p>Для простоты мы не будем учитывать разницу плотностей воздуха &ndash; будем считать, что мы стреляем
именно при температуре 15&deg;С и давлении 760 мм. Заменив в формуле радиус поперечного сечения снаряда <i>R</i>
на его диаметр <i>D</i> (мы договорились задавать именно диаметр), получим:</p>

<p class="center"><img class="formula" src="../img/Form_ball_3.png" width="275" height="37" alt="F=0.25*pi*A(v)*D^2*v^(n(v))" /></p>

<p>Разложим силу сопротивления воздуха <i>F</i> на горизонтальную и вертикальную составляющие
<i>F</i><sub>x</sub> и <i>F</i><sub>y</sub>. Считая, что вектор мгновенной скорости снаряда
<i>v</i> в данный момент направлен под углом &phi; к горизонту, то есть имеет горизонтальную составляющую
<i>v</i><sub>x</sub>=<i>v</i> cos &phi; и вертикальную
<i>v</i><sub>y</sub>=<i>v</i> sin &phi;, получим:</p>

<p class="center"><img class="formula" src="../img/Form_ball_4.png" width="247" height="165" alt="Fx=F*cos(phi)=F*vx/v; Fy=F*sin(phi)=F*vy/v" /></p>

<p>Обозначив через <i>a</i><sub>x</sub> и <i>a</i><sub>y</sub> горизонтальную и вертикальную составляющие
ускорения снаряда соответственно, из второго закона Ньютона получим:</p>

<p class="center"><img class="formula" src="../img/Form_ball_5.png" width="207" height="83" alt="m*ax=-Fx; m*ay=-mg-Fy" /></p>

<p>Поскольку ускорение &ndash; это первая производная скорости по времени, получаем
следующие дифференциальные уравнения:</p>

<p class="center"><img class="formula" src="../img/Form_ball_6.png" width="229" height="166" alt="m*dvx/dt=-Fx; m*dvy/dt=-mg-Fy" /></p>

<p>Нулевым моментом времени (<i>t</i>=0) будем считать момент вылета снаряда из ствола. В этом
случае начальными условиями для приведенных выше уравнений будут горизонтальная и вертикальная составляющие
вектора начальной скорости <i>v</i><sub>0</sub> (см. <a href="#pic1" title="Метательная машина в системе координат">рис.&nbsp;94</a>):</p>

<p class="center"><img class="formula" src="../img/Form_ball_7.png" width="190" height="83" alt="vx(0)=v0*cos(alpha); vy(0)=v0*sin(alpha)" /></p>

<p>Нам нужно рассчитать траекторию полета снаряда, то есть функции
<i>x</i>(<i>t</i>) и <i>y</i>(<i>t</i>). Поскольку скорость &ndash; первая производная координаты по времени,
получаем следующие дифференциальные уравнения (начальными условиями для них будут
координаты точки вылета):</p>

<p class="center"><img class="formula" src="../img/Form_ball_8.png" width="393" height="162" alt="dx/dt=vx, x(0)=x0=l0*cos(alpha); dy/dt=vy, y(0)=y0=h0+l0*sin(alpha)" /></p>

<p>Теперь, объединив все приведенные выше уравнения и добавив к ним вычисление модуля вектора скорости по
его компонентам <i>v</i><sub>x</sub> и <i>v</i><sub>y</sub>, получим систему дифференциальных и
алгебраических уравнений, описывающих полет нашего снаряда:</p>

<p class="center"><img class="formula" src="../img/Form_ball_9.png" width="530" height="601" alt="Все предыдущие уравнения в одной системе" /></p>

<div class="picright"><div class="container" id="pic3">
<img src="../img/Ballistics_Euler.png" width="383" height="346" alt="Переход к дискретному времени" />
<p id="light_pic3">Рис.&nbsp;96. Переход к дискретному времени</p>
</div></div>


<p><span id="ref4">Из-за</span>
нелинейной зависимости силы сопротивления воздуха от скорости полета снаряда эта система
не имеет аналитического решения. Мы будем решать ее численно, используя простейший метод численного
интегрирования &ndash; <span id="light_ref4">метод Эйлера</span>. От непрерывного времени
<i>t</i> мы перейдем к дискретным отсчетам <i>t</i><sub>k</sub>, интервал между которыми постоянен и равен
&Delta;<i>t</i>
(<a href="#pic3" title="Переход к дискретному времени">рис.&nbsp;96</a>).
Для некоторой непрерывной функции <i>z</i>(<i>t</i>) моменту времени <i>t</i><sub>k</sub> будет
соответствовать значение <i>z</i><sub>k</sub>=<i>z</i>(<i>t</i><sub>k</sub>). Если функция
<i>z</i>(<i>t</i>) задана дифференциальным уравнением вида</p>

<p class="center"><img class="formula" src="../img/Form_ball_10.png" width="116" height="62" alt="dz/dt=f(t)" />,</p>

<p class="noindent">то при достаточно малом &Delta;<i>t</i> можно приближенно заменить
<i>dz</i>/<i>dt</i> на &Delta;<i>z</i>/&Delta;<i>t</i>, то есть заменить дифференциалы конечными разностями,
и получить следующее соотношение для момента времени <i>t</i><sub>k</sub>:</p>

<p class="center"><img class="formula" src="../img/Form_ball_11.png" width="298" height="82" alt="dz/dt|(t=t[k]) = delta_z/delta_t = (z[k+1]-z[k])/delta_t" />.</p>

<p class="noindent">Поскольку</p>

<p class="center"><img class="formula" src="../img/Form_ball_12.png" width="184" height="83" alt="dz/dt|(t=t[k]) = f(t[k])" />,</p>

<p class="noindent">рекуррентное выражение, позволяющее вычислить значение <i>z</i><sub>k+1</sub> по
известному <i>z</i><sub>k</sub> и правой части дифференциального уравнения
<i>f</i>(<i>t</i>), будет выглядеть следующим образом:</p>

<p class="center"><img class="formula" src="../img/Form_ball_13.png" width="231" height="32" alt="z[k+1]=z[k]+delta_t*f(t[k])" />.</p>

<p class="noindent">Фактически, мы считаем, что на интервале времени &Delta;<i>t</i> производная функции
<i>z</i>(<i>t</i>), то есть скорость изменения этой функции, не меняется и равна
<i>f</i>(<i>t</i><sub>k</sub>). Чем меньше будет интервал времени &Delta;<i>t</i>, тем точнее набор отсчетов
{<i>z</i><sub>0</sub>, <i>z</i><sub>1</sub>, &hellip;, <i>z</i><sub>k</sub>, &hellip;} будет совпадать с
функцией <i>z</i>(<i>t</i>).</p>

<p><span id="ref5">Применив</span>
те же рассуждения к дифференциальным уравнениям, описывающим полет снаряда, получим следующую систему
<span id="light_ref5">разностных уравнений</span>:</p>

<p class="center"><img class="formula" src="../img/Form_ball_14.png" width="683" height="365" alt="v(tk)=sqrt((vx(tk)^2+vy(tk)^2); F(tk)=0.25*pi*A(v(tk))*D^2*v(tk)^(n(v(tk))); Fx(tk)=F(tk)*vx(tk)/v(tk); Fy(tk)=F(tk)*vy(tk)/v(tk); vx(t[k+1])=vx(tk)-delta_t*Fx(tk)/m; vy(t[k+1])=vy(tk)-delta_t*(g+Fx(tk))/m; x(t[k+1])=x(tk)+delta_t*vx(tk); y(t[k+1])=y(tk)+delta_t*vy(tk)" /></p>

<p>Эти уравнения позволяют по текущим значениям <i>x</i>, <i>y</i>,
<i>v</i><sub>x</sub> и <i>v</i><sub>y</sub> вычислить значения, которые примут эти переменные через
интервал времени &Delta;<i>t</i>. Такие уравнения уже можно закладывать в программу модели блока.</p>

<div class="picright"><div class="container" id="pic4">
<img src="../img/Ballistics_Impact.png" width="300" height="194" alt="Определение точки встречи снаряда с поверхностью" />
<p id="light_pic4">Рис.&nbsp;97. Определение точки встречи<br />снаряда с поверхностью</p>
</div></div>


<p>По условиям задачи нам требуется определить дальность полета снаряда при выстреле с заданным углом
возвышения &alpha;. Дальность полета <i>L</i> &ndash; это значение горизонтальной координаты снаряда в
тот момент, когда его вертикальная координата стала равна нулю (см.
<a href="#pic1" title="Метательная машина в системе координат">рис.&nbsp;94</a>). Поскольку при моделировании полета снаряда мы
численно интегрируем описывающую его движение систему дифференциальных уравнений, траекторию
(<i>x</i>(<i>t</i>), <i>y</i>(<i>t</i>)) мы получаем в виде набора отсчетов
(<i>x</i><sub>k</sub>, <i>y</i><sub>k</sub>), отстоящих друг от друга на интервал времени &Delta;<i>t</i>.
Мы считаем, что на этом временном интервале производные координат и компонентов скорости снаряда
не изменяются, то есть движение снаряда между вычисляемыми точками траектории считается прямолинейным с
постоянной скоростью. Таким образом, траектория снаряда в сделанном нами приближении представляет собой
кусочно-линейную функцию. Для того, чтобы определить дальность полета, нам нужно дождаться, когда
вертикальная координата снаряда станет отрицательной и определить точку пересечения отрезка, соединяющего
предпоследний и последний отсчеты траектории, с горизонтальной осью
(<a href="#pic4" title="Определение точки встречи снаряда с поверхностью">рис.&nbsp;97</a>). Поскольку прямая, проходящая через точки
(<i>x</i><sub>k&minus;1</sub>, <i>y</i><sub>k&minus;1</sub>) и (<i>x</i><sub>k</sub>, <i>y</i><sub>k</sub>)
описывается уравнением</p>

<p class="center"><img class="formula" src="../img/Form_ball_15.png" width="244" height="65" alt="(y-y[k-1])/(y[k]-y[k-1])=(x-x[k-1])/(x[k]-x[k-1])" />,</p>

<p class="noindent">координата <i>L</i> пересечения этой прямой с горизонтальной осью
(<i>y</i>=0) вычисляется следующим образом:</p>

<p class="center"><img class="formula" src="../img/Form_ball_16.png" width="286" height="65" alt="L=x[k-1]-y[k-1]*(x[k]-x[k-1])/(y[k]-y[k-1])" /></p>

<p>Теперь у нас есть все формулы, необходимые для расчета траектории и дальности полета снаряда. Однако,
прежде чем приступать к созданию функции модели блока, который будет производить этот расчет,
напишем одну вспомогательную функцию, которая существенно облегчит нам настройку этого и некоторых
других блоков. В нашем блоке довольно много вещественных параметров: диаметр снаряда, его масса,
начальная скорость и т.п. Для удобства пользователя следует предусмотреть в блоке функцию настройки
этих параметров, причем хранить эти параметры имеет смысл в
<a href="pm_2_7_4.htm" title="&sect;2.7.4. Хранение настроечных параметров в переменных блока">статических переменных блока</a>, чтобы у пользователя был выбор:
вводить значения параметров в окне настройки или получать их значения по связям от других блоков.
<span id="ref6">В</span>
<a href="pm_2_7_4.htm#ref1" title="Хранение параметров в значениях переменных по умолчанию">&sect;2.7.4</a>, мы создали универсальную функцию
<span id="light_ref6"><span class="cpp"><a href="pm_2_7_4.htm#light_ref10" title="Функция добавления поля в окно настройки">AddWinEditOrDisplayDouble</a></span></span>, которая добавляет в
окно настроек поле ввода для редактирования значения по умолчанию вещественной статической переменной
блока, если к ней в данный момент не подключена связь.
<span id="ref7">Сейчас</span>,
на ее основе, мы напишем <span id="light_ref7">универсальную функцию
настройки</span>, в которую передаются номера переменных блока и заголовки для соответствующих им полей ввода,
а функция самостоятельно создает эти поля, открывает окно, ждет ввода пользователя и, если он нажал в
окне кнопку &laquo;<span class="menu">OK</span>&raquo;, записывает введенные им значения обратно в переменные. Эта функция пригодится
нам не только для блока моделирования полета снаряда, но и для других блоков, все параметры которых
&ndash; вещественные числа.</p>

<p>Для того, чтобы в универсальную функцию настройки можно было передать произвольное число пар
&laquo;номер переменной &ndash; заголовок поля&raquo;, сделаем одним из ее параметров массив строк.
Каждая строка будет начинаться с символьного представления номера переменной (нужно помнить, что
нумерация переменных в RDS начинается с нуля), за которым без пробела будет следовать заголовок поля
ввода. Например, если в пятнадцатой переменной блока хранится масса снаряда в килограммах, в массив
нужно будет включить строку &laquo;15Масса снаряда, кг&raquo;. Чтобы не передавать в функцию вместе
с указателем на начало массива еще и его размер, будем считать, что он всегда завершается значением
<span class="cpp">NULL</span>. В этом случае функция, встретив в массиве <span class="cpp">NULL</span> вместо
очередной строки, будет знать, что элементы массива закончились.</p>

<p><span id="ref8">Универсальная</span>
функция настройки вещественных параметров будет выглядеть следующим образом:</p>

<pre class="cpp">  <span class="rem">// Функция настройки вещественных параметров, хранящихся в</span>
  <span class="rem">// статических переменных блока.</span>
  <span class="rem">// Возвращает: 1 – ОК, 0 – отмена.</span>
  <span class="kw">int</span> <span id="light_ref8">SetupDoubleVars</span>(
    <a class="hidden" href="app_ids.htm#light_ref1" title="Идентификатор блока">RDS_BHANDLE</a> Block, <span class="rem">// Настраиваемый блок</span>
    <span class="kw">char</span> *wintitle,    <span class="rem">// Заголовок окна настройки</span>
    <span class="kw">char</span> **vars)       <span class="rem">// Массив строк-описаний полей ввода</span>
  { <a class="hidden" href="app_ids.htm#light_ref6" title="Идентификатор вспомогательного объекта">RDS_HOBJECT</a> window; <span class="rem">// Идентификатор вспомогательного объекта</span>
    <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> ok;            <span class="rem">// Пользователь нажал "OK"</span>
    <span class="kw">int</span> count=<span class="const">0</span>;
    <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> *Connections;
    <span class="kw">int</span> *VarNums;

    <span class="kw">if</span>(vars==NULL) <span class="rem">// Ошибка – массив не передан</span>
      <span class="kw">return</span> <span class="const">0</span>;

    <span class="rem">// Подсчитываем число полей ввода в массиве vars</span>
    <span class="kw">while</span>(vars[count]!=NULL)
      count++;
    <span class="kw">if</span>(!count) <span class="rem">// Ошибка – массив пуст</span>
      <span class="kw">return</span> <span class="const">0</span>;

    <span class="rem">// Отводим вспомогательный массив логических значений, в котором</span>
    <span class="rem">// будем запоминать наличие связей, присоединенных к переменным,</span>
    <span class="rem">// а также массив целых чисел для номеров переменных, считанных</span>
    <span class="rem">// из строк массива vars</span>
    Connections=<span class="kw">new</span> <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a>[count];
    VarNums=<span class="kw">new</span> <span class="kw">int</span>[count];

    <span class="rem">// Создаем окно с заголовком wintitle</span>
    window=<span id="light_ref9"><a class="hidden" href="rdsFORMCreate.htm" title="А.5.28.1. rdsFORMCreate &ndash; создать объект для работы с окном">rdsFORMCreate</a></span>(FALSE,-<span class="const">1</span>,-<span class="const">1</span>,wintitle);

    <span class="rem">// Добавляем поля ввода из массива vars, заполняя массивы</span>
    <span class="rem">// Connections и VarNums</span>
    <span class="kw">for</span>(<span class="kw">int</span> i=<span class="const">0</span>;i&lt;count;i++)
      { <span class="kw">char</span> *str;
        <span class="rem">// Считываем из строки номер переменной. Указатель на первый</span>
        <span class="rem">// после номера символ запишется в str.</span>
        VarNums[i]=<span id="light_ref10">strtol</span>(vars[i],&amp;str,<span class="const">0</span>);
        <span class="rem">// Если после номера строка кончается, присваиваем str</span>
        <span class="rem">// значение NULL, чтобы в качестве заголовка было</span>
        <span class="rem">// использовано имя переменной</span>
        <span class="kw">if</span>(*str==<span class="const">0</span>)
          str=NULL;
        <span class="rem">// Добавляем поле ввода, запоминаем наличие связи</span>
        Connections[i]=<a class="hidden" href="pm_2_7_4.htm#light_ref10" title="Функция добавления поля в окно настройки">AddWinEditOrDisplayDouble</a>(window,Block,
                  VarNums[i],i,str);
      }

    <span class="rem">// Открываем окно</span>
    ok=<a class="hidden" href="rdsFORMShowModalEx.htm" title="А.5.28.6. rdsFORMShowModalEx &ndash; открыть окно с функцией обратного вызова">rdsFORMShowModalEx</a>(window,NULL);
    <span class="kw">if</span>(ok)
      { <span class="rem">// Нажата кнопка OK – запись параметров в переменные</span>
        <span class="kw">for</span>(<span class="kw">int</span> i=<span class="const">0</span>;i&lt;count;i++)
          <span class="kw">if</span>(!Connections[i]) <span class="rem">// У переменной нет связи</span>
            { <span class="kw">char</span> *str=<a class="hidden" href="rdsGetObjectStr.htm" title="А.5.22.9. rdsGetObjectStr &ndash; получить строку">rdsGetObjectStr</a>(window,i,<a class="hidden" href="RDS_FORMVAL_VALUE.htm" title="А.5.28.27. Команда RDS_FORMVAL_VALUE &ndash; значение поля">RDS_FORMVAL_VALUE</a>);
              <span class="rem">// Устанавливаем новое значение по умолчанию</span>
              <span id="light_ref11"><a class="hidden" href="rdsSetBlockVarDefValueStr.htm" title="А.5.14.17. rdsSetBlockVarDefValueStr &ndash; установить значение переменной по умолчанию">rdsSetBlockVarDefValueStr</a></span>(Block,VarNums[i],str);
            }
      }
    <span class="rem">// Удаляем вспомогательные массивы</span>
    <span class="kw">delete</span>[] Connections;
    <span class="kw">delete</span>[] VarNums;
    <span class="rem">// Уничтожаем окно</span>
    <span id="light_ref12"><a class="hidden" href="rdsDeleteObject.htm" title="А.5.22.4. rdsDeleteObject &ndash; удалить объект">rdsDeleteObject</a></span>(window);
    <span class="rem">// Возвращаем 1 или 0</span>
    <span class="kw">return</span> ok?<span class="const">1</span>:<span class="const">0</span>;
  }
  <span class="rem">//=========================================</span></pre>

<p>Функция принимает три параметра: <a href="app_ids.htm#light_ref1" title="Идентификатор блока">идентификатор блока</a>,
для которого вызывается функция настройки
(<span class="cpp">Block</span>), текст заголовка окна (<span class="cpp">wintitle</span>) и массив строк
описанного выше формата (<span class="cpp">vars</span>). Эта функция, прежде всего, подсчитывает число строк
в массиве <span class="cpp">vars</span>, перебирая их до тех пор, пока не встретит значение
<span class="cpp">NULL</span>. Число обнаруженных строк записывается в переменную <span class="cpp">count</span>.
Затем отводятся два вспомогательных массива из <span class="cpp">count</span> элементов: логический массив
<span class="cpp">Connections</span>, в котором будет запоминаться наличие связи у каждой из перечисленных
в массиве <span class="cpp">vars</span> переменных, и целый массив
<span class="cpp">VarNums</span>, в который будут записаны номера переменных блока, полученные при
разборе строк из <span class="cpp">vars</span>. Затем, как обычно, сервисной функцией
RDS <span class="cpp"><a href="rdsFORMCreate.htm" title="А.5.28.1. rdsFORMCreate &ndash; создать объект для работы с окном">rdsFORMCreate</a></span> создается вспомогательный объект-окно, идентификатор
которого присваивается переменной <span class="cpp">window</span>.</p>

<p>Далее в цикле перебираются строки из массива <span class="cpp">vars</span>, каждая из которых разбивается
на номер переменной и заголовок поля при помощи функции <span class="cpp">strtol</span> из стандартной библиотеки
языка C (ее прототип описан в файле &laquo;<span class="file"><span id="light_ref13">stdlib.h</span></span>&raquo;).
Эта функция преобразует строку, переданную в ее первом параметре, в целое число, и возвращает полученное
значение. В третьем параметре функции передается основание системы счисления преобразуемого числа (в
нашем случае передается 0, при этом функция сама определит систему счисления по форме записи).
Во втором параметре функции передается указатель на переменную, в которую записывается указатель на первый
символ строки, который функция не смогла распознать, то есть первый не относящийся к числу символ.
Нам именно это и нужно: в строке из массива <span class="cpp"></span> сразу за числом, указывающим номер
переменной в блоке, следует текст заголовка поля ввода, и мы получим указатель на первый следующий за
числом символ, то есть на начало заголовка. Например, если в <span class="cpp">vars[i]</span> будет записана строка
&laquo;15Масса снаряда, кг&raquo;, то после вызова</p>

<pre class="cpp">  VarNums[i]=strtol(vars[i],&str,<span class="const">0</span>);</pre>

<p class="noindent"><span class="cpp">VarNums[i]</span> получит значение 15, а
<span class="cpp">str</span> будет указывать на символ &laquo;М&raquo; в слове
&laquo;Масса&raquo;. Таким образом, при помощи одного вызова мы получаем и номер переменной,
и указатель на начало заголовка поля ввода.</p>

<p>Если <span class="cpp">str</span> указывает на нулевой символ, то есть на маркер конца строки,
значит, строка содержала только номер переменной, а заголовка поля ввода в ней не было. В этом случае переменной
<span class="cpp">str</span> принудительно присваивается значение <span class="cpp">NULL</span>, поскольку вызываемая
нами функция <span class="cpp"><a class="hidden" href="pm_2_7_4.htm#light_ref10" title="Функция добавления поля в окно настройки">AddWinEditOrDisplayDouble</a></span> написана так, чтобы при передаче ей
<span class="cpp">NULL</span> в качестве заголовка поля ввода использовалось имя переменной блока (иногда
имена переменных достаточно информативны сами по себе). В качестве номера переменной в функцию передается только
что полученное нами значение <span class="cpp">VarNums[i]</span>, в качестве номера поля ввода &ndash;
значение индекса цикла <span class="cpp">i</span>, а результат ее возврата, то есть наличие связи
у переменной, записывается в элемент массива <span class="cpp">Connections[i]</span>. Теперь можно открывать
окно функцией <span class="cpp"><a href="rdsFORMShowModalEx.htm" title="А.5.28.6. rdsFORMShowModalEx &ndash; открыть окно с функцией обратного вызова">rdsFORMShowModalEx</a></span>, которая вернет управление только тогда, когда
пользователь закроет это окно кнопками &laquo;<span class="menu">OK</span>&raquo; или &laquo;<span class="menu">Отмена</span>&raquo;.</p>

<p>Если пользователь нажал &laquo;<span class="menu">OK</span>&raquo; (переменная <span class="cpp">ok</span> в этом случае будет
иметь значение <span class="cpp">TRUE</span>), мы снова перебираем все переменные из массива
<span class="cpp">vars</span> в цикле от 0 до <span class="cpp">count-1</span> и для тех из них,
у которых нет присоединенной связи (<span class="cpp">Connections[i]</span> имеет значение
<span class="cpp">FALSE</span>), записываем строку, введенную пользователем в поле ввода <span class="cpp">i</span>,
в значение по умолчанию переменной с номером <span class="cpp">VarNums[i]</span>.</p>

<p>Перед завершением функции уничтожаются вспомогательные массивы и объект-окно, после чего функция возвращает 1,
если пользователь нажал в окне кнопку &laquo;<span class="menu">OK</span>&raquo;, и 0, если кнопку &laquo;<span class="menu">Отмена</span>&raquo;
(именно такие значения должна возвращать функция модели, при наличии и отсутствии изменений после вызова
функции настройки).</p>

<p>С использованием функции <span class="cpp"><a class="hidden" href="#ref8" title="SetupDoubleVars">SetupDoubleVars</a></span> написание моделей блоков, в которых нужно
настраивать вещественные параметры, сильно упрощается. Например, если у нас есть три переменных блока
типа <span class="cpp">double</span> с номерами 2, 3 и 8, которые используются для хранения настроечных параметров,
то часть модели, ответственная за вызов функции настройки, может выглядеть так:</p>

<pre class="cpp">  <span class="rem">// Массив строк, описывающих номера переменных и заголовки полей</span>
  <span class="rem">// ввода (объявлен как static, чтобы не занимал место в стеке)</span>
  <span class="kw">static</span> <span class="kw">char</span> *setup[]={
    <span class="str">"2Параметр 1"</span>,
    <span class="str">"3Параметр 2"</span>,
    <span class="str">"8Еще один параметр"</span>,
    NULL};

    &hellip;

    <span class="rem">// Вызов функции настройки</span>
    <span class="kw">case</span> <a class="hidden" href="RDS_BFM_SETUP.htm" title="А.2.6.13. RDS_BFM_SETUP &ndash; вызов функции настройки блока">RDS_BFM_SETUP</a>:
      <span class="kw">return</span> <a class="hidden" href="#ref8" title="SetupDoubleVars">SetupDoubleVars</a>(BlockData-&gt;Block,
        <span class="str">"Заголовок окна"</span>,setup);</pre>

<p><span id="ref14">Вернемся</span>
к блоку, моделирующему полет снаряда, и определимся с необходимыми для его работы переменными.
Будем считать, что выстрел производится при запуске расчета. При выстреле блок должен будет <span id="light_ref14">установить
начальные значения переменных</span> <i>v</i><sub>x</sub> и <i>v</i><sub>y</sub>, вычислив их по значениям модуля
начальной скорости <i>v</i><sub>0</sub> и угла возвышения &alpha;, которые мы сделаем входами блока.
Здесь мы встретимся с проблемой, на которой нужно остановиться подробно.</p>

<p>Согласно логике расчета, значения <i>v</i><sub>0</sub> и &alpha; нужны блоку только в момент
выстрела, поскольку они используются для определения начальных значений компонентов вектора скорости.
Дальше все вычисления ведутся уже с переменными <i>v</i><sub>x</sub> и <i>v</i><sub>y</sub> согласно
<a href="#ref5" title="Разностные уравнения полета снаряда">разностным уравнениям</a>. Если значения на входы блока поступают
по связям с других блоков, может случиться так, что блок считает <i>v</i><sub>0</sub> и &alpha; до того,
как установятся их правильные значения. Например, если значение на вход блока будет подаваться по цепочке из
трех последовательно соединенных блоков, значение этого входа установится только к третьему
<a href="um_1_3.htm#ref4" title="Такт расчета">такту расчета</a>.
Мы не можем заранее знать, сколько тактов потребуется для того, чтобы правильные значения добрались
до входа блока, но мы можем оценить это число сверху. Если в во всей схеме содержится <i>N</i>
<a href="pm_1_2.htm#light_ref3" title="Простой блок">простых</a> блоков (именно простых, поскольку в расчете участвуют только
простые блоки), длина любой цепочки из соединенных блоков в этой схеме не может быть больше <i>N</i>,
а, значит, пропустив <i>N</i> тактов, мы гарантируем установку всех начальных значений на входах всех
блоков схемы. Таким образом, мы могли бы отсчитать <i>N</i> тактов после запуска расчета, и только потом
устанавливать начальные значения переменных <i>v</i><sub>x</sub> и <i>v</i><sub>y</sub>.</p>

<p><span id="ref15">К</span>
счастью, возможность
<span id="light_ref16">пропуска заданного числа тактов</span>
уже реализована в <span id="light_ref15">стандартном блоке-<a href="pm_2_6_1.htm#ref10" title="Блок управления динамическим расчетом (планировщик)">планировщике</a>
динамического расчета</span>. Число пропускаемых тактов задается в настройках этого блока
(<a href="#pic5" title="Настройки планировщика для расчета траектории снаряда">рис.&nbsp;98</a>),
причем вместо того, чтобы вводить число тактов вручную, можно установить флаг
&laquo;<span class="menu">авто</span>&raquo; &ndash; в этом случае число начальных тактов будет равно числу блоков в подсистеме
с учетом подсистем, вложенных в нее.</p>

<div class="pic"><div class="container" id="pic5">
<img src="../img/Ballistics0_RTP.png" width="638" height="334" alt="Настройки планировщика для расчета траектории снаряда" />
<p id="light_pic5">Рис.&nbsp;98. Настройки планировщика для расчета траектории снаряда</p>
</div></div>


<p><span id="ref17">Блок-планировщик</span>
изменит значение динамической переменной времени
&laquo;<span class="rdsvar"><span id="light_ref17">DynTime</span></span>&raquo; только после пропуска заданного
числа начальных тактов, поэтому модель нашего блока должна дождаться изменения
&laquo;<span class="rdsvar">DynTime</span>&raquo; и только после этого считать значения <i>v</i><sub>0</sub> и &alpha; и
начать расчет разностных уравнений. Для управления моментом считывания введем в блок
внутреннюю логическую переменную &laquo;<span class="rdsvar">ValSet</span>&raquo; с начальным значением 0. Пока это значение
будет оставаться нулевым, модель не будет вести расчет. Как только
&laquo;<span class="rdsvar">DynTime</span>&raquo; изменится при нулевом значении &laquo;<span class="rdsvar">ValSet</span>&raquo;, модель считает
<i>v</i><sub>0</sub> и &alpha; и присвоит &laquo;<span class="rdsvar">ValSet</span>&raquo; значение 1, разрешив тем самым расчет
траектории.</p>

<p>После встречи снаряда с землей блок должен прекратить вычисление его координат и скоростей: в
любой момент времени после падения горизонтальная координата снаряда <i>x</i> должна быть равна дальности
полета <i>L</i> (см. <a href="#pic1" title="Метательная машина в системе координат">рис.&nbsp;94</a>), а вертикальная координата
<i>y</i> и обе компоненты вектора скорости <i>v</i><sub>x</sub> и <i>v</i><sub>y</sub> должны быть равны нулю.
Кроме того, после падения снаряда на землю блок должен выдать на выход сигнал, сообщающий другим блокам о
том, что дальность полета вычислена. Назовем этот сигнальный выход
&laquo;<span class="rdsvar">Impact</span>&raquo;, позже мы подключим к нему блок, который будет подбирать угол вылета для достижения
заданной дальности. Для прекращения моделирования полета после падения снаряда будем использовать внутреннюю
логическую переменную &laquo;<span class="rdsvar">InFlight</span>&raquo; с нулевым начальным значением: блок будет считать траекторию
снаряда только тогда, когда ее значение равно единице. В момент начала расчета траектории модель присвоит
ей значение 1, а затем, как только снаряд встретится с землей, модель обнулит ее, и расчет траектории
прекратится.</p>

<p>Таким образом, наша модель может находиться в одном из следующих трех состояний:</p>

  <div class="tablecenter"><div class="tcont">
  <table>
    <tr>
      <th>ValSet</th>
      <th>InFlight</th>
      <th>Состояние модели</th>
    </tr>
    <tr>
      <td class="center">0</td>
      <td class="center">0</td>
      <td>Расчет сброшен, модель ждет, пока планировщик не отсчитает заданное число
      начальных тактов и не изменит значение времени</td>
    </tr>
    <tr>
      <td class="center">1</td>
      <td class="center">1</td>
      <td>Снаряд в полете, идет расчет траектории</td>
    </tr>
    <tr>
      <td class="center">1</td>
      <td class="center">0</td>
      <td>Снаряд встретился с землей (при переходе в это состояние выдается сигнал
      &laquo;<span class="rdsvar">Impact</span>&raquo;)</td>
    </tr>
  </table>
  </div></div>

<p>Нужно отметить, что, хотя сигнал &laquo;<span class="rdsvar">Impact</span>&raquo; и будет получать единичное значение синхронно с
обнулением переменной &laquo;<span class="rdsvar">InFlight</span>&raquo;, для описания состояния машины он не подходит,
поскольку при передаче по связям сигнальные выходы автоматически сбрасываются.</p>

<p>Кроме трех перечисленных переменных, управляющих логикой работы блока, и вещественных переменных для
хранения координат, компонентов скорости и параметров снаряда, нам потребуется еще одна дополнительная
внутренняя вещественная переменная. Для вычисления интервала времени &Delta;<i>t</i> в
<a href="#ref5" title="Разностные уравнения полета снаряда">разностных уравнениях</a>, нам нужно запоминать значение времени
предыдущего шага расчета. Течением времени в нашей схеме будет управлять стандартный блок &ndash;
планировщик динамического расчета, поэтому значение текущего времени наш блок будет брать из
динамической переменной &laquo;<span class="rdsvar">DynTime</span>&raquo;, как мы уже неоднократно делали ранее. Если мы
введем в блок статическую переменную &laquo;<span class="rdsvar">t0</span>&raquo; и будем каждый раз запоминать в ней
текущее значение времени, то при изменении &laquo;<span class="rdsvar">DynTime</span>&raquo; мы сможем вычислить величину
изменения времени, то есть значение &Delta;<i>t</i>, как <span class="cpp">DynTime-t0</span>. Мы уже
использовали такой механизм когда создавали модель блока, движущегося внутри окна подсистемы с заданной скоростью
(см. <a href="pm_2_6_4.htm#ref4" title="Запоминание предыдущего значения времени">&sect;2.6.4</a>).</p>

<p>Структура переменных блока моделирования полета снаряда будет следующей:</p>

<div class="tablecenter"><div class="tcont">
<table>

  <tr>
    <th>Смещение</th>
    <th>Имя</th>
    <th>Тип</th>
    <th>Размер</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
    <th>Назначение</th>
    <th>Номер</th>
  </tr><tr><td class="center">0</td>
<td class="vcenter">Start</td>
<td class="center">Сигнал</td>
<td class="center">1</td>
<td class="center">Вход</td>
<td class="center">&checkmark;</td>
<td class="center">0</td>
<td>Стандартный сигнал запуска</td><td class="center">0</td>
</tr>
<tr><td class="center">1</td>
<td class="vcenter">Ready</td>
<td class="center">Сигнал</td>
<td class="center">1</td>
<td class="center">Выход</td>
<td></td>
<td class="center">0</td>
<td>Стандартный сигнал готовности</td><td class="center">1</td>
</tr>
<tr><td class="center">2</td>
<td class="vcenter">D</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Вход</td>
<td></td>
<td class="center">0.1</td>
<td>Диаметр снаряда, м</td><td class="center">2</td>
</tr>
<tr><td class="center">10</td>
<td class="vcenter">m</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Вход</td>
<td></td>
<td class="center">1</td>
<td>Масса снаряда, кг</td><td class="center">3</td>
</tr>
<tr><td class="center">18</td>
<td class="vcenter">v0</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Вход</td>
<td></td>
<td class="center">0</td>
<td>Начальная скорость снаряда, м/с</td><td class="center">4</td>
</tr>
<tr><td class="center">26</td>
<td class="vcenter">Angle</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Вход</td>
<td></td>
<td class="center">0</td>
<td>Угол возвышения, градусов</td><td class="center">5</td>
</tr>
<tr><td class="center">34</td>
<td class="vcenter">l0</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Вход</td>
<td></td>
<td class="center">0</td>
<td>Длина ствола (направляющей), м</td><td class="center">6</td>
</tr>
<tr><td class="center">42</td>
<td class="vcenter">h0</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Вход</td>
<td></td>
<td class="center">0</td>
<td>Высота оси ствола (направляющей), м</td><td class="center">7</td>
</tr>
<tr><td class="center">50</td>
<td class="vcenter">ValSet</td>
<td class="center">Логический</td>
<td class="center">1</td>
<td class="center">Внутренняя</td>
<td></td>
<td class="center">0</td>
<td>Признак того, что &laquo;<span class="rdsvar">v0</span>&raquo; и &laquo;<span class="rdsvar">Angle</span>&raquo; считаны</td><td class="center">8</td>
</tr>
<tr><td class="center">51</td>
<td class="vcenter">x</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Выход</td>
<td></td>
<td class="center">0</td>
<td>Координата <i>x</i> снаряда, м</td><td class="center">9</td>
</tr>
<tr><td class="center">59</td>
<td class="vcenter">y</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Выход</td>
<td></td>
<td class="center">0</td>
<td>Координата <i>y</i> снаряда, м</td><td class="center">10</td>
</tr>
<tr><td class="center">67</td>
<td class="vcenter">vx</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Выход</td>
<td></td>
<td class="center">0</td>
<td>Горизонтальная скорость <i>v</i><sub>x</sub>, м/с</td><td class="center">11</td>
</tr>
<tr><td class="center">75</td>
<td class="vcenter">vy</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Выход</td>
<td></td>
<td class="center">0</td>
<td>Вертикальная скорость <i>v</i><sub>y</sub>, м/с</td><td class="center">12</td>
</tr>
<tr><td class="center">83</td>
<td class="vcenter">v</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Выход</td>
<td></td>
<td class="center">0</td>
<td>Модуль вектора скорости, м/с</td><td class="center">13</td>
</tr>
<tr><td class="center">91</td>
<td class="vcenter">Impact</td>
<td class="center">Сигнал</td>
<td class="center">1</td>
<td class="center">Выход</td>
<td></td>
<td class="center">0</td>
<td>Снаряд встретился с землей</td><td class="center">14</td>
</tr>
<tr><td class="center">92</td>
<td class="vcenter">t0</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Внутренняя</td>
<td></td>
<td class="center">0</td>
<td>Значение времени предыдущего шага, с</td><td class="center">15</td>
</tr>
<tr><td class="center">100</td>
<td class="vcenter">InFlight</td>
<td class="center">Логический</td>
<td class="center">1</td>
<td class="center">Выход</td>
<td></td>
<td class="center">0</td>
<td>Снаряд в данный момент &ndash; в полете</td><td class="center">16</td>
</tr>


</table>
</div></div>

<p>К выходам блока мы добавили переменную &laquo;<span class="rdsvar">v</span>&raquo; &ndash; модуль вектора скорости. Для
решения поставленной задачи этот выход нам не нужен, но он даст возможность, при желании, построить график
зависимости скорости снаряда от времени.</p>

<p>Теперь можно написать модель блока:</p>

<pre class="cpp">  <span class="rem">// Расчет внешней баллистики</span>
  <span class="kw">extern</span> <span class="str">"C"</span> <span class="kw">__declspec</span>(<span class="kw">dllexport</span>)
      <span class="kw">int</span> <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> Ballistics(<span class="kw">int</span> CallMode,
                             <a class="hidden" href="RDS_BLOCKDATA.htm#ref2" title="Указатель на RDS_BLOCKDATA">RDS_PBLOCKDATA</a> BlockData,
                             <a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> ExtParam)
  { <span id="light_ref18"><a class="hidden" href="RDS_DYNVARLINK.htm#ref2" title="Указатель на RDS_DYNVARLINK">RDS_PDYNVARLINK</a></span> Link;
    <span class="kw">double</span> t,dt,A,n,F,Fx,Fy,xp,yp;
  <span class="rem">// </span><a class="hidden" href="pm_2_5_1.htm#light_ref9" title="Макросы для статических переменных блока"><span class="rem">Макроопределения для статических переменных</span></a>
  <span class="preproc">#define pStart ((char *)(BlockData-&gt;VarData))</span>
  <span class="preproc">#define Start  (*((char *)(pStart)))       </span><span class="rem">// 0</span>
  <span class="preproc">#define Ready  (*((char *)(pStart+1)))     </span><span class="rem">// 1</span>
  <span class="preproc">#define D      (*((double *)(pStart+2)))   </span><span class="rem">// 2</span>
  <span class="preproc">#define m      (*((double *)(pStart+10)))  </span><span class="rem">// 3</span>
  <span class="preproc">#define v0     (*((double *)(pStart+18)))  </span><span class="rem">// 4</span>
  <span class="preproc">#define Angle  (*((double *)(pStart+26)))  </span><span class="rem">// 5</span>
  <span class="preproc">#define l0     (*((double *)(pStart+34)))  </span><span class="rem">// 6</span>
  <span class="preproc">#define h0     (*((double *)(pStart+42)))  </span><span class="rem">// 7</span>
  <span class="preproc">#define ValSet (*((char *)(pStart+50)))    </span><span class="rem">// 8</span>
  <span class="preproc">#define x      (*((double *)(pStart+51)))  </span><span class="rem">// 9</span>
  <span class="preproc">#define y      (*((double *)(pStart+59)))  </span><span class="rem">// 10</span>
  <span class="preproc">#define vx     (*((double *)(pStart+67)))  </span><span class="rem">// 11</span>
  <span class="preproc">#define vy     (*((double *)(pStart+75)))  </span><span class="rem">// 12</span>
  <span class="preproc">#define v      (*((double *)(pStart+83)))  </span><span class="rem">// 13</span>
  <span class="preproc">#define Impact (*((char *)(pStart+91)))    </span><span class="rem">// 14</span>
  <span class="preproc">#define t0     (*((double *)(pStart+92)))  </span><span class="rem">// 15</span>
  <span class="preproc">#define InFlight (*((char *)(pStart+100))) </span><span class="rem">// 16</span>
    <span class="rem">// Массив описания параметров для универсальной функции настройки</span>
    <span class="kw">static</span> <span class="kw">char</span> *setup[]={
      <span class="str">"6Длина ствола, м"</span>,
      <span class="str">"7Высота оси, м"</span>,
      <span class="str">"2Диаметр снаряда, м"</span>,
      <span class="str">"3Масса снаряда, кг"</span>,
      <span class="str">"4Начальная скорость, м/с"</span>,
      <span class="str">"5Угол вылета, град."</span>,
      NULL};

    <span class="kw">switch</span>(CallMode)
      { <span class="rem">// Инициализация</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_INIT.htm" title="А.2.4.7. RDS_BFM_INIT &ndash; инициализация блока">RDS_BFM_INIT</a>:
          <span class="rem">// Подписка на динамическую переменную "DynTime"</span>
          Link=<span id="light_ref19"><a class="hidden" href="rdsSubscribeToDynamicVar.htm" title="А.5.16.7. rdsSubscribeToDynamicVar &ndash; создать подписку на динамическую переменную">rdsSubscribeToDynamicVar</a></span>(<span id="light_ref20"><a class="hidden" href="rdsCreateAndSubscribeDV.htm#light_ref4" title="RDS_DVPARENT">RDS_DVPARENT</a></span>,<span class="str">"DynTime"</span>,
                <span class="str">"D"</span>,TRUE);
          BlockData-&gt;BlockData=Link;
          <span class="kw">break</span>;

        <span class="rem">// Очистка</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_CLEANUP.htm" title="А.2.4.3. RDS_BFM_CLEANUP &ndash; очистка данных блока">RDS_BFM_CLEANUP</a>:
          <span class="rem">// Прекращение подписки на "DynTime"</span>
          <span id="light_ref21"><a class="hidden" href="rdsUnsubscribeFromDynamicVar.htm" title="А.5.16.8. rdsUnsubscribeFromDynamicVar &ndash; прекратить подписку на динамическую переменную">rdsUnsubscribeFromDynamicVar</a></span>(
              (<a class="hidden" href="RDS_DYNVARLINK.htm#ref2" title="Указатель на RDS_DYNVARLINK">RDS_PDYNVARLINK</a>)BlockData-&gt;BlockData);
          <span class="kw">break</span>;

        <span class="rem">// Проверка типов переменных</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_VARCHECK.htm" title="А.2.4.18. RDS_BFM_VARCHECK &ndash; проверка допустимости структуры статических переменных блока">RDS_BFM_VARCHECK</a>:
          <span class="kw">return</span> strcmp((<span class="kw">char</span>*)ExtParam,<span class="str">"{SSDDDDDDLDDDDDSDL}"</span>)?
            <a class="hidden" href="RDS_BFM_VARCHECK.htm#light_ref3" title="Возврат RDS_BFR_BADVARSMSG">RDS_BFR_BADVARSMSG</a>:<a class="hidden" href="app_a_2_1.htm#ref2" title="Возврат RDS_BFR_DONE">RDS_BFR_DONE</a>;

        <span class="rem">// Вызов функции настройки</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_SETUP.htm" title="А.2.6.13. RDS_BFM_SETUP &ndash; вызов функции настройки блока">RDS_BFM_SETUP</a>:
          <span class="kw">return</span> <a class="hidden" href="#ref8" title="SetupDoubleVars">SetupDoubleVars</a>(BlockData-&gt;Block,
                  <span class="str">"Внешняя баллистика"</span>,setup);

        <span class="rem">// Изменение динамической переменной</span>
        <span class="kw">case</span> <span id="light_ref22"><a class="hidden" href="RDS_BFM_DYNVARCHANGE.htm" title="А.2.4.4. RDS_BFM_DYNVARCHANGE &ndash; изменение динамической переменной">RDS_BFM_DYNVARCHANGE</a></span>:
          <span class="rem">// Получаем доступ к динамической переменной времени</span>
          Link=(<a class="hidden" href="RDS_DYNVARLINK.htm#ref2" title="Указатель на RDS_DYNVARLINK">RDS_PDYNVARLINK</a>)BlockData-&gt;BlockData;
          <span class="kw">if</span>(Link==NULL || Link-&gt;Data==NULL)	<span class="rem">// Нет доступа</span>
            <span class="kw">break</span>;
          t=*((<span class="kw">double</span>*)Link-&gt;Data); <span class="rem">// В t – текущее время</span>
          <span class="kw">if</span>(t==t0) <span class="rem">// Время не изменилось - ждем</span>
            <span class="kw">break</span>;
          dt=t-t0; <span class="rem">// В dt – интервал времени с прошлого шага</span>
          t0=t;    <span class="rem">// Запоминаем время в t0 чтобы при следующем</span>
                   <span class="rem">// изменени DynTime (t) можно было вычислить dt</span>
          <span class="kw">if</span>(!ValSet) <span class="rem">// Начальные значения еще не считаны</span>
            { <span class="rem">// Начинаем расчет траектории снаряда</span>
              <span class="kw">double</span> alpha=Angle*M_PI/<span class="const">180.0</span>; <span class="rem">// Угол в радианах</span>
              <span class="rem">// Занесение в переменные начальных значений</span>
              vx=v0*cos(alpha);
              vy=v0*sin(alpha);
              v=v0;
              x=l0*cos(alpha);
              y=h0+l0*sin(alpha);
              <span class="rem">// Сбрасываем сигнал падения</span>
              Impact=<span class="const">0</span>;
              <span class="rem">// Разрешаем расчет и взводим ValSet</span>
              InFlight=ValSet=<span class="const">1</span>;
            }
          <span class="kw">else</span> <span class="kw">if</span>(!InFlight) <span class="rem">// Снаряд не в полете – ничего не делаем</span>
            <span class="kw">break</span>;
          <span class="rem">// Вычисление модуля вектора скорости и силы сопротивления</span>
          <span class="rem">// по формуле Забудского</span>
          v=sqrt(vx*vx+vy*vy);
          <span class="kw">if</span>(v&lt;<span class="const">240.0</span>)
            { A=<span class="const">0</span>.<span class="const">0140</span>; n=<span class="const">2</span>; }
          <span class="kw">else</span> <span class="kw">if</span>(v&lt;<span class="const">295.0</span>)
            { A=<span class="const">0</span>.<span class="const">00005</span>83; n=<span class="const">3</span>; }
          <span class="kw">else</span> <span class="kw">if</span>(v&lt;<span class="const">375.0</span>)
            { A=<span class="const">0</span>.<span class="const">000000000670</span>; n=<span class="const">5</span>; }
          <span class="kw">else</span> <span class="kw">if</span>(v&lt;<span class="const">419.0</span>)
            { A=<span class="const">0</span>.<span class="const">0000</span>940; n=<span class="const">3</span>; }
          <span class="kw">else</span> <span class="kw">if</span>(v&lt;<span class="const">550.0</span>)
            { A=<span class="const">0</span>.<span class="const">03</span>94; n=<span class="const">2</span>; }
          <span class="kw">else</span> <span class="kw">if</span>(v&lt;<span class="const">800.0</span>)
            { A=<span class="const">0</span>.<span class="const">2616</span>; n=<span class="const">1.7</span>; }
          <span class="kw">else</span>
            { A=<span class="const">0</span>.<span class="const">713</span>; n=<span class="const">1.55</span>; }
          F=A*M_PI*D*D*pow(v,n)/<span class="const">4.0</span>;	<span class="rem">// Сила сопротивления</span>
          <span class="rem">// Горизонтальная и вертикальная компоненты F</span>
          Fx=F*vx/v;
          Fy=F*vy/v;
          <span class="rem">// Запоминаем текущие значения координат</span>
          xp=x; yp=y;
          <span class="rem">// Вычисляем новые значения координат по</span>
          <span class="rem">// разностным уравнениям</span>
          x+=dt*vx;
          y+=dt*vy;
          <span class="rem">// Вычисляем новые значения компонент вектора скорости</span>
          <span class="rem">// по разностным уравнениям</span>
          vx-=dt*Fx/m;
          vy-=dt*(<span class="const">9.807</span>+Fy/m);
          <span class="kw">if</span>(y&lt;<span class="const">0</span>.<span class="const">0</span>) <span class="rem">// Снаряд встретился с поверхностью</span>
            { Impact=<span class="const">1</span>;   <span class="rem">// Взводим выходной сигнал падения снаряда</span>
              InFlight=<span class="const">0</span>; <span class="rem">// Прекращаем расчет траектории</span>
              <span class="rem">// Вычисляем координату встречи с поверхностью</span>
              x=xp-yp*(x-xp)/(y-yp);
              y=vx=vy=<span class="const">0</span>;
            }
          Ready=<span class="const">1</span>; <span class="rem">// Для передачи выходов по связям</span>
          <span class="kw">break</span>;
      }
    <span class="kw">return</span> <a class="hidden" href="app_a_2_1.htm#ref2" title="Возврат RDS_BFR_DONE">RDS_BFR_DONE</a>;
  <span class="rem">// Отмена макроопределений переменных</span>
  <span class="preproc">#undef InFlight</span>
  <span class="preproc">#undef t0</span>
  <span class="preproc">#undef Impact</span>
  <span class="preproc">#undef v</span>
  <span class="preproc">#undef vy</span>
  <span class="preproc">#undef vx</span>
  <span class="preproc">#undef y</span>
  <span class="preproc">#undef x</span>
  <span class="preproc">#undef ValSet</span>
  <span class="preproc">#undef h0</span>
  <span class="preproc">#undef l0</span>
  <span class="preproc">#undef Angle</span>
  <span class="preproc">#undef v0</span>
  <span class="preproc">#undef m</span>
  <span class="preproc">#undef D</span>
  <span class="preproc">#undef Ready</span>
  <span class="preproc">#undef Start</span>
  <span class="preproc">#undef pStart</span>
  }
  <span class="rem">//=========================================</span></pre>

<p>В самом начале функции модели, после описаний локальных переменных и макроопределений, описывается
статический массив строк <span class="cpp">setup</span>, который будет использоваться для вызова
написанной нами ранее универсальной функции настройки <span class="cpp"><a href="#ref8" title="SetupDoubleVars">SetupDoubleVars</a></span>. Массив описан
как статический, чтобы он не занимал место в стеке функции &ndash; его содержимое будет общим
для всех блоков с моделью <span class="cpp">Ballistics</span> и не будет изменяться в процессе
их работы. Каждая строка массива содержит номер переменной в символьном представлении и заголовок
соответствующего ей поля ввода, которое будет добавлено в окно настройки. Всего в этом блоке у
нас шесть параметров, которые пользователь сможет ввести в окне настройки, либо, при необходимости,
подать с других блоков через связи.</p>

<p>При инициализации блока (вызов с параметром <span class="cpp"><a href="RDS_BFM_CLEANUP.htm" title="А.2.4.3. RDS_BFM_CLEANUP &ndash; очистка данных блока">RDS_BFM_CLEANUP</a></span>) модель отменяет подписку, передавая запомненный указатель в функцию
<span class="cpp"><a href="rdsUnsubscribeFromDynamicVar.htm" title="А.5.16.8. rdsUnsubscribeFromDynamicVar &ndash; прекратить подписку на динамическую переменную">rdsUnsubscribeFromDynamicVar</a></span>. Эти функции уже не один раз встречались в описываемых
примерах. В реакции модели на проверку типа переменных (<span class="cpp"><a href="RDS_BFM_VARCHECK.htm" title="А.2.4.18. RDS_BFM_VARCHECK &ndash; проверка допустимости структуры статических переменных блока">RDS_BFM_VARCHECK</a></span>) тоже нет
ничего нового: переданная в параметре <span class="cpp">ExtParam</span> строка сравнивается со
<a href="pm_1_5.htm#ref19" title="Строка типа переменных блока">строкой</a>, соответствующей нужной нам последовательности переменных, и,
в зависимости от результата сравнения, возвращается константа
<span class="cpp"><a href="RDS_BFM_VARCHECK.htm#light_ref3" title="Возврат RDS_BFR_BADVARSMSG">RDS_BFR_BADVARSMSG</a></span> или <span class="cpp"><a href="app_a_2_1.htm#ref2" title="Возврат RDS_BFR_DONE">RDS_BFR_DONE</a></span>.</p>

<p>В режиме <span class="cpp"><a href="RDS_BFM_SETUP.htm" title="А.2.6.13. RDS_BFM_SETUP &ndash; вызов функции настройки блока">RDS_BFM_SETUP</a></span> модель вызывает универсальную функцию настройки
<span class="cpp"><a class="hidden" href="#ref8" title="SetupDoubleVars">SetupDoubleVars</a></span>, в которую передается идентификатор настраиваемого блока,
заголовок окна настройки &laquo;Внешняя баллистика&raquo; и массив строк описаний полей ввода
<span class="cpp">setup</span>, описанный в начале функции модели. Все необходимые действия по созданию
полей ввода, открытию окна и записи измененных пользователем параметров в значения переменных блока выполняются
внутри этой функции.</p>

<p>Расчет траектории полета снаряда производится в реакции на изменение динамической переменной
<span class="cpp"><a href="RDS_BFM_DYNVARCHANGE.htm" title="А.2.4.4. RDS_BFM_DYNVARCHANGE &ndash; изменение динамической переменной">RDS_BFM_DYNVARCHANGE</a></span>, реакция на такт моделирования
<span class="cpp"><a href="RDS_BFM_MODEL.htm" title="А.2.4.9. RDS_BFM_MODEL &ndash; выполнение такта расчета">RDS_BFM_MODEL</a></span> в этой модели отсутствует: все действия выполняются только при
изменении времени. Блок подписан на единственную динамическую переменную &ndash; время
&laquo;<span class="rdsvar">DynTime</span>&raquo;, поэтому вызов <span class="cpp"><a class="hidden" href="RDS_BFM_DYNVARCHANGE.htm" title="А.2.4.4. RDS_BFM_DYNVARCHANGE &ndash; изменение динамической переменной">RDS_BFM_DYNVARCHANGE</a></span> означает, что
время в системе изменилось. Прежде всего модель проверяет, есть ли у нее доступ к переменной времени. Если
его нет, функция модели немедленно завершается, если есть &ndash; значение времени записывается во
вспомогательную переменную <span class="cpp">t</span>. Для расчета координат и составляющих вектора
скорости снаряда по разностным уравнениям необходимо знать интервал времени &Delta;<i>t</i>,
прошедший с последнего вычисления этих значений. Если значение <span class="cpp">t</span> будет равно значению
<span class="cpp">t0</span>, то есть значению времени на момент последнего вычисления, значит,
время в системе с прошлого раза не изменилось, и ничего вычислять не нужно &ndash; модель немедленно завершается.
В противном случае из текущего значения времени <span class="cpp">t</span> вычитается значение времени
при прошлом вычислении <span class="cpp">t0</span> и полученная разность присваивается переменной
<span class="cpp">dt</span> &ndash; это и есть интересующий нас интервал времени. Затем переменной
<span class="cpp">t0</span> присваивается текущее время, чтобы в следующий раз при изменении
времени можно было снова определить интервал &Delta;<i>t</i>.</p>

<p>После того, как интервал <span class="cpp">dt</span> вычислен, и переменной
<span class="cpp">t0</span> присвоено новое значение времени, модель проверяет, считаны ли уже
значения начальной скорости снаряда и угла возвышения метательной машины. Если значение логической переменной
<span class="cpp">ValSet</span> нулевое, эти значения нужно считать сейчас: мы уже знаем, что системное
время изменилось, значит, планировщик уже выполнил все начальные такты, заданные в его настройках.
В этом случае угол <span class="cpp">Angle</span> переводится в радианы и записывается во вспомогательную переменную
<span class="cpp">alpha</span>, вычисляются начальные значения горизонтальной и вертикальной составляющих
скорости снаряда <span class="cpp">vx</span> и <span class="cpp">vy</span> и начальные координаты снаряда
<span class="cpp">x</span> и <span class="cpp">y</span> (они соответствуют координатам конца ствола
метательной машины при данном угле возвышения). После этого сбрасывается сигнал падения снаряда
<span class="cpp">Impact</span>, и взводятся логические переменные <span class="cpp">ValSet</span> (мы
уже считали <span class="cpp">v0</span> и <span class="cpp">Angle</span> и больше ничего не ждем) и
<span class="cpp">InFlight</span> (снаряд теперь в полете, и мы начинаем расчет его траектории).</p>

<p>Если значение <span class="cpp">ValSet</span> было ненулевым, мы проверяем
<span class="cpp">InFlight</span>: если ее значение нулевое, значит, снаряд уже закончил свой полет,
и модель немедленно завершается.</p>

<p>После того, как модель убедилась, что снаряд находится в полете, вычисляется модуль вектора его скорости
<span class="cpp">v</span> &ndash; он нужен для определения силы сопротивления воздуха. В зависимости
от скорости по приведенной выше таблице определяются параметры <span class="cpp">A</span> и <span class="cpp">n</span>,
используемые в формуле Забудского, после чего вычисляется модуль силы сопротивления
<span class="cpp">F</span>, который затем раскладывается на горизонтальную и вертикальную составляющие
<span class="cpp">Fx</span> и <span class="cpp">Fy</span>. По приведенным
<a href="#ref5" title="Разностные уравнения полета снаряда">выше</a> разностным уравнениям вычисляются новые значения координат
снаряда <span class="cpp">x</span> и <span class="cpp">y</span> и составляющих его скорости
<span class="cpp">vx</span> и <span class="cpp">vy</span>, причем предыдущие значения координат запоминаются
в переменных <span class="cpp">xp</span> и <span class="cpp">yp</span> &ndash; они понадобятся для вычисления
координат точки встречи снаряда с поверхностью, если она произошла.</p>

<p>Если очередное вычисленное значение координаты <span class="cpp">y</span> стало отрицательным, значит,
траектория снаряда пересеклась с поверхностью земли. В этом случае выходному сигналу <span class="cpp">Impact</span>
присваивается единица, а логической переменной <span class="cpp">InFlight</span> &ndash; ноль, что прекратит
дальнейший расчет траектории. Затем, согласно <a href="#pic4" title="Определение точки встречи снаряда с поверхностью">рис.&nbsp;97</a>,
вычисляется горизонтальная координата встречи снаряда с поверхностью, которая присваивается переменной
<span class="cpp">x</span>. Переменной <span class="cpp">y</span> присваивается значение 0 &ndash;
снаряд лежит на земле. Поскольку, начиная с этого момента, дальнейший расчет траектории вестись не будет,
значения <span class="cpp">x</span> и <span class="cpp">y</span> больше не изменятся, и значение
<span class="cpp">x</span> на момент выдачи блоком сигнала <span class="cpp">Impact</span> можно считать дальностью полета снаряда.</p>

<p>В самом конце реакции на вызов <span class="cpp"><a class="hidden" href="RDS_BFM_DYNVARCHANGE.htm" title="А.2.4.4. RDS_BFM_DYNVARCHANGE &ndash; изменение динамической переменной">RDS_BFM_DYNVARCHANGE</a></span> переменной
<span class="cpp"><a href="um_1_4.htm#ref27" title="Сигнал готовности блока">Ready</a></span> присваивается значение 1, чтобы выходы, вычисленные
в этом вызове, передались по связям. На этом работа модели блока завершается.</p>

<p>Теперь можно протестировать созданный нами блок. Для этого, прежде всего, нужно создать новый блок,
<a href="pm_1_5.htm" title="&sect;1.5. Статические переменные блоков, входы и выходы">задать</a>
для него указанную выше структуру переменных,
<a href="pm_1_4.htm#pic3" title="Параметры блока &ndash; модель и реакции">подключить</a>
к нему созданную модель <span class="cpp">Ballistics</span>, включить в параметрах блока функцию настройки и
задать для блока <a href="pm_1_4.htm#ref5" title="Запуск модели каждый такт">запуск по сигналу</a>. Теперь можно собрать вокруг блока схему,
изображенную
на <a href="#pic6" title="Схема для проверки блока расчета траектории снаряда">рис.&nbsp;99</a>.</p>

<div class="pic"><div class="container" id="pic6">
<img src="../img/Ballistics0.png" width="873" height="455" alt="Схема для проверки блока расчета траектории снаряда" />
<p id="light_pic6">Рис.&nbsp;99. Схема для проверки блока расчета траектории снаряда</p>
</div></div>


<div class="picright"><div class="container" id="pic7">
<img src="../img/Ballistics0_setup.png" width="432" height="267" alt="Окно настройки блока расчета траектории снаряда" />
<p id="light_pic7">Рис.&nbsp;100. Окно настройки блока расчета<br />траектории снаряда</p>
</div></div>


<p>Все параметры блока, кроме начальной скорости снаряда &laquo;<span class="rdsvar">v0</span>&raquo; и угла возвышения
&laquo;<span class="rdsvar">Angle</span>&raquo;, заданы через функцию настройки
(<a href="#pic7" title="Окно настройки блока расчета траектории снаряда">рис.&nbsp;100</a>).
К выходам &laquo;<span class="rdsvar">x</span>&raquo; и &laquo;<span class="rdsvar">y</span>&raquo; нашего блока присоединен стандартный график для построения
фазового портрета, то есть параметрической функции (<i>x</i>(<i>t</i>), <i>y</i>(<i>t</i>)) &ndash;
он будет отображать траекторию полета. Выход &laquo;<span class="rdsvar">Impact</span>&raquo; нашего блока соединен с входом
&laquo;<span class="rdsvar">Stop</span>&raquo; блока запуска и остановки расчета, созданного нами в
<a href="pm_2_14_1.htm" title="&sect;2.14.1. Запуск и остановка расчета">&sect;2.14.1</a>. Как только снаряд достигнет поверхности и наш блок выдаст
сигнал &laquo;<span class="rdsvar">Impact</span>&raquo;, этот блок остановит расчет.</p>

<p>Для правильной работы схемы необходимо настроить блок-планировщик согласно
<a href="#pic5" title="Настройки планировщика для расчета траектории снаряда">рис.&nbsp;98</a>. Во-первых, необходимо отключить завершение
расчета по времени &ndash; для остановки расчета после падения снаряда мы подключили специальный блок.
Во-вторых, нужно выбрать шаг расчета. Самые быстро изменяющиеся величины в модели полета снаряда &ndash;
это координаты &laquo;<span class="rdsvar">x</span>&raquo; и &laquo;<span class="rdsvar">y</span>&raquo;, максимально возможная скорость снаряда,
для которой мы еще можем считать сопротивление воздуха, равна 1000 м/с, поэтому для определения дальности с
точностью около одного метра можно выбрать шаг порядка одной тысячной секунды. И, в-третьих, как уже было указано
выше, следует задать некоторое количество начальных тактов или, лучше всего, установить флаг
&laquo;<span class="menu">авто</span>&raquo;. Так мы будем уверены, что на момент первого изменения времени планировщиком значения
&laquo;<span class="rdsvar">v0</span>&raquo; и &laquo;<span class="rdsvar">Angle</span>&raquo; уже успеют установиться.</p>

<p>Результат моделирования полета снаряда с указанными в настройках параметрами при начальной скорости
700 м/с и угле возвышения 45&deg; изображен на <a href="#pic6" title="Схема для проверки блока расчета траектории снаряда">рис.&nbsp;99</a>.
Видно, что из-за влияния сопротивления воздуха траектория снаряда отличается от параболы.</p>

<p>Теперь мы перейдем к главной задаче: сделаем блок, который подберет такой угол возвышения метательной машины,
чтобы дальность полета снаряда была как можно ближе к заданной. Это достаточно обычная оптимизационная задача,
для решения которой существует множество способов. Будем считать, что у метательной машины есть допустимый
диапазон углов возвышения (например, от 0&deg; до 90&deg;), в пределах которого мы можем установить любой
угол, но только с заданной точностью. Например, если точность установки угла будет равной одной десятой градуса,
мы сможем установить углы в 30.1&deg;, 30.2&deg;, 30.3&deg;, но не сможем установить угол в 30.15&deg;
&ndash; у нас просто не хватит точности исполнительного механизма, или цены деления шкалы, если угол
устанавливается вручную. Будем решать нашу задачу следующим образом: установим максимально возможный угол
возвышения, выполним расчет и, дождавшись падения снаряда на землю (получив от блока расчета траектории сигнал
&laquo;<span class="rdsvar">Impact</span>&raquo;), определим величину промаха, то есть разность между заданной и получившейся дальностью для
этого угла. Выберем какой-либо шаг, с которым мы будем изменять угол &ndash; например, одну пятую всего
диапазона. Сбросим в исходное состояние подсистему, в которой будет находиться наш блок вместе с блоком
расчета траектории (моделью <span class="cpp">Ballistics</span>), и уменьшим угол на выбранную величину
шага (мы начали с максимально возможного угла возвышения, поэтому мы можем только уменьшать его). Поскольку
расчет мы не останавливали, полет снаряда будет промоделирован снова, но уже с другим углом возвышения.
Снова дождемся падения снаряда, и определим новую величину промаха. Если она стала меньше, будем
уменьшать угол с этим шагом, каждый раз сбрасывая расчет и повторяя его заново до тех пор, пока промах
будет уменьшаться. Как только промах начнет увеличиваться, вернемся к предыдущему значению угла, уменьшим
шаг по углу вдвое и снова попробуем уменьшить угол, но уже с новым шагом. Если промах уменьшился, продолжим
уменьшать угол, если же он увеличился &ndash; попробуем, наоборот, увеличивать его. Если и увеличение,
и уменьшение угла с данным шагом приводит к увеличению промаха, еще раз уменьшим шаг по углу вдвое
и снова попытаемся уменьшать или увеличивать угол. Так мы будем действовать до тех пор, пока шаг,
с которым мы изменяем угол, не станет меньше точности установки угла, определяемой конструкцией механизма
наведения нашей машины. Тогда последнее значение угла, при котором промах был наименьшим, и будет искомым
углом возвышения для заданной дальности. Описанный метод поиска является упрощением стандартного метода
покоординатного спуска для случая единственной координаты &ndash; угла возвышения.</p>

<p>После того, как алгоритм поиска завершится и искомый угол возвышения будет найден, нужно будет
еще раз провести расчет для этого значения угла, чтобы, если пользователь включил в схему какие-либо
графики (например, график траектории, как на <a href="#pic6" title="Схема для проверки блока расчета траектории снаряда">рис.&nbsp;99</a>), на
них отобразились бы координаты или скорости снаряда именно для найденного значения. Предыдущий
расчет, проведенный в рамках алгоритма, был очередной попыткой изменить угол, поэтому он, очевидно,
не будет соответствовать углу возвышения, промах для которого минимален.</p>

<p><span id="ref23">Несмотря</span>
на простой алгоритм поиска, <span id="light_ref23">модель блока</span>, который будет его осуществлять,
будет довольно сложной. После каждого вычисления дальности этот блок должен сбросить в исходное
состояние подсистему, в которой он будет находиться вместе с блоком расчета траектории снаряда,
и изменить значение угла возвышения согласно алгоритму. Поскольку все статические переменные блока
при сбросе вернутся к начальным значениям, в них нельзя хранить такие значения, как текущий
проверяемый угол возвышения, наименьший на данный момент промах и соответствующий ему угол и т.д.
Эти значения не должны сбрасываться при каждом расчете дальности, иначе алгоритм не будет работать. Мы
воспользуемся тем, что сброс расчета не затрагивает личную область данных блока, и будем хранить
эти переменные в ней. Оформим личную область данных как класс:</p>

<pre class="cpp">  <span class="rem">//==============================================</span>
  <span class="rem">// Поиск угла возвышения для заданной дальности</span>
  <span class="rem">//==============================================</span>
  <span class="rem">// Личная область данных блока</span>
  <span class="kw">class</span> TArtSearchData
  { <span class="kw">public</span>:
      <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> SelfReset;   <span class="rem">// Блок сам сбросил подсистему</span>
      <span class="kw">int</span> Mode;         <span class="rem">// Текущее состояние алгоритма:</span>
        <span class="preproc">#define ASMODE_READY      0 </span><span class="rem">// Готов к поиску</span>
        <span class="preproc">#define ASMODE_SEARCHING  1 </span><span class="rem">// Идет поиск</span>
        <span class="preproc">#define ASMODE_FINALRUN   2 </span><span class="rem">// Последний прогон</span>
        <span class="preproc">#define ASMODE_FINISHED   3 </span><span class="rem">// Поиск завершен</span>
      <span class="kw">double</span> AngleStep; <span class="rem">// Текущий шаг изменения угла</span>
      <span class="kw">double</span> AngleToSet;<span class="rem">// Угол, который нужно установить</span>
                        <span class="rem">// после сброса</span>
      <span class="kw">double</span> OptAngle;  <span class="rem">// Наилучший на данный момент угол</span>
      <span class="kw">double</span> OptMiss;   <span class="rem">// Наименьший на данный момент промах</span>
      <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> FirstStep;   <span class="rem">// Проведенное моделирование – первое с</span>
                        <span class="rem">// новым шагом изменения угла</span>


      <span class="rem">// Ограничение диапазона и точности установки угла</span>
      <span class="kw">double</span> FixAngle(<span class="kw">double</span> a,<span class="kw">double</span> amin,<span class="kw">double</span> amax,<span class="kw">double</span> acc)
        { <span class="kw">if</span>(a&lt;amin) <span class="kw">return</span> amin;
          <span class="kw">if</span>(a&gt;amax) <span class="kw">return</span> amax;
          <span class="kw">return</span> <span id="light_ref24">floor</span>((a-amin)/acc)*acc+amin;
        };

      <span class="rem">// Вывод сообщения о результатах поиска</span>
      <span class="kw">void</span> ShowResults(<span class="kw">void</span>)
        { <span class="kw">char</span> *str,
               *angle=<span id="light_ref25"><a class="hidden" href="rdsDtoA.htm" title="А.5.4.5. rdsDtoA &ndash; преобразование вещественного числа в строку">rdsDtoA</a></span>(OptAngle,-<span class="const">1</span>,NULL),
               *miss=<a class="hidden" href="rdsDtoA.htm" title="А.5.4.5. rdsDtoA &ndash; преобразование вещественного числа в строку">rdsDtoA</a>(OptMiss,<span class="const">0</span>,NULL);
          <span class="rem">// Формирование динамической строки с сообщением</span>
          str=<span id="light_ref26"><a class="hidden" href="rdsDynStrCat.htm" title="А.5.4.6. rdsDynStrCat &ndash; сложение двух строк">rdsDynStrCat</a></span>(<span class="str">"Угол возвышения: "</span>,angle,FALSE);
          <span id="light_ref27"><a class="hidden" href="rdsAddToDynStr.htm" title="А.5.4.1. rdsAddToDynStr &ndash; добавление строки к динамически отведенной строке">rdsAddToDynStr</a></span>(&amp;str,<span class="str">" гр.\nПромах: "</span>,FALSE);
          <a class="hidden" href="rdsAddToDynStr.htm" title="А.5.4.1. rdsAddToDynStr &ndash; добавление строки к динамически отведенной строке">rdsAddToDynStr</a>(&amp;str,miss,FALSE);
          <a class="hidden" href="rdsAddToDynStr.htm" title="А.5.4.1. rdsAddToDynStr &ndash; добавление строки к динамически отведенной строке">rdsAddToDynStr</a>(&amp;str,<span class="str">" м"</span>,FALSE);
          <span class="rem">// Вывод текста</span>
          <span id="light_ref28"><a class="hidden" href="rdsMessageBox.htm" title="А.5.5.6. rdsMessageBox &ndash; вывод окна сообщения">rdsMessageBox</a></span>(str,<span class="str">"Поиск завершен"</span>,<a class="hidden" href="rdsMessageBox.htm#light_ref7" title="MB_OK">MB_OK</a>);
          <span class="rem">// Освобождение всех динамических строк</span>
          <span id="light_ref29"><a class="hidden" href="rdsFree.htm" title="А.5.4.8. rdsFree &ndash; освобождение отведенной динамической памяти">rdsFree</a></span>(str);
          <a class="hidden" href="rdsFree.htm" title="А.5.4.8. rdsFree &ndash; освобождение отведенной динамической памяти">rdsFree</a>(angle);
          <a class="hidden" href="rdsFree.htm" title="А.5.4.8. rdsFree &ndash; освобождение отведенной динамической памяти">rdsFree</a>(miss);
        };

      <span class="rem">// Конструктор класса</span>
      TArtSearchData(<span class="kw">void</span>)
        { SelfReset=FALSE;
          Mode=ASMODE_READY;
        };
  };
  <span class="rem">//=========================================</span></pre>

<p>Наш блок должен по-разному реагировать на сброс и на запуск расчета в зависимости от того,
чем он в данный момент занят. Он должен отличать сброс расчета, выполненный пользователем,
от сброса состояния подсистемы, выполненного самим блоком: в первом случае нужно прекратить поиск и
вернуть все параметры в исходное состояние, во втором &ndash; продолжить поиск с новым значением угла. Для
того, чтобы различать эти два случая, мы ввели в класс личной области данных блока логическое поле
<span class="cpp">SelfReset</span> с исходным значением <span class="cpp">FALSE</span> (исходное
значение задается в конструкторе класса). Перед программным сбросом модель будет присваивать этому
полю значение <span class="cpp">TRUE</span>, а в конце реакции на сброс расчета
(<span class="cpp"><a href="RDS_BFM_RESETCALC.htm" title="А.2.4.12. RDS_BFM_RESETCALC &ndash; сброс расчета">RDS_BFM_RESETCALC</a></span>) снова сбрасывать его в <span class="cpp">FALSE</span>.
Таким образом, если расчет сброшен пользователем, при вызове модели в режиме
<span class="cpp"><a class="hidden" href="RDS_BFM_RESETCALC.htm" title="А.2.4.12. RDS_BFM_RESETCALC &ndash; сброс расчета">RDS_BFM_RESETCALC</a></span> поле <span class="cpp">SelfReset</span> будет иметь значение
<span class="cpp">FALSE</span>, а если расчет сброшен моделью блока &ndash; <span class="cpp">TRUE</span>.</p>

<p>Нам также необходимо хранить текущее состояние алгоритма, то есть выполняемое им в данный момент
действие. Для этого в класс введено целое поле <span class="cpp">Mode</span> и определены символические
константы для каждого из состояний блока:</p>

<ul>
  <li><span class="cpp">ASMODE_READY</span> &ndash; поиск угла еще не проводился, блок в
  исходном состоянии (это значение присваивается полю <span class="cpp">Mode</span> в конструкторе класса);</li>

  <li><span class="cpp">ASMODE_SEARCHING</span> &ndash; идет поиск угла;</li>

  <li><span class="cpp">ASMODE_FINALRUN</span> &ndash; идет последний расчет с найденным значением угла возвышения;</li>

  <li><span class="cpp">ASMODE_FINISHED</span> &ndash; поиск завершен.</li>
</ul>

<p class="noindent">При самом первом запуске расчета или после сброса расчета пользователем блок
будет находиться в состоянии <span class="cpp">ASMODE_READY</span>. Как только расчет будет запущен, блок
перейдет в состояние <span class="cpp">ASMODE_SEARCHING</span>, и будет находиться в нем до тех пор,
пока алгоритм не закончит работу. Затем блок перейдет в состояние <span class="cpp">ASMODE_FINALRUN</span>
и будет проведен последний расчет для найденного значения угла. После завершения расчета состояние блока
изменится на <span class="cpp">ASMODE_FINISHED</span>, и расчет остановится. В зависимости от
значения переменной <span class="cpp">Mode</span> блок будет по-разному реагировать на запуск расчета и
на получение значения дальности полета снаряда от блока расчета траектории (то есть на конец очередного расчета
дальности).</p>

<p>Для того чтобы в процессе поиска после очередного программного сброса состояния подсистемы установить
новое значение угла, в личной области данных нам потребуется поле для хранения этого значения: значение,
которое нужно установить, мы сможем вычислить только в конце очередного расчета дальности, а
установить его можно только после сброса, иначе установленное значение сбросится вместе со
всеми остальными переменными. С этой целью в класс введено вещественное поле
<span class="cpp">AngleToSet</span>: в конце расчета мы запишем в него новое значение угла, а
в реакции модели на сброс расчета скопируем значение из этого поля в соответствующий выход блока,
который будет подключен к входу <span class="cpp">Angle</span> блока расчета траектории. Три оставшихся вещественных
поля класса хранят текущие параметры алгоритма: шаг по углу, используемый в данный момент
(<span class="cpp">AngleStep</span>), наилучший на данный момент угол возвышения
(<span class="cpp">OptAngle</span>) и промах при этом значении угла
(<span class="cpp">OptMiss</span>).</p>

<p>Последнее логическое поле класса, <span class="cpp">FirstStep</span>, будет использоваться для переключения
направления изменения угла. При каждом уменьшении шага по углу мы будем присваивать этому полю значение
<span class="cpp">TRUE</span>, а после любого изменения угла &ndash; <span class="cpp">FALSE</span>. Согласно
алгоритму поиска, после очередного уменьшения величины шага мы сначала должны попытаться уменьшить угол
с этим шагом, а если промах при этом возрастет, попытаться увеличить угол. Если при возрастании промаха поле
<span class="cpp">FirstStep</span> имело значение <span class="cpp">TRUE</span>, значит, это была первая
попытка изменить угол с новым шагом, и нужно изменить знак шага, то есть перейти от уменьшения угла к
увеличению с тем же шагом. Если же поле имело значение <span class="cpp">FALSE</span>, значит, либо это не
первый шаг по углу в этом направлении (в этом случае двигаться обратно с тем же шагом бессмысленно &ndash;
мы там уже побывали), либо мы только что изменили знак шага, не меняя его величину, то есть начали изменять
угол в другом направлении, поскольку старое направление изменения угла приводило к возрастанию промаха.
В обоих случаях нужно будет уменьшать шаг и снова пытаться изменить угол, но уже с новым шагом. Таким образом,
если при очередном расчете промах увеличится и <span class="cpp">FirstStep</span> будет иметь значение
<span class="cpp">FALSE</span>, нужно уменьшить шаг по углу вдвое.</p>

<p>На самом деле, не важно, будем ли мы после уменьшения шага сначала пытаться уменьшать угол, а
потом увеличивать, или, наоборот, сначала увеличивать, а потом уменьшать. Поэтому мы не будем следить за
знаком шага при его уменьшении &ndash; будем оставлять его прежним, а если промах возрастет, менять знак
шага на противоположный.</p>

<p>Кроме полей, необходимых для реализации алгоритма поиска, в классе личной области данных блока описаны
две вспомогательные функции. Первая из них, <span class="cpp">FixAngle</span>, корректирует переданное ей значение
угла a таким образом, чтобы оно, во-первых, оставалось в заданном диапазоне
<span class="cpp">amin</span>&hellip;<span class="cpp">amax</span>, и, во-вторых, соответствовало заданной
точности <span class="cpp">acc</span>. Изменяя угол в процессе поиска, мы можем выйти из допустимого
диапазона углов возвышения, а уменьшая шаг по углу &ndash; получить значение угла, которое не может быть
установлено механизмом нашей метательной машины. Допустим, метательная машина позволяет установить
угол возвышения с точностью до 0.1&deg;, текущее значение угла &ndash; 45&deg;, а текущий шаг по углу
&ndash; 0.5&deg;. Если мы, согласно алгоритму, уменьшим шаг вдвое и попытаемся уменьшить угол возвышения
на этот шаг, мы получим 45&deg;&minus;0.25&deg;=44.75&deg;. Такой угол не может быть установлен с
точностью 0.1&deg;, и нам придется выбрать ближайшее допустимое значение, то есть 44.8&deg;. Функция
<span class="cpp">FixAngle</span> округляет значение угла до заданной точности, возвращая для переданного ей
угла <span class="cpp">a</span> ближайшее значение вида <span class="cpp">amin</span>+<i>N</i>&times;<span class="cpp">acc</span>, где
<i>N</i> &ndash; целое число.</p>

<p>Вторая функция класса, <span class="cpp">ShowResults</span>, служит для демонстрации результатов поиска
пользователю. В ней значения найденного угла <span class="cpp">OptAngle</span> и соответствующего ему промаха
<span class="cpp">OptMiss</span> преобразуются в динамически отводимые строки при помощи уже
использовавшейся ранее сервисной функции RDS <span class="cpp"><a href="rdsDtoA.htm" title="А.5.4.5. rdsDtoA &ndash; преобразование вещественного числа в строку">rdsDtoA</a></span>. Затем при помощи функций
<span class="cpp"><a href="rdsDynStrCat.htm" title="А.5.4.6. rdsDynStrCat &ndash; сложение двух строк">rdsDynStrCat</a></span> и <span class="cpp"><a href="rdsAddToDynStr.htm" title="А.5.4.1. rdsAddToDynStr &ndash; добавление строки к динамически отведенной строке">rdsAddToDynStr</a></span> из этих строк формируется
сообщение пользователю, которое выводится функцией <span class="cpp"><a href="rdsMessageBox.htm" title="А.5.5.6. rdsMessageBox &ndash; вывод окна сообщения">rdsMessageBox</a></span>. В конце функции
все динамически созданные строки уничтожаются при помощи <span class="cpp"><a href="rdsFree.htm" title="А.5.4.8. rdsFree &ndash; освобождение отведенной динамической памяти">rdsFree</a></span>.</p>

<p>Для того, чтобы блок поиска угла можно было присоединить к блоку расчета траектории, и
чтобы было где хранить настроечные параметры поиска, потребуется следующая структура переменных:</p>

<div class="tablecenter"><div class="tcont">
<table>

  <tr>
    <th>Смещение</th>
    <th>Имя</th>
    <th>Тип</th>
    <th>Размер</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
    <th>Назначение</th>
    <th>Номер</th>
  </tr><tr><td class="center">0</td>
<td class="vcenter">Start</td>
<td class="center">Сигнал</td>
<td class="center">1</td>
<td class="center">Вход</td>
<td class="center">&checkmark;</td>
<td class="center">0</td>
<td>Стандартный сигнал запуска</td><td class="center">0</td>
</tr>
<tr><td class="center">1</td>
<td class="vcenter">Ready</td>
<td class="center">Сигнал</td>
<td class="center">1</td>
<td class="center">Выход</td>
<td></td>
<td class="center">0</td>
<td>Стандартный сигнал готовности</td><td class="center">1</td>
</tr>
<tr><td class="center">2</td>
<td class="vcenter">MinAngle</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Внутренняя</td>
<td></td>
<td class="center">0</td>
<td>Минимально возможный угол возвышения, градусов</td><td class="center">2</td>
</tr>
<tr><td class="center">10</td>
<td class="vcenter">MaxAngle</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Внутренняя</td>
<td></td>
<td class="center">90</td>
<td>Максимально возможный угол возвышения, градусов</td><td class="center">3</td>
</tr>
<tr><td class="center">18</td>
<td class="vcenter">Accuracy</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Внутренняя</td>
<td></td>
<td class="center">0.1</td>
<td>Точность установки угла, градусов</td><td class="center">4</td>
</tr>
<tr><td class="center">26</td>
<td class="vcenter">Distance</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Внутренняя</td>
<td></td>
<td class="center">100</td>
<td>Дальность полета, для которой ищется угол возвышения, м</td><td class="center">5</td>
</tr>
<tr><td class="center">34</td>
<td class="vcenter">x</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Вход</td>
<td></td>
<td class="center">0</td>
<td>Текущая горизонтальная координата снаряда, м (от блока расчета траектории)</td><td class="center">6</td>
</tr>
<tr><td class="center">42</td>
<td class="vcenter">Impact</td>
<td class="center">Сигнал</td>
<td class="center">1</td>
<td class="center">Вход</td>
<td class="center">&checkmark;</td>
<td class="center">0</td>
<td>Сигнал о падении снаряда (от блока расчета траектории)</td><td class="center">7</td>
</tr>
<tr><td class="center">43</td>
<td class="vcenter">Angle</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Выход</td>
<td></td>
<td class="center">0</td>
<td>Текущий угол возвышения, градусов (к блоку расчета траектории)</td><td class="center">8</td>
</tr>


</table>
</div></div>

<p>Значения переменных <span class="cpp">MinAngle</span>, <span class="cpp">MaxAngle</span>,
<span class="cpp">Accuracy</span> и <span class="cpp">Distance</span> будут задаваться пользователем в
функции настройки блока &ndash; это параметры алгоритма поиска. Входы <span class="cpp">x</span> и
<span class="cpp">Impact</span> нужно будет соединить с одноименными выходами блока расчета траектории снаряда:
когда блок расчета определит точку падения снаряда и выдаст сигнал <span class="cpp"></span>, с входа
<span class="cpp">x</span> можно будет считать дальность полета снаряда. Выход
<span class="cpp"></span> будет соединяться с одноименным входом блока расчета траектории, через
него блок поиска угла передаст текущий угол возвышения, для которого нужно определить дальность.</p>

<p>Модель блока поиска угла будет такой:</p>

<pre class="cpp">  <span class="rem">// Модель блока поиска угла для заданной дальности</span>
  <span class="kw">extern</span> <span class="str">"C"</span> <span class="kw">__declspec</span>(<span class="kw">dllexport</span>)
      <span class="kw">int</span> <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> ArtSearch(<span class="kw">int</span> CallMode,
                            <a class="hidden" href="RDS_BLOCKDATA.htm#ref2" title="Указатель на RDS_BLOCKDATA">RDS_PBLOCKDATA</a> BlockData,
                            <a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> ExtParam)
  { TArtSearchData *data=(TArtSearchData*)(BlockData-&gt;BlockData);
    <span class="kw">double</span> delta;
  <span class="rem">// </span><a class="hidden" href="pm_2_5_1.htm#light_ref9" title="Макросы для статических переменных блока"><span class="rem">Макроопределения для статических переменных</span></a>
  <span class="preproc">#define pStart   ((char *)(BlockData-&gt;VarData))</span>
  <span class="preproc">#define Start    (*((char *)(pStart)))      </span><span class="rem">// 0</span>
  <span class="preproc">#define Ready    (*((char *)(pStart+1)))    </span><span class="rem">// 1</span>
  <span class="preproc">#define MinAngle (*((double *)(pStart+2)))  </span><span class="rem">// 2</span>
  <span class="preproc">#define MaxAngle (*((double *)(pStart+10))) </span><span class="rem">// 3</span>
  <span class="preproc">#define Accuracy (*((double *)(pStart+18))) </span><span class="rem">// 4</span>
  <span class="preproc">#define Distance (*((double *)(pStart+26))) </span><span class="rem">// 5</span>
  <span class="preproc">#define x        (*((double *)(pStart+34))) </span><span class="rem">// 6</span>
  <span class="preproc">#define Impact   (*((char *)(pStart+42)))   </span><span class="rem">// 7</span>
  <span class="preproc">#define Angle    (*((double *)(pStart+43))) </span><span class="rem">// 8</span>
    <span class="rem">// Массив описания параметров для универсальной функции настройки</span>
    <span class="kw">static</span> <span class="kw">char</span> *setup[]={
      <span class="str">"2Минимальный угол, град."</span>,
      <span class="str">"3Максимальный угол, град."</span>,
      <span class="str">"4Точность по углу, град."</span>,
      <span class="str">"5Дальность цели, м"</span>,
      NULL};

    <span class="kw">switch</span>(CallMode)
      { <span class="rem">// Инициализация</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_INIT.htm" title="А.2.4.7. RDS_BFM_INIT &ndash; инициализация блока">RDS_BFM_INIT</a>:
          BlockData-&gt;BlockData=<span class="kw">new</span> TArtSearchData();
          <span class="kw">break</span>;

        <span class="rem">// Очистка</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_CLEANUP.htm" title="А.2.4.3. RDS_BFM_CLEANUP &ndash; очистка данных блока">RDS_BFM_CLEANUP</a>:
          <span class="kw">delete</span> data;
          <span class="kw">break</span>;

        <span class="rem">// Проверка типов переменных</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_VARCHECK.htm" title="А.2.4.18. RDS_BFM_VARCHECK &ndash; проверка допустимости структуры статических переменных блока">RDS_BFM_VARCHECK</a>:
          <span class="kw">return</span> strcmp((<span class="kw">char</span>*)ExtParam,<span class="str">"{SSDDDDDSD}"</span>)?
            <a class="hidden" href="RDS_BFM_VARCHECK.htm#light_ref3" title="Возврат RDS_BFR_BADVARSMSG">RDS_BFR_BADVARSMSG</a>:<a class="hidden" href="app_a_2_1.htm#ref2" title="Возврат RDS_BFR_DONE">RDS_BFR_DONE</a>;

        <span class="rem">// Вызов функции настройки</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_SETUP.htm" title="А.2.6.13. RDS_BFM_SETUP &ndash; вызов функции настройки блока">RDS_BFM_SETUP</a>:
          <span class="kw">return</span> <a class="hidden" href="#ref8" title="SetupDoubleVars">SetupDoubleVars</a>(BlockData-&gt;Block,
              <span class="str">"Поиск угла"</span>,setup);

        <span class="rem">// Запуск расчета</span>
        <span class="kw">case</span> <span id="light_ref30"><a class="hidden" href="RDS_BFM_STARTCALC.htm" title="А.2.4.14. RDS_BFM_STARTCALC &ndash; запуск расчета">RDS_BFM_STARTCALC</a></span>:
          <span class="kw">switch</span>(data-&gt;Mode)
            { <span class="kw">case</span> ASMODE_READY:
                <span class="rem">// Начать поиск угла</span>
                Angle=MaxAngle;	<span class="rem">// Начальное значение</span>
                data-&gt;OptMiss=<a class="hidden" href="pm_2_5_1.htm#ref12" title="Проверка вещественного числа на признак ошибки">DoubleErrorValue</a>; <span class="rem">// Пока не определено</span>
                data-&gt;AngleStep=-(MaxAngle-MinAngle)/<span class="const">5</span>;
                data-&gt;FirstStep=TRUE;
                data-&gt;Mode=ASMODE_SEARCHING;
                Ready=<span class="const">1</span>; <span class="rem">// Для передачи угла по связи</span>
                <span class="kw">break</span>;
              <span class="kw">case</span> ASMODE_FINISHED:
                <span class="rem">// Поиск уже проведен – показать результаты</span>
                <span id="light_ref31"><a class="hidden" href="rdsStopCalc.htm" title="А.5.2.42. rdsStopCalc &ndash; остановка расчета">rdsStopCalc</a></span>();
                data-&gt;ShowResults();
                <span class="kw">break</span>;
            }
          <span class="kw">break</span>;

        <span class="rem">// Сброс расчета</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_RESETCALC.htm" title="А.2.4.12. RDS_BFM_RESETCALC &ndash; сброс расчета">RDS_BFM_RESETCALC</a>:
          <span class="kw">if</span>(data-&gt;SelfReset)
            { <span class="rem">// Блок сам сбросил подсистему</span>
              data-&gt;SelfReset=FALSE; <span class="rem">// Очиска признака самосброса</span>
              <span class="rem">// Устанавливаем новый угол</span>
              Angle=data-&gt;AngleToSet;
              Ready=<span class="const">1</span>; <span class="rem">// Для передачи угла по связи</span>
            }
          <span class="kw">else</span> <span class="rem">// Расчет сброшен пользователем</span>
            data-&gt;Mode=ASMODE_READY;
          <span class="kw">break</span>;

        <span class="rem">// Один такт моделирования</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_MODEL.htm" title="А.2.4.9. RDS_BFM_MODEL &ndash; выполнение такта расчета">RDS_BFM_MODEL</a>:
          <span class="kw">if</span>(!Impact) <span class="rem">// Снаряд еще не долетел</span>
            <span class="kw">break</span>;

          <span class="rem">// Снаряд долетел – дальность полета в x</span>
          Impact=<span class="const">0</span>; <span class="rem">// Сбрасываем входной сигнал</span>
          <span class="kw">if</span>(data-&gt;Mode==ASMODE_FINALRUN)
            { <span class="rem">// Это был последний (демонстрационный) прогон</span>
              data-&gt;Mode=ASMODE_FINISHED;
              <a class="hidden" href="rdsStopCalc.htm" title="А.5.2.42. rdsStopCalc &ndash; остановка расчета">rdsStopCalc</a>();
              data-&gt;ShowResults();
              <span class="kw">break</span>;
            }
          <span class="rem">// Это – очередной прогон в поиске угла</span>
          delta=fabs(x-Distance); <span class="rem">// Промах при угле Angle</span>
          <span class="kw">if</span>(data-&gt;OptMiss==<a class="hidden" href="pm_2_5_1.htm#ref12" title="Проверка вещественного числа на признак ошибки">DoubleErrorValue</a> || <span class="rem">// Первый прогон</span>
             delta&lt;data-&gt;OptMiss) <span class="rem">// При новом угле попали точнее</span>
            { <span class="rem">// Запоминаем новый наилучший угол и промах</span>
              data-&gt;OptAngle=Angle;
              data-&gt;OptMiss=delta;
              <span class="rem">// Двигаемся дальше с тем же шагом</span>
              data-&gt;AngleToSet=Angle+data-&gt;AngleStep;
              <span class="rem">// Новый расчет будет уже не первым с этим шагом</span>
              data-&gt;FirstStep=FALSE;
            }
          <span class="kw">else</span> <span class="rem">// Промах увеличился или не изменился</span>
            { <span class="kw">if</span>(data-&gt;FirstStep)
                { <span class="rem">// Мы только что провели первый расчет с новым</span>
                  <span class="rem">// значением шага. Промах увеличился – попробуем</span>
                  <span class="rem">// двигаться в обратном направлении с тем же</span>
                  <span class="rem">// шагом</span>
                  data-&gt;AngleStep=-data-&gt;AngleStep;
                  <span class="rem">// Новый расчет будет уже не первым с этим шагом</span>
                  data-&gt;FirstStep=FALSE;
                }
              <span class="kw">else</span>
                { <span class="rem">// Это был не первый расчет с данным значением</span>
                  <span class="rem">// шага. Мы либо сделали несколько шагов в этом</span>
                  <span class="rem">// направлении, либо уже пробовали двигаться</span>
                  <span class="rem">// в обратном. Теперь нужно уменьшить шаг вдвое,</span>
                  <span class="rem">//  если это возможно.</span>
                  <span class="kw">if</span>(fabs(data-&gt;AngleStep)&lt;=Accuracy)
                    { <span class="rem">// Достигли минимального шага по углу -</span>
                      <span class="rem">// выполняем последний расчет</span>
                      data-&gt;Mode=ASMODE_FINALRUN;
                      <span class="rem">// Устанавливаем найденный угол</span>
                      data-&gt;AngleToSet=data-&gt;OptAngle;
                      data-&gt;SelfReset=TRUE; <span class="rem">// Флаг самосброса</span>
                      <span class="rem">// Сбрасываем родительскую подсистему</span>
                      <span id="light_ref32"><a class="hidden" href="rdsResetSystemState.htm" title="А.5.7.3. rdsResetSystemState &ndash; сбросить состояние блока или подсистемы">rdsResetSystemState</a></span>(BlockData-&gt;Parent);
                      <span class="kw">break</span>;
                    }
                   <span class="rem">// Минимальный шаг еще не достигнут</span>
                   <span class="rem">// Дальше будем двигаться от наилучшего на данный</span>
                   <span class="rem">// момент угла с меньшим шагом</span>
                   data-&gt;AngleStep=data-&gt;AngleStep/<span class="const">2.0</span>;
                   <span class="rem">// Не даем шагу стать меньше минимального</span>
                   <span class="kw">if</span>(fabs(data-&gt;AngleStep)&lt;Accuracy)
                     data-&gt;AngleStep=(data-&gt;AngleStep&lt;<span class="const">0</span>)?
                                          (-Accuracy):Accuracy;
                   <span class="rem">// Новый расчет будет первым с этим значением шага</span>
                   data-&gt;FirstStep=TRUE;
                }
              <span class="rem">// Новый угол, который установиться после сброса</span>
              data-&gt;AngleToSet=data-&gt;OptAngle+data-&gt;AngleStep;
            }
          <span class="rem">// Ограничиваем угол и привязываем его к точности</span>
          data-&gt;AngleToSet=data-&gt;FixAngle(
              data-&gt;AngleToSet,MinAngle,MaxAngle,Accuracy);
          <span class="rem">// Сбрасываем родительскую подсистему</span>
          data-&gt;SelfReset=TRUE; <span class="rem">// Флаг самосброса</span>
          <a class="hidden" href="rdsResetSystemState.htm" title="А.5.7.3. rdsResetSystemState &ndash; сбросить состояние блока или подсистемы">rdsResetSystemState</a>(BlockData-&gt;Parent);
          <span class="kw">break</span>;
      }
    <span class="kw">return</span> <a class="hidden" href="app_a_2_1.htm#ref2" title="Возврат RDS_BFR_DONE">RDS_BFR_DONE</a>;
  <span class="rem">// Отмена макроопределений</span>
  <span class="preproc">#undef Angle</span>
  <span class="preproc">#undef Impact</span>
  <span class="preproc">#undef x</span>
  <span class="preproc">#undef Distance</span>
  <span class="preproc">#undef Accuracy</span>
  <span class="preproc">#undef MaxAngle</span>
  <span class="preproc">#undef MinAngle</span>
  <span class="preproc">#undef Ready</span>
  <span class="preproc">#undef Start</span>
  <span class="preproc">#undef pStart</span>
  }
  <span class="rem">//=========================================</span></pre>

<p>Первые четыре реакции модели не содержат ничего специфического: при инициализации блока создается
личная область данных, при очистке эта область уничтожается, проверка типов переменных ничем не
отличается от такой же реакции во всех остальных моделях, для настройки параметров блока, как
и в предыдущей модели, используется универсальная функция <span class="cpp"><a href="#ref8" title="SetupDoubleVars">SetupDoubleVars</a></span>
(массив параметров <span class="cpp">setup</span> описан в начале функции модели, сразу после
макроопределений для переменных).</p>

<p>Реакция модели на запуск расчета (<span class="cpp"><a href="RDS_BFM_STARTCALC.htm" title="А.2.4.14. RDS_BFM_STARTCALC &ndash; запуск расчета">RDS_BFM_STARTCALC</a></span>) зависит от того,
в каком режиме находится блок. Если поиск угла еще не проводился, то есть поле
<span class="cpp">Mode</span> класса личной области данных имеет значение
<span class="cpp">ASMODE_READY</span>, необходимо установить начальное значение угла, с
которого мы начнем поиск (выбираем в качестве начального максимально возможный угол возвышения, то есть
<span class="cpp">MaxAngle</span>) и начальный шаг изменения угла (выбираем одну пятую всего диапазона,
при этом мы будем уменьшать угол от максимального, поэтому шаг делается отрицательным). Полю
<span class="cpp">OptMiss</span>, в котором должно храниться наименьшее на данный момент значение промаха,
мы присваиваем специальное значение &ndash; индикатор ошибки из глобальной переменной
<span class="cpp"><a href="pm_2_5_1.htm#ref12" title="Проверка вещественного числа на признак ошибки">DoubleErrorValue</a></span>, поскольку мы еще не провели
ни одного расчета, и у нас пока нет ни наилучшего на данный момент значения угла,
ни минимального значения промаха. Полю <span class="cpp">FirstStep</span> присваивается значение
<span class="cpp">TRUE</span> (это самый первый расчет с таким значением шага), и блок переводится в режим
<span class="cpp">ASMODE_SEARCHING</span>: алгоритм поиска угла начал свою работу. Затем взводится сигнал
<span class="cpp"><a href="um_1_4.htm#ref27" title="Сигнал готовности блока">Ready</a></span>, чтобы установленное значение угла
<span class="cpp">Angle</span> передалось по связям, и реакция на этом завершается.</p>

<p>Если поиск угла уже завершен, в поле <span class="cpp">Mode</span> будет находиться константа
<span class="cpp">ASMODE_FINISHED</span>. В этом случае запущенный расчет принудительно останавливается,
и вызывается функция <span class="cpp">ShowResults</span>, чтобы показать пользователю найденное значение
угла и соответствующий ему промах. Во всех остальных случаях модель никак не
реагирует на запуск расчета.</p>

<p>Следует отметить, что реакция на запуск расчета будет вызываться чаще, чем может показаться
на первый взгляд. Дело в том, что наша модель будет время от времени сбрасывать состояние подсистемы
при работающем расчете. RDS технически не может выполнить сброс, пока расчет работает,
поэтому при вызове сервисной функции <span class="cpp"><a href="rdsResetSystemState.htm" title="А.5.7.3. rdsResetSystemState &ndash; сбросить состояние блока или подсистемы">rdsResetSystemState</a></span>, которой мы пользуемся
для сброса, расчет сначала останавливается, затем состояние подсистемы сбрасывается, и расчет запускается снова.
В результате модель нашего блока, как и модели всех остальных блоков схемы, будет вызываться в режимах
<span class="cpp"><a href="RDS_BFM_STOPCALC.htm" title="А.2.4.15. RDS_BFM_STOPCALC &ndash; остановка расчета">RDS_BFM_STOPCALC</a></span> и <span class="cpp"><a href="RDS_BFM_STARTCALC.htm" title="А.2.4.14. RDS_BFM_STARTCALC &ndash; запуск расчета">RDS_BFM_STARTCALC</a></span> не только при остановке
и запуске расчета пользователем, но и при каждом сбросе состояния подсистемы. Тем не менее,
на работу нашей модели этот факт никак не повлияет.</p>

<p>При сбросе расчета (режим <span class="cpp"><a href="RDS_BFM_RESETCALC.htm" title="А.2.4.12. RDS_BFM_RESETCALC &ndash; сброс расчета">RDS_BFM_RESETCALC</a></span>) модель прежде всего проверяет, сам
ли блок сбросил состояние подсистемы, или это сделал кто-то другой, то есть пользователь или какой-то
другой блок. Для этого проверяется значение поля <span class="cpp">SelfReset</span>: мы договорились, что
перед сбросом состояния подсистемы модель будет присваивать этому полю значение <span class="cpp">TRUE</span>.
Таким образом, если значение <span class="cpp">SelfReset</span> истинно, то блок сам сбросил расчет
в процессе поиска угла, и модель устанавливает на выходе блока <span class="cpp">Angle</span> новое значение
из поля <span class="cpp">AngleToSet</span>. Кроме этого, <span class="cpp">SelfReset</span> снова сбрасывается в
<span class="cpp">FALSE</span> до следующего программного сброса, и взводится сигнал
<span class="cpp">Ready</span> для передачи выхода <span class="cpp">Angle</span> по связям. Если же поле
<span class="cpp">SelfReset</span> имело значение <span class="cpp">FALSE</span>, блок переводится в
состояние готовности к поиску <span class="cpp">ASMODE_READY</span>. Таким образом, если пользователь сбросит,
а затем запустит расчет, поиск начнется заново.</p>

<p>Основная работа алгоритма поиска выполняется в реакции на такт расчета
<span class="cpp"><a href="RDS_BFM_MODEL.htm" title="А.2.4.9. RDS_BFM_MODEL &ndash; выполнение такта расчета">RDS_BFM_MODEL</a></span>. Прежде всего проверяется значение сигнального входа
<span class="cpp">Impact</span>, на котором должна появиться единица, как только снаряд упадет на землю.
Если <span class="cpp">Impact</span> имеет нулевое значение, модель немедленно завершается: снаряд еще в
полете, и дальность, соответствующая текущему углу возвышения, пока неизвестна. Как только сигнал
<span class="cpp">Impact</span> станет равным 1, модель сбрасывает его (любая модель должна самостоятельно
сбрасывать все свои входные сигналы), а дальше действует в зависимости от текущего режима работы блока.
При запущенном расчете блок может находиться в одном из двух состояний:
<span class="cpp">ASMODE_SEARCHING</span> в процессе поиска угла и <span class="cpp">ASMODE_FINALRUN</span> при
последнем, &laquo;демонстрационном&raquo;, расчете с найденным углом возвышения, который выполняется только
для того, чтобы показать пользователю графики и значения, соответствующие именно этому, наилучшему,
значению угла. Если поле <span class="cpp">Mode</span> имеет значение
<span class="cpp">ASMODE_FINALRUN</span>, значит, только что был проведен последний расчет. При
этом блок переводится в состояние <span class="cpp">ASMODE_FINISHED</span> (поиск окончен), расчет
останавливается, и вызывается функция <span class="cpp">ShowResults</span> для демонстрации результатов
пользователю. В противном случае поиск еще не завершен &ndash; нужно вычислять новое значение промаха,
соответствующее текущему углу возвышения <span class="cpp">Angle</span>, и сравнивать его с запомненным.</p>

<p>Значение промаха <span class="cpp">delta</span> вычисляется как модуль разности текущей дальности
полета, которая считывается с входа <span class="cpp">x</span>, и заданной в настройках блока дальности
<span class="cpp">Distance</span>. Этот промах нужно сравнить с наименьшим на данный момент промахом
<span class="cpp">OptMiss</span>. После самого первого расчета, когда у нас еще нет наименьшего запомненного
промаха, в <span class="cpp"></span> будет находится значение-индикатор ошибки
<span class="cpp"><a class="hidden" href="pm_2_5_1.htm#ref12" title="Проверка вещественного числа на признак ошибки">DoubleErrorValue</a></span>. В этом случае наилучшим на
данный момент нужно считать текущее значение угла, поскольку никакого другого у нас еще нет. Текущее значение
угла нужно считать наилучшим и в том случае, если с углом <span class="cpp">Angle</span> промах получился
меньше запомненного, то есть <span class="cpp">delta&lt;data-&gt;OptMiss</span>. Таким образом, в
обоих этих случаях полю <span class="cpp">OptAngle</span> присваивается текущее значение угла
<span class="cpp">Angle</span>, а полю <span class="cpp">OptMiss</span> &ndash; текущий промах
<span class="cpp">delta</span>: текущее значение угла теперь будет наилучшим на данный момент. Раз
изменение угла с текущим шагом улучшило ситуацию, мы продолжаем двигаться в том же направлении с тем же шагом:
полю <span class="cpp">AngleToSet</span>, откуда будет взято новое значение угла после программного сброса,
присваивается сумма текущего значения <span class="cpp">Angle</span> и текущего шага <span class="cpp">AngleStep</span>.
Затем сбрасывается логическое поле <span class="cpp">FirstStep</span>: это будет уже не первый шаг
в данном направлении.</p>

<p>Если же значение промаха <span class="cpp">delta</span> получилось большим
<span class="cpp">OptMiss</span>, то есть сделанный шаг по углу привел к ухудшению ситуации, нам нужно
либо изменить знак шага (если мы увеличивали угол &ndash; начать уменьшать его, если уменьшали &ndash;
начать увеличивать), либо, если мы уже попробовали оба знака, уменьшить шаг вдвое. Если значение поля
<span class="cpp">FirstStep</span> истинно, значит, мы еще не пробовали менять знак шага &ndash;
в этом случае знак <span class="cpp">AngleStep</span> меняется на противоположный, а
<span class="cpp">FirstStep</span> сбрасывается, поскольку это будет уже не первая попытка изменить угол
с этим абсолютным значением шага. В противном случае нужно уменьшать шаг, но сначала нужно проверить,
не достигли ли мы уже заданной точности по углу.</p>

<p>Если текущий шаг <span class="cpp">AngleStep</span> по модулю меньше или равен точности
<span class="cpp">Accuracy</span>, значит, уменьшать его дальше невозможно. В этом случае блок переводится в
режим <span class="cpp">ASMODE_FINALRUN</span>, устанавливается наилучшее на данный момент значение
угла возвышения, и проводится последний расчет, чтобы показать пользователю правильные графики. Для
этого полю <span class="cpp">SelfReset</span> присваивается значение
<span class="cpp">TRUE</span> (сейчас блок будет сам сбрасывать расчет) и вызывается функция
<span class="cpp"><a class="hidden" href="rdsResetSystemState.htm" title="А.5.7.3. rdsResetSystemState &ndash; сбросить состояние блока или подсистемы">rdsResetSystemState</a></span> для
<a href="pm_1_2.htm#ref7" title="Родительская подсистема">родительской подсистемы</a>
данного блока, то есть для подсистемы, в которой он
находится вместе с блоком расчета траектории. Затем функция модели
завершается.</p>

<p>Если заданная точность еще не достигнута, шаг уменьшается в два раза и ограничивается снизу значением
точности по углу <span class="cpp">Accuracy</span> (мы не можем устанавливать угол точнее). Затем полю
<span class="cpp">FirstStep</span> присваивается значение <span class="cpp">TRUE</span>, поскольку
это будет первый расчет с новым значением шага &ndash; если новый шаг ухудшит ситуацию, нам нужно
будет менять знак шага, а не его абсолютное значение.</p>

<p>Наконец, когда все ситуации, возникающие при увеличении промаха, рассмотрены, в поле
<span class="cpp">AngleToSet</span> записывается новое значение угла, которое нужно будет установить после
сброса, то есть наилучший на данный момент угол <span class="cpp">OptAngle</span>, к которому прибавлено новое
значение шага <span class="cpp">AngleStep</span> (оно либо поменяло знак, либо уменьшилось вдвое).</p>

<p>В самом конце реакции на такт расчета новое значение угла возвышения <span class="cpp">AngleToSet</span>
&laquo;пропускается&raquo; через функцию <span class="cpp">FixAngle</span>, которая ограничит его диапазоном
<span class="cpp">MinAngle</span>&hellip;<span class="cpp">MaxAngle</span> и округлит до точности
<span class="cpp">Accuracy</span>. Затем родительская подсистема сбрасывается в начальное состояние:
реагируя на сброс, как было описано выше, модель нашего блока подаст на выход
<span class="cpp">Angle</span> новое значение <span class="cpp">AngleToSet</span>, и расчет повторится снова.</p>

<p>Для тестирования созданной модели <span class="cpp">ArtSearch</span> нужно поместить в одну подсистему
блок с этой моделью и блок, моделирующий полет снаряда, и собрать схему, подобную изображенной
на <a href="#pic8" title="Схема поиска угла возвышения для заданной дальности">рис.&nbsp;101</a>.</p>

<div class="pic"><div class="container" id="pic8">
<img src="../img/Ballistics2.png" width="907" height="449" alt="Схема поиска угла возвышения для заданной дальности" />
<p id="light_pic8">Рис.&nbsp;101. Схема поиска угла возвышения для заданной дальности</p>
</div></div>


<div class="picright"><div class="container" id="pic9">
<img src="../img/Ballistics2_setup.png" width="310" height="203" alt="Настройки блока поиска угла" />
<p id="light_pic9">Рис.&nbsp;102. Настройки блока поиска угла</p>
</div></div>


<p>В этой схеме выход &laquo;<span class="rdsvar">Angle</span>&raquo; блока поиска угла подается на одноименный вход блока
расчета траектории не напрямую, а через поле ввода &ndash; так удобнее наблюдать за изменяющимся в процессе
поиска значением угла. Перед запуском расчета нужно настроить параметры блока поиска
(<a href="#pic9" title="Настройки блока поиска угла">рис.&nbsp;102</a>) и блока расчета траектории
(в данном случае начальная скорость снаряда установлена в 200 м/с, а все остальные параметры
блока соответствуют <a href="#pic7" title="Окно настройки блока расчета траектории снаряда">рис.&nbsp;100</a>). В процессе расчета
график траектории будет постоянно изменяться, пока, в конце концов, блок поиска не проведет последний
расчет в режиме <span class="cpp">ASMODE_FINALRUN</span> и не выведет сообщение об окончании поиска.</p>

<p>Для каждой начальной скорости снаряда существует максимальная дальность полета, поэтому для
дальностей, больших максимальной, невозможно подобрать угол возвышения, при котором промах станет
близким к нулю. Наш блок в этом случае найдет такой угол, при котором промах будет наименьшим из всех
возможных, то есть угол, соответствующий максимальной дальности полета. Для большинства дальностей,
меньших максимально возможной, на самом деле существует два значения угла возвышения, при которых промах
близок к нулю: в одну и ту же точку можно попасть как настильной траекторией (при малом угле возвышения), так
и навесной (при большом угле). Наш блок найдет только один из этих углов, причем нельзя заранее сказать,
какой именно. Это &ndash; недостаток данной реализации алгоритма поиска, но мы не будем его исправлять,
чтобы не усложнять пример: со своей задачей он, в принципе, справляется.</p>

<p>В рассмотренном примере очень важно расположить блок поиска угла в одной подсистеме со всеми блоками,
ответственными за расчет (в нашем случае это блок моделирования полета снаряда и планировщик вычислений).
Это связано с тем, что блок поиска угла сбрасывает свою родительскую подсистему со всеми подсистемами,
вложенными в нее, поэтому, чтобы можно было сбрасывать расчет траектории и начинать его заново для
другого значения угла возвышения, все блоки, участвующие в этом расчете, должны находиться в пределах
действия этого сброса. Если мы вставим схему на <a href="#pic8" title="Схема поиска угла возвышения для заданной дальности">рис.&nbsp;101</a> в
подсистему внутри другой подсистемы, &laquo;внешняя&raquo; подсистема в процессе работы алгоритма
сбрасываться не будет. Этим можно воспользоваться, например, для построения графика зависимости дальности
полета снаряда от угла возвышения. Для построения такого графика нужно создать блок, который будет изменять
угол с заданным шагом, дожидаться конца расчета траектории и сбрасывать расчет. Этот блок нужно поместить
в подсистему вместе с блоком расчета траектории, а сам график вместе с обслуживающими его блоками
разместить снаружи этой подсистемы. При этом при сбросе внутренней подсистемы график сбрасываться не
будет, и сможет, точка за точкой, построить кривую зависимости дальности от угла.</p>

<p>Прежде всего, нужно создать модель блока, который будет менять угол с заданным шагом и
сбрасывать состояние подсистемы после каждого изменения. Эта модель будет гораздо проще модели
блока поиска угла <span class="cpp">ArtSearch</span> &ndash; здесь не нужно ни вычислять промах,
ни изменять шаг по углу. Однако, в логике работы этого блока есть свои особенности, на которых
нужно остановиться подробнее.</p>

<p>Блок поиска угла, рассмотренный ранее, получал от блока расчета траектории сигнал
&laquo;<span class="rdsvar">Impact</span>&raquo; вместе с новым значением дальности, вычислял промах и тут же сбрасывал подсистему
в начальное состояние, начиная новый расчет. В новом блоке, который будет менять угол для построения
графика, сбрасывать подсистему сразу же при получении сигнала &laquo;<span class="rdsvar">Impact</span>&raquo; нельзя. Дело в том,
что значение дальности полета здесь будет передаваться наружу подсистемы, в график, поэтому расчет можно сбрасывать
только тогда, когда это значение будет принято и обработано блоком графика. Мы не знаем заранее, когда
это случится: между подсистемой и графиком может оказаться длинная цепочка из блоков, которые как-то
обрабатывают это значение. Фактически, нам нужно задержать сигнал &laquo;<span class="rdsvar">Impact</span>&raquo;, сформированный блоком
расчета траектории, на некоторое, заранее неизвестное, число тактов. Если этого не сделать, подсистема вместе
со всеми своими переменными, включая вычисленную дальность полета, может сброситься раньше, чем график успеет
считать со своего входа очередное значение дальности. Конечно, можно подсчитать число простых блоков во
всей схеме, и задержать сброс подсистемы на такое же число тактов, тогда график точно успеет сработать. Однако,
есть более простое решение &ndash; можно заставить блок изменения угла ждать не только окончания расчета
траектории, но и готовности графика и остальных блоков, находящихся снаружи подсистемы. Для этого нужно
предусмотреть в блоке два сигнальных входа. На один из них будет подаваться сигнал окончания расчета траектории
&laquo;<span class="rdsvar">Impact</span>&raquo;, а на другой &ndash; сигнал готовности графика снаружи подсистемы. Только когда оба
этих сигнала станут равными единице, блок сбросит подсистему. Формирование этого сигнала готовности снаружи
подсистемы &ndash; отдельный вопрос, и мы займемся им, когда будем создавать схему. А пока можно заняться
моделью блока изменения угла, который будет иметь следующую структуру переменных:</p>

<div class="tablecenter"><div class="tcont">
<table>

  <tr>
    <th>Смещение</th>
    <th>Имя</th>
    <th>Тип</th>
    <th>Размер</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
    <th>Назначение</th>
    <th>Номер</th>
  </tr><tr><td class="center">0</td>
<td class="vcenter">Start</td>
<td class="center">Сигнал</td>
<td class="center">1</td>
<td class="center">Вход</td>
<td class="center">&checkmark;</td>
<td class="center">0</td>
<td>Стандартный сигнал запуска</td><td class="center">0</td>
</tr>
<tr><td class="center">1</td>
<td class="vcenter">Ready</td>
<td class="center">Сигнал</td>
<td class="center">1</td>
<td class="center">Выход</td>
<td></td>
<td class="center">0</td>
<td>Стандартный сигнал готовности</td><td class="center">1</td>
</tr>
<tr><td class="center">2</td>
<td class="vcenter">MinAngle</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Внутренняя</td>
<td></td>
<td class="center">0</td>
<td>Минимально возможный угол возвышения, градусов</td><td class="center">2</td>
</tr>
<tr><td class="center">10</td>
<td class="vcenter">MaxAngle</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Внутренняя</td>
<td></td>
<td class="center">90</td>
<td>Максимально возможный угол возвышения, градусов</td><td class="center">3</td>
</tr>
<tr><td class="center">18</td>
<td class="vcenter">Accuracy</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Внутренняя</td>
<td></td>
<td class="center">0.1</td>
<td>Шаг изменения угла, градусов</td><td class="center">4</td>
</tr>
<tr><td class="center">26</td>
<td class="vcenter">Impact</td>
<td class="center">Сигнал</td>
<td class="center">1</td>
<td class="center">Вход</td>
<td class="center">&checkmark;</td>
<td class="center">0</td>
<td>Сигнал о падении снаряда (от блока расчета траектории)</td><td class="center">5</td>
</tr>
<tr><td class="center">27</td>
<td class="vcenter">GraphReady</td>
<td class="center">Сигнал</td>
<td class="center">1</td>
<td class="center">Вход</td>
<td class="center">&checkmark;</td>
<td class="center">0</td>
<td>Сигнал готовности графика и других блоков снаружи подсистемы</td><td class="center">6</td>
</tr>
<tr><td class="center">28</td>
<td class="vcenter">Angle</td>
<td class="center">double</td>
<td class="center">8</td>
<td class="center">Выход</td>
<td></td>
<td class="center">0</td>
<td>Текущий угол возвышения, градусов (к блоку расчета траектории)</td><td class="center">7</td>
</tr>


</table>
</div></div>

<p>Сама модель будет такой:</p>

<pre class="cpp">  <span class="rem">//============================================</span>
  <span class="rem">// Блок перебора углов для построения графика</span>
  <span class="rem">// зависимости дальности от угла</span>
  <span class="rem">//============================================</span>
  <span class="rem">// Личная область данных блока</span>
  <span class="kw">class</span> TArtWalkData
  { <span class="kw">public</span>:
      <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> SelfReset;    <span class="rem">// Блок сам сбросил подсистему</span>
      <span class="kw">double</span> AngleToSet; <span class="rem">// Угол, который нужно установить</span>
                         <span class="rem">// после сброса</span>
      <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> FirstStart;   <span class="rem">// Начать построение графика с начала</span>

      <span class="rem">// Конструктор класса</span>
      TArtWalkData(<span class="kw">void</span>)
        { SelfReset=FALSE; FirstStart=TRUE; };
  };
  <span class="rem">//=========================================</span>
  <span class="rem">// Функция модели блока</span>
  <span class="kw">extern</span> <span class="str">"C"</span> <span class="kw">__declspec</span>(<span class="kw">dllexport</span>)
      <span class="kw">int</span> <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> ArtWalk(<span class="kw">int</span> CallMode,
                          <a class="hidden" href="RDS_BLOCKDATA.htm#ref2" title="Указатель на RDS_BLOCKDATA">RDS_PBLOCKDATA</a> BlockData,
                          <a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> ExtParam)
  { TArtWalkData *data=(TArtWalkData*)(BlockData-&gt;BlockData);
  <span class="rem">// </span><a class="hidden" href="pm_2_5_1.htm#light_ref9" title="Макросы для статических переменных блока"><span class="rem">Макроопределения для статических переменных</span></a>
  <span class="preproc">#define pStart     ((char *)(BlockData-&gt;VarData))</span>
  <span class="preproc">#define Start      (*((char *)(pStart)))      </span><span class="rem">// 0</span>
  <span class="preproc">#define Ready      (*((char *)(pStart+1)))    </span><span class="rem">// 1</span>
  <span class="preproc">#define MinAngle   (*((double *)(pStart+2)))  </span><span class="rem">// 2</span>
  <span class="preproc">#define MaxAngle   (*((double *)(pStart+10))) </span><span class="rem">// 3</span>
  <span class="preproc">#define Accuracy   (*((double *)(pStart+18))) </span><span class="rem">// 4</span>
  <span class="preproc">#define Impact     (*((char *)(pStart+26)))   </span><span class="rem">// 5</span>
  <span class="preproc">#define GraphReady (*((char *)(pStart+27)))   </span><span class="rem">// 6</span>
  <span class="preproc">#define Angle      (*((double *)(pStart+28))) </span><span class="rem">// 7</span>
    <span class="rem">// Массив описания параметров для универсальной функции настройки</span>
    <span class="kw">static</span> <span class="kw">char</span> *setup[]={
      <span class="str">"2Минимальный угол, град."</span>,
      <span class="str">"3Маскимальный угол, град."</span>,
      <span class="str">"4Шаг по углу, град."</span>,
      NULL};

    <span class="kw">switch</span>(CallMode)
      { <span class="rem">// Инициализация</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_INIT.htm" title="А.2.4.7. RDS_BFM_INIT &ndash; инициализация блока">RDS_BFM_INIT</a>:
          BlockData-&gt;BlockData=<span class="kw">new</span> TArtWalkData();
          <span class="kw">break</span>;
        <span class="rem">// Очистка</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_CLEANUP.htm" title="А.2.4.3. RDS_BFM_CLEANUP &ndash; очистка данных блока">RDS_BFM_CLEANUP</a>:
          <span class="kw">delete</span> data;
          <span class="kw">break</span>;
        <span class="rem">// Проверка типов переменных</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_VARCHECK.htm" title="А.2.4.18. RDS_BFM_VARCHECK &ndash; проверка допустимости структуры статических переменных блока">RDS_BFM_VARCHECK</a>:
          <span class="kw">return</span> strcmp((<span class="kw">char</span>*)ExtParam,<span class="str">"{SSDDDSSD}"</span>)?
            <a class="hidden" href="RDS_BFM_VARCHECK.htm#light_ref3" title="Возврат RDS_BFR_BADVARSMSG">RDS_BFR_BADVARSMSG</a>:<a class="hidden" href="app_a_2_1.htm#ref2" title="Возврат RDS_BFR_DONE">RDS_BFR_DONE</a>;
        <span class="rem">// Вызов функции настройки</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_SETUP.htm" title="А.2.6.13. RDS_BFM_SETUP &ndash; вызов функции настройки блока">RDS_BFM_SETUP</a>:
          <span class="kw">return</span> <a class="hidden" href="#ref8" title="SetupDoubleVars">SetupDoubleVars</a>(BlockData-&gt;Block,
              <span class="str">"Перебор углов"</span>,setup);

        <span class="rem">// Запуск расчета</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_STARTCALC.htm" title="А.2.4.14. RDS_BFM_STARTCALC &ndash; запуск расчета">RDS_BFM_STARTCALC</a>:
          <span class="kw">if</span>(data-&gt;FirstStart)
            { <span class="rem">// Самый первый запуск – начало графика</span>
              Angle=MinAngle; <span class="rem">// Начинаем с начала диапазона</span>
              data-&gt;FirstStart=FALSE;
              Impact=GraphReady=<span class="const">0</span>;
              Ready=<span class="const">1</span>; <span class="rem">// Для передачи по связям</span>
            }
          <span class="kw">break</span>;

        <span class="rem">// Сброс расчета</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_RESETCALC.htm" title="А.2.4.12. RDS_BFM_RESETCALC &ndash; сброс расчета">RDS_BFM_RESETCALC</a>:
          <span class="kw">if</span>(data-&gt;SelfReset)
            { <span class="rem">// Блок сам сбросил подсистему</span>
              data-&gt;SelfReset=FALSE;
              <span class="rem">// Устанавливаем новый угол</span>
              Angle=data-&gt;AngleToSet;
              Ready=<span class="const">1</span>; <span class="rem">// Для передачи по связям</span>
            }
          <span class="kw">else</span> <span class="rem">// Расчет сброшен кем=то еще</span>
            data-&gt;FirstStart=TRUE;
          <span class="kw">break</span>;

        <span class="rem">// Один такт расчета</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_MODEL.htm" title="А.2.4.9. RDS_BFM_MODEL &ndash; выполнение такта расчета">RDS_BFM_MODEL</a>:
          <span class="kw">if</span>(!Impact) <span class="rem">// Снаряд не долетел</span>
            { <span class="rem">// Сбрасываем сигнал готовности графика</span>
              GraphReady=<span class="const">0</span>;
              <span class="kw">break</span>;
            }
          <span class="rem">// Снаряд долетел – проверяем готовность графика</span>
          <span class="kw">if</span>(!GraphReady)
            <span class="kw">break</span>;
          <span class="rem">// График готов</span>
          Impact=GraphReady=<span class="const">0</span>; <span class="rem">// Сбрасываем оба сигнала</span>
          <span class="kw">if</span>(Angle&gt;=MaxAngle)
            { <span class="rem">// Достигли конца диапазона – прекращаем расчет</span>
              <a class="hidden" href="rdsStopCalc.htm" title="А.5.2.42. rdsStopCalc &ndash; остановка расчета">rdsStopCalc</a>();
              <span class="kw">break</span>;
            }
          <span class="rem">// Увеличиваем угол на один шаг</span>
          data-&gt;AngleToSet=Angle+Accuracy;
          <span class="kw">if</span>(data-&gt;AngleToSet&gt;MaxAngle) <span class="rem">// Не допускаем выход</span>
            data-&gt;AngleToSet=MaxAngle; <span class="rem">// за MaxAngle</span>
          data-&gt;SelfReset=TRUE; <span class="rem">// Сейчас блок сам сбросит подсистему</span>
          <a class="hidden" href="rdsResetSystemState.htm" title="А.5.7.3. rdsResetSystemState &ndash; сбросить состояние блока или подсистемы">rdsResetSystemState</a>(BlockData-&gt;Parent);
          <span class="kw">break</span>;
      }
    <span class="kw">return</span> <a class="hidden" href="app_a_2_1.htm#ref2" title="Возврат RDS_BFR_DONE">RDS_BFR_DONE</a>;
  <span class="rem">// Отмена макроопределений</span>
  <span class="preproc">#undef Angle</span>
  <span class="preproc">#undef GraphReady</span>
  <span class="preproc">#undef Impact</span>
  <span class="preproc">#undef Accuracy</span>
  <span class="preproc">#undef MaxAngle</span>
  <span class="preproc">#undef MinAngle</span>
  <span class="preproc">#undef Ready</span>
  <span class="preproc">#undef Start</span>
  <span class="preproc">#undef pStart</span>
  }
  <span class="rem">//=========================================</span></pre>

<p>Не будем подробно останавливаться на личной области данных этого блока: фактически,
она представляет собой урезанный вариант класса <span class="cpp">TArtSearchData</span>, в котором остался
только флаг самостоятельного сброса <span class="cpp">SelfReset</span> и поле
<span class="cpp">AngleToSet</span> для хранения значения угла, которое нужно установить после сброса.
Вместо целого поля для режима работы блока в этом классе используется логическое
<span class="cpp">FirstStart</span> &ndash; блок может находиться всего в двух режимах: либо он
ничего не делает в данный момент и готов к работе (<span class="cpp">FirstStart</span> истинно), либо
он работает, увеличивая угол шаг за шагом (<span class="cpp">FirstStart</span> ложно).</p>

<p>Из всех реакций этой модели подробно рассмотрим только три:
<span class="cpp"><a class="hidden" href="RDS_BFM_STARTCALC.htm" title="А.2.4.14. RDS_BFM_STARTCALC &ndash; запуск расчета">RDS_BFM_STARTCALC</a></span>, <span class="cpp"><a class="hidden" href="RDS_BFM_RESETCALC.htm" title="А.2.4.12. RDS_BFM_RESETCALC &ndash; сброс расчета">RDS_BFM_RESETCALC</a></span> и
<span class="cpp"><a class="hidden" href="RDS_BFM_MODEL.htm" title="А.2.4.9. RDS_BFM_MODEL &ndash; выполнение такта расчета">RDS_BFM_MODEL</a></span>, поскольку остальные устроены очевидным образом и похожи
на реакции других моделей, уже рассматривавшихся раньше. В реакции на запуск расчета
<span class="cpp"><a class="hidden" href="RDS_BFM_STARTCALC.htm" title="А.2.4.14. RDS_BFM_STARTCALC &ndash; запуск расчета">RDS_BFM_STARTCALC</a></span> модель проверяет состояние блока, и, если он до
сих пор ничего не делал, инициализирует выход <span class="cpp">Angle</span> началом диапазона углов
<span class="cpp">MinAngle</span>, сбрасывает флаг <span class="cpp">FirstStart</span> и входные сигналы
<span class="cpp">Impact</span> и <span class="cpp">GraphReady</span> &ndash; теперь блок установил на своем
выходе самое первое значение угла, для которого нужно вычислить дальность, и готов к приему сигнала конца
расчета траектории <span class="cpp">Impact</span> и сигнала готовности графика <span class="cpp">GraphReady</span>.
После этого взводится выходной сигнал <span class="cpp">Ready</span>, чтобы значение
<span class="cpp">Angle</span> передалось по связям в блок расчета траектории.</p>

<p>Реакция на сброс расчета <span class="cpp"><a class="hidden" href="RDS_BFM_RESETCALC.htm" title="А.2.4.12. RDS_BFM_RESETCALC &ndash; сброс расчета">RDS_BFM_RESETCALC</a></span>, в целом, похожа на реакцию
предыдущей модели: если блок сам сбросил подсистему, на выход выдается новое значение угла из поля
<span class="cpp">AngleToSet</span>, если нет &ndash; переменной
<span class="cpp">FirstStart</span> присваивается значение <span class="cpp">TRUE</span>, при следующем
запуске расчета это приведет к тому, что блок снова начнет перебирать углы от начала диапазона
с заданным шагом.</p>

<p>В реакции на такт расчета <span class="cpp"><a class="hidden" href="RDS_BFM_MODEL.htm" title="А.2.4.9. RDS_BFM_MODEL &ndash; выполнение такта расчета">RDS_BFM_MODEL</a></span> прежде всего проверяется,
закончен ли расчет траектории, то есть взведен ли сигнал <span class="cpp">Impact</span>. Если он сброшен,
значит, снаряд еще летит, и нас не интересует сигнал готовности графика <span class="cpp">GraphReady</span>
(он сбрасывается), и функция модели на этом завершается. Если же сигнал <span class="cpp">Impact</span> взведен,
нужно ждать готовности графика: проверяется сигнал <span class="cpp">GraphReady</span>, и, если он сброшен,
модель завершается. Если оба сигнала взведены, значит, и расчет траектории уже закончен, и график уже
считал нужные ему значения, в этом случае работа функции модели будет продолжена.</p>

<p>Может возникнуть вопрос: если нам нужно продолжать работу модели и изменять угол только
после поступления обоих сигналов <span class="cpp">Impact</span> и <span class="cpp">GraphReady</span>,
почему бы не проверить эти сигналы одновременно, написав проверку так:</p>

<pre class="cpp">  <span class="kw">if</span>(Impact &amp;&amp; GraphReady)
    { Impact=GraphReady=<span class="const">0</span>;
      <span class="rem">// &hellip; дальнейшие действия &hellip;</span>
    }</pre>

<p>Почему в модели сначала проверяется сигнал <span class="cpp">Impact</span>, и, если он не взведен,
<span class="cpp">GraphReady</span> сбрасывается? Дело в том, что мы пока не знаем, как и
какими блоками будет формироваться сигнал, поступающий на вход <span class="cpp">GraphReady</span>. Если он
будет взят с выхода готовности одного из блоков непосредственно перед графиком, не исключены ложные срабатывания
сигнала, если этот блок по какой-либо причине запустится до завершения расчета траектории. Мы точно знаем
только одно: при нормальной работе схемы сигнал готовности графика может прийти только после завершения
расчета траектории, то есть сигнал <span class="cpp">GraphReady</span> может быть взведен только после того,
как взведется сигнал <span class="cpp">Impact</span>. Таким образом, все срабатывания
<span class="cpp">GraphReady</span> до <span class="cpp">Impact</span> можно считать ложными, и
сбрасывать их. Без этого нам пришлось бы жестко требовать от пользователя, который будет собирать схему на основе
нашего блока, исключения ложных срабатываний <span class="cpp">GraphReady</span>, что, несомненно,
усложнит его работу.</p>

<p>Вернемся к реакции модели на такт расчета. Когда оба входных сигнала взведены, модель сбрасывает
их и сравнивает текущий угол с верхней границей диапазона. Если угол достиг конца диапазона,
значит, все углы уже перебраны, и расчет завершается. В противном случае к текущему значению угла
<span class="cpp">Angle</span> добавляется шаг <span class="cpp">Accuracy</span>, и сумма записывается в поле
<span class="cpp">AngleToSet</span> личной области данных &ndash; после сброса расчета это значение
будет переписано в выход блока <span class="cpp">Angle</span> и передастся в блок расчета траектории.
Затем взводится флаг <span class="cpp">SelfReset</span> и родительская подсистема сбрасывается в начальное
состояние.</p>

<p>Теперь, используя созданный блок, можно собрать схему для построения графика, изображенную
на <a href="#pic10" title="Построение графика зависимости дальности от угла">рис.&nbsp;103</a>.
В этой схеме блок-планировщик, блок перебора углов и блок расчета траектории помещены в подсистему
&laquo;<span class="rdsvar">Sys1</span>&raquo;, которая, в свою очередь, помещена в
<a href="pm_1_2.htm#ref5" title="Корневая подсистема">корневую подсистему</a>. Устанавливаемое блоком перебора значение угла
&laquo;<span class="rdsvar">Angle</span>&raquo; подается на одноименный вход блока расчета траектории и выведено на внешний
выход подсистемы. Сигнал &laquo;<span class="rdsvar">Impact</span>&raquo; с блока расчета траектории подан на одноименный вход
блока перебора углов и на внешний выход &laquo;<span class="rdsvar">OK</span>&raquo; подсистемы. Горизонтальная координата снаряда
&laquo;<span class="rdsvar">x</span>&raquo; выведена наружу подсистемы через внешний выход &laquo;<span class="rdsvar">L</span>&raquo;. Наконец,
с внешнего входа подсистемы &laquo;<span class="rdsvar">Ready</span>&raquo; сигнал подается на вход
&laquo;<span class="rdsvar">GraphReady</span>&raquo; блока перебора углов &ndash; это и есть сигнал готовности графика, который
формируется снаружи подсистемы &laquo;<span class="rdsvar">Sys1</span>&raquo;.</p>

<div class="pic"><div class="container" id="pic10">
<img src="../img/Ballistics3.png" width="711" height="502" alt="Построение графика зависимости дальности от угла" />
<p id="light_pic10">Рис.&nbsp;103. Построение графика зависимости дальности от угла</p>
</div></div>


<p>Снаружи подсистемы &laquo;Sys1&raquo; все устроено достаточно просто. Сигнал
&laquo;<span class="rdsvar">OK</span>&raquo; (к нему внутри подсистемы подключен сигнал &laquo;<span class="rdsvar">Impact</span>&raquo;) подан на вход
счетчика, который, таким образом, будет считать число расчетов траектории, увеличивая свой выход
&laquo;<span class="rdsvar">N</span>&raquo; каждый раз, как снаряд будет падать на землю. Выход &laquo;<span class="rdsvar">N</span>&raquo; счетчика соединен со
входом времени &laquo;<span class="rdsvar">Time</span>&raquo; двухкоординатного графика. Чтобы схема работала, в
параметрах этого графика нужно указать, что значение времени нужно брать не из динамической переменной
&laquo;<span class="rdsvar">DynTime</span>&raquo;, а с входа &laquo;<span class="rdsvar">Time</span>&raquo; &ndash; в этом случае график будет запоминать
очередной отсчет при изменении этого входа. К входу &laquo;<span class="rdsvar">X</span>&raquo; графика присоединен выход подсистемы
&laquo;<span class="rdsvar">Angle</span>&raquo;, а к входу &laquo;<span class="rdsvar">Y</span>&raquo; &ndash; выход &laquo;<span class="rdsvar">L</span>&raquo;. Таким образом,
на момент окончания расчета траектории, у графика на входе &laquo;<span class="rdsvar">X</span>&raquo; окажется значение угла возвышения,
а на входе &laquo;<span class="rdsvar">Y</span>&raquo; &ndash; соответствующая ему дальность. В качестве сигнала готовности графика
(внешний вход &laquo;<span class="rdsvar">Ready</span>&raquo; подсистемы) используется выход счетчика &laquo;<span class="rdsvar">N</span>&raquo;: в
RDS с сигнальным входом можно соединять выход любого типа, при этом сигнал взведется при срабатывании связи,
идущей от этого выхода, какое бы значение ни было передано по этой связи.</p>

<p>Схема будет работать следующим образом: при самом первом запуске расчета блок перебора выдаст на
выход &laquo;<span class="rdsvar">Angle</span>&raquo; начало диапазона углов, и блок расчета траектории начнет моделировать полет
снаряда. На выходе счетчика в корневой подсистеме, а, значит, и на входе &laquo;<span class="rdsvar">Time</span>&raquo; графика при
этом будет начальное значение счетчика, то есть 0. На входе &laquo;<span class="rdsvar">X</span>&raquo; графика установится начальное
значение угла, а на вход &laquo;<span class="rdsvar">Y</span>&raquo; будет постоянно передаваться меняющаяся горизонтальная координата
снаряда. Как только снаряд упадет на землю, блок расчета траектории выдаст сигнал
&laquo;<span class="rdsvar">Impact</span>&raquo;, который попадет на вход блока перебора углов и, через выход подсистемы
&laquo;<span class="rdsvar">OK</span>&raquo;, на вход счетчика. Блок перебора углов не сделает ничего, поскольку он пока еще
не получил сигнал готовности графика. Счетчик увеличит значение на 1, и это значение одновременно попадет на
вход &laquo;<span class="rdsvar">Time</span>&raquo; графика и взведет сигнал &laquo;<span class="rdsvar">GraphReady</span>&raquo; у блока перебора углов через
внешний вход &laquo;<span class="rdsvar">Ready</span>&raquo; подсистемы. График при этом запомнит очередной отсчет
&laquo;угол–дальность&raquo;, а блок перебора сбросит расчет. Затем все повторится снова: по
окончании расчета траектории счетчик увеличит выходное значение, график запишет очередной отсчет, расчет будет
сброшен и т.д. Так будет продолжаться до тех пор, пока угол не достигнет верхней границы диапазона. В
результате получится график зависимости дальности полета снаряда от угла возвышения для заданного диапазона
углов.</p>

<p>График на <a href="#pic10" title="Построение графика зависимости дальности от угла">рис.&nbsp;103</a> построен для начальной скорости
200 м/с в диапазоне углов 0&hellip;90&deg; с шагом по углу 0.1&deg;. Поскольку ось нашей метательной
машины поднята на 1 м от поверхности земли
(см. <a href="#pic7" title="Окно настройки блока расчета траектории снаряда">рис.&nbsp;100</a>), при нулевом угле возвышения дальность
полета получилась не нулевой. При угле возвышения 90&deg;, то есть при выстреле вертикально вверх, снаряд,
как и следовало ожидать, имеет нулевую дальность полета. Видно, что дальности 3000 м, для которой при
тех же параметрах блоком поиска угла был найден угол возвышения 36&deg;
(<a href="#pic8" title="Схема поиска угла возвышения для заданной дальности">рис.&nbsp;101</a>), соответствует еще и угол около 50&deg;. Таким
образом, в прошлый раз наш блок поиска угла нашел угол возвышения для настильной траектории.</p>

<p>Оба рассмотренных примера используют сброс подсистемы для повторного проведения расчета с
новыми параметрами. В принципе, можно было бы написать блок расчета траектории снаряда так, чтобы
его можно было перезапускать при помощи специального входного сигнала, тогда программный сброс расчета
не понадобился бы. Однако, это несколько усложнило бы модель блока. Кроме того, многие стандартные
блоки (например, графики) и блоки, написанные сторонними программистами, могут не иметь возможности
перезапуска, поэтому при работе с ними программный сброс расчета &ndash; единственный выход.
Использование программного сброса для многократного проведения расчета делает схему универсальной,
поскольку она при этом не зависит от особенностей реализации моделей входящих в нее блоков: если
они работают при сбросе и запуске расчета пользователем, они будут работать и при программном сбросе.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="pm_2_14_1.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="pm_2_14_3.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="pm_index.htm#light_htm:pm_2_14_2">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
