<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;2.5.2. Особенности использования сигналов</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="pm_index.htm">Руководство программиста</a></p>
<div class="level"><p><a href="pm_index.htm#light_htm:pm_2">Глава 2. Создание моделей блоков</a></p>
<div class="level"><p><a href="pm_index.htm#light_htm:pm_2_5">&sect;2.5. Статические переменные блоков</a></p>
<div class="level"><p>&sect;2.5.2. Особенности использования сигналов</p>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="pm_2_5_1.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="pm_2_5_3.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="pm_index.htm#light_htm:pm_2_5_2">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
<div class="right">
<span class="curtab">Текст</span>
<span class="tab"><a href="pm_2_5_2_c.htm">С++</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Руководство программиста</h1>
<h2 class="off">Глава 2. Создание моделей блоков</h2>
<h3 class="off">&sect;2.5. Статические переменные блоков</h3>
<h4>&sect;2.5.2. Особенности использования сигналов</h4>
<p class="abstract">Описываются особенности работы с переменными сигнального типа, то есть с переменными, используемыми для передачи информации о факте наступления какого-либо события. Использование сигналов позволяет организовать сложное логическое взаимодействие блоков. Приводится пример модели блока-счетчика, увеличивающего значение своего выхода на единицу при каждом поступлении сигнала на вход.</p>



<div class="picright"><div class="container" id="pic1">
<img src="../img/Signals_Count.png" width="251" height="51" alt="Подсчет числа нажатий кнопки" />
<p id="light_pic1">Рис.&nbsp;17. Подсчет числа нажатий кнопки</p>
</div></div>


<p>Во многих случаях модели блока бывает нужно не передать другим блокам по связям какое-либо конкретное
значение, а уведомить их о том, что произошло какое-то событие, на которое эти блоки должны отреагировать
согласно логике работы своих моделей. Допустим, например, что нам для каких-то целей нужно подсчитывать число
нажатий кнопки пользователем. Мы можем для этого взять из библиотеки RDS стандартные блоки: кнопку,
счетчик и индикатор, и соединить их, как показано на
<a href="#pic1" title="Подсчет числа нажатий кнопки">рис.&nbsp;17</a>.
Если бы таких стандартных блоков в библиотеке не было, нам пришлось бы создавать модели кнопки и
счетчика самостоятельно. Рассмотрим возможные варианты решения этой задачи.</p>

<p>Передавать факт нажатия кнопки по связи при помощи обычных переменных, конечно, можно, но не очень
удобно. Можно было бы, например, сделать выход кнопки логическим и присваивать ему единицу при нажатии кнопки
и ноль при отпускании. В этом случае счетчик, который подключен к этой кнопке, должен был бы увеличивать на
единицу свой выход только при изменении значения своего входа с ноля на единицу. Просто увеличивать выход при
единичном значении входа было бы ошибкой: если пользователь продержит кнопку нажатой несколько тактов расчета,
на протяжении всех этих тактов вход счетчика будет иметь единичное значение, и его выход будет каждый раз
увеличиваться, хотя пользователь нажал на кнопку всего один раз. Таким образом, в этом случае мы подсчитали
бы не число фактических нажатий кнопки, а число тактов, в течение которых кнопка была нажата. Значит, нам
нужно отслеживать именно изменение входа с нуля на единицу (переход кнопки в нажатое состояние), а для этого
в блок придется добавить дополнительную переменную, в которую нужно записывать значение входа в прошлом
такте и сравнивать с ней его текущее значение &ndash; только так мы сможем обнаружить изменение входа. </p>

<p>Кроме усложнения модели блока из-за необходимости работы с дополнительной переменной, хранящей прошлое значение
входа, этот метод передачи информации о событиях имеет еще один недостаток: блок сможет реагировать на события не
чаще одного раза в два такта. Действительно, обнаружив событие мы должны присвоить выходу блока единицу, а
сбросить его в ноль мы сможем только в следующем такте, иначе единица не будет передана по связи, и блок на
другом ее конце на получит информацию об этом событии. Таким образом, передача информации о событии занимает
два такта, в течение которых новое событие будет проигнорировано блоком. Для реакции на нажатие кнопки этот
недостаток не имеет большого значения, поскольку такты расчета занимают очень небольшое время, и за один такт
пользователь просто физически не успеет отпустить кнопку и снова ее нажать. Однако, во многих случаях
игнорирование двух последовательных событий может помешать нормальной работе схемы.</p>

<p>Во избежание описанных выше проблем, в RDS введен
<a href="pm_1_5.htm#light_ref3" title="Сигналы в блоке">сигнальный тип</a>
переменных, специально предназначенный для передачи по связям информации о событиях. Как и логические
переменные, сигнальные могут принимать значения 0 и 1, но передаются от блока к блоку они совсем по-другому.
Во-первых, по связи передается только единичное значение сигнального выхода, при его нулевом значении связь
не срабатывает. Фактически, передается только передний фронт сигнала: при изменении значения выхода с
0 на 1 во все входы, соединенные с этим выходом, запишется значение 1. Во-вторых, после передачи единичного
значения сигнальному выходу автоматически присваивается ноль. Таким образом, отпадает необходимость в
дополнительном такте расчета для обнуления значения выхода: выход обнуляется автоматически в конце такта,
и в следующем же такте блок будет готов передать информацию о новом событии. Кроме того, в блоках, к
входам которых подключена сигнальная связь, нет необходимости создавать дополнительные переменные для
отслеживания факта изменения входа. Вместо этого при обнаружении на сигнальном входе единицы им достаточно
сбросить его в ноль: поскольку выход соединенного блока будет сброшен автоматически, а нулевое значение
сигнального выхода по связи не передается, единица на входе появится только при следующем событии.
Следует учитывать, что если модель блока с сигнальным входом не сбросит этот вход после реакции на событие,
то в следующем такте расчета, обнаружив единицу на входе, она может ошибочно посчитать, что произошло еще
одно событие. По этой причине при написании моделей крайне важно следить за сбросом сигнальных входов.
Однако, в некоторых случаях, единицу, не исчезающую автоматически с сигнального входа после срабатывания связи,
модель может использовать в своих целях. Например, если модель выполняет какие-то действия по таймеру раз в
несколько секунд, она может не беспокоиться о том, что пропустит какое-то событие: единица, появившаяся на ее
входе в результате срабатывания связи, так на нем и останется до следующего вызова модели по таймеру. Конечно,
в этом случае модель не сможет узнать, сколько именно событий произошло между ее вызовами, но, во многих случаях,
это и не нужно. Если же число событий важно, всегда можно переписать модель так, чтобы она, как положено,
сбрасывала сигнальный вход в каждом такте расчета и увеличивала какой-нибудь внутренний счетчик.</p>

<p>Описанные принципы передачи сигнальных переменных по связям можно проиллюстрировать условной временной
диаграммой, приведенной на
<a href="#pic2" title="Временная диаграмма передачи переменных сигнального типа на примере трех соединенных блоков">рис.&nbsp;18</a>. Пусть в схеме есть три блока:
&laquo;<span class="rdsvar">Блок 1</span>&raquo; с сигнальным выходом <span class="cpp">y</span>, &laquo;<span class="rdsvar">Блок 2</span>&raquo; с
сигнальным входом <span class="cpp">x1</span> и &laquo;<span class="rdsvar">Блок 3</span>&raquo; с сигнальным
входом <span class="cpp">x2</span>, причем выход первого блока соединен с входами второго и третьего.</p>

<div class="pic"><div class="container" id="pic2">
<img src="../img/SignalTimeDiagram.png" width="657" height="637" alt="Временная диаграмма передачи переменных сигнального типа на примере трех соединенных блоков" />
<p id="light_pic2">Рис.&nbsp;18. Временная диаграмма передачи переменных сигнального типа<br />на примере трех соединенных блоков</p>
</div></div>


<p>На рисунке изображены три такта расчета, каждый из которых разделен на две части: полутакт срабатывания
моделей блоков и следующий за ним полутакт срабатывания связей. Пусть в первом такте модель первого блока
присвоила сигнальному выходу <span class="cpp">y</span> значение 1 (на рисунке этот момент обозначен буквой
&laquo;а&raquo;), информируя соединенные блоки о каком-то событии. В конце этого такта, при срабатывании
связей, эта единица будет передана на входы <span class="cpp"></span> и <span class="cpp">x2</span> второго
и третьего блоков соответственно (&laquo;б&raquo;), а значение выхода <span class="cpp">y</span> будет
автоматически обнулено (&laquo;в&raquo;).</p>

<p>Во втором такте расчета модель второго блока обнаружит единицу на входе <span class="cpp">x1</span>, выполнит
связанные с данным событием действия, определяемые логикой модели, и обнулит вход, подготавливая его к приему
информации о следующем событии (&laquo;г&raquo;). Модель третьего блока в это же время по какой-то причине
(по своей внутренней логике или из-за ошибки программиста) не обнулит вход <span class="cpp">x2</span>, и в нем
так и останется единичное значение (&laquo;д&raquo;). В это же время модель первого блока снова присвоит
выходу <span class="cpp">y</span> единицу, чтобы сообщить соединенным блокам о втором событии (&laquo;е&raquo;).
Когда в конце второго такта расчета начнут срабатывать связи, эта единица снова будет передана на входы первого
и второго блоков (&laquo;ж&raquo;), однако, поскольку значение <span class="cpp">x2</span> не было сброшено
моделью второго блока, там оставалась единица, полученная им в прошлом такте расчета &ndash; таким образом,
значение <span class="cpp">x2</span> не изменится. После передачи выходу первого блока снова будет автоматически
присвоено нулевое значение (&laquo;з&raquo;).</p>

<p>В начале третьего такта расчета выход <span class="cpp">y</span> имеет нулевое значение, а входы
<span class="cpp">x1</span> и <span class="cpp">x2</span> &ndash; единичные. В этом такте первый блок не
будет информировать остальные о новом событии, его выход <span class="cpp">y</span> так и останется нулевым
и не будет передаваться по связям. Модель второго блока, отреагировав на событие, информация о котором
передана ей по связи в конце второго такта, снова сбросит свой вход <span class="cpp">x1</span>
(&laquo;и&raquo;) и будет ждать нового события. Значение же <span class="cpp">x2</span>, не сброшенное
моделью третьего блока, так и останется единичным, поскольку нулевое значение сигнального выхода
<span class="cpp">y</span>, соединенного с ним, в конце третьего такта не будет передано по связи.</p>

<p>Из приведенной диаграммы видно, что модель первого блока передала по связям информацию о
двух событиях в двух последовательных тактах (такт 1 и такт 2). Модель второго блока узнала об обоих
этих событиях, несмотря на то, что они возникли в соседних тактах, и отреагировала на них с запаздыванием
в один такт (любая передача данных по связи создает такое запаздывание, потому что модель блока, на вход
которого переданы данные, запустится только в начале следующего такта расчета). Модель же третьего блока
не сбросила вовремя свой сигнальный вход и поэтому не сможет узнать, сколько событий произошло с момента
выполнения первого такта расчета.</p>

<p>При работе с сигналами нужно также иметь в виду, что в RDS к одному и тому же входу блока может
быть одновременно присоединено несколько связей. Если несколько связей подключено к сигнальному входу,
значение этого входа станет единицей при срабатывании хотя бы одной из них. Модель не может узнать,
сколько связей одновременно сработало. Значение входа либо останется нулем, если не сработала ни одна,
либо станет равным единице, если сработала одна или несколько связей. Если модели необходимо знать число
сработавших связей, их нужно подключать к разным входам блока и анализировать независимо. Можно, например,
сделать вход <a href="pm_2_5_3.htm" title="&sect;2.5.3. Доступ к матрицам и массивам">массивом</a>
сигналов и <a href="um_2_7_3.htm" title="&sect;2.7.3. Подключение связей к полям структур и элементам массивов">подключать связи к его элементам</a>.</p>

<p><span id="light_ref3"><span id="ref1">Обязательные </span><span id="ref2">для </span>каждого простого блока переменные</span>
<span class="cpp" id="light_ref1">Start</span> и
<span class="cpp" id="light_ref2">Ready</span> тоже являются сигналами. При задании набора переменных блока
(см. <a href="pm_1_5.htm#pic2" title="Редактор переменных">рис.&nbsp;9</a>) можно изменить только их имена и начальные значения,
при этом первая переменная блока всегда останется сигнальным входом, а вторая &ndash; сигнальным выходом.
Эти сигналы управляют работой модели и ее выходных связей в режиме расчета: единица на входе
<span class="cpp">Start</span> запускает модель блока, единица на выходе <span class="cpp">Ready</span> разрешает
передачу данных выходов. Модель может работать с этими переменными как с обычными сигналами, однако следует
помнить, что RDS автоматически сбрасывает сигнал <span class="cpp">Start</span> и взводит сигнал
<span class="cpp">Ready</span> перед запуском модели для выполнения такта моделирования, то есть в режиме
<span class="cpp"><a href="RDS_BFM_MODEL.htm" title="А.2.4.9. RDS_BFM_MODEL &ndash; выполнение такта расчета">RDS_BFM_MODEL</a></span>. Если модели необходимо запуститься в следующем такте независимо от
срабатывания связей, присоединенных к ее входам, и состояния флага блока
&laquo;<a href="pm_1_4.htm#ref6" title="Запуск модели каждый такт">запуск каждый такт</a>&raquo;, она может самостоятельно взвести сигнал
<span class="cpp">Start</span>. Модель также может запретить передачу данных своих выходов по связям, сбросив
сигнал <span class="cpp">Ready</span>.</p>

<p>Для примера рассмотрим модель блока-счетчика, который по сигналу изменяет значение выхода от 0 до 9,
после чего выдает на выход сигнал переноса и начинает счет с нуля. Блок будет иметь сигнальные входы
<span class="cpp">Clk</span> и <span class="cpp">Reset</span>, целый выход <span class="cpp">Count</span> и
сигнальный выход <span class="cpp">Carry</span>. Блок будет работать следующим образом: по сигналу,
приходящему на вход <span class="cpp">Clk</span>, блок будет увеличивать значение выхода
<span class="cpp">Count</span> на 1 до тех пор, пока оно не достигнет девяти. При следующем срабатывании
<span class="cpp">Clk</span> модель обнулит выход <span class="cpp">Count</span> и выдаст сигнал переноса на
выход <span class="cpp">Carry</span>. По сигналу <span class="cpp">Reset</span> модель должна обнулить оба
выхода.
На <a href="#pic3" title="Два последовательно соединенных счетчика">рис.&nbsp;19</a>
изображены два таких счетчика, соединенные последовательно.</p>

<div class="pic"><div class="container" id="pic3">
<img src="../img/Signal_Counters.png" width="393" height="156" alt="Два последовательно соединенных счетчика" />
<p id="light_pic3">Рис.&nbsp;19. Два последовательно соединенных счетчика</p>
</div></div>


<p>К входу <span class="cpp">Clk</span> первого счетчика подключена кнопка &laquo;+1&raquo;, позволяющая
увеличивать значение его выхода на единицу. Его выход <span class="cpp">Carry</span> подключен к входу
<span class="cpp">Clk</span> второго счетчика &ndash; в результате этого, когда первый счетчик досчитает до
десяти и его выход обнулится, второй увеличит свой выход на единицу. Кнопка &laquo;Сброс&raquo; подключена к
входам <span class="cpp">Reset</span> обоих счетчиков, ее нажатие сбрасывает их одновременно. При таком
соединении выходы первого и второго счетчиков можно считать двумя разрядами двузначного десятичного числа,
таким образом, вместе они могут досчитать до ста.</p>

<p>Структура переменных такого блока-счетчика будет выглядеть следующим образом:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Смещение</th>
    <th>Имя</th>
    <th>Тип</th>
    <th>Размер</th>
    <th>Вход/выход</th>
  </tr>
  <tr>
    <td class="center">0</td>
    <td>Start</td>
    <td class="center">Сигнал</td>
    <td class="center">1</td>
    <td class="center">Вход</td>
  </tr>
  <tr>
    <td class="center">1</td>
    <td>Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">1</td>
    <td class="center">Выход</td>
  </tr>
  <tr>
    <td class="center">2</td>
    <td>Reset</td>
    <td class="center">Сигнал</td>
    <td class="center">1</td>
    <td class="center">Вход</td>
  </tr>
  <tr>
    <td class="center">3</td>
    <td>Clk</td>
    <td class="center">Сигнал</td>
    <td class="center">1</td>
    <td class="center">Вход</td>
  </tr>
  <tr>
    <td class="center">4</td>
    <td>Count</td>
    <td class="center">int</td>
    <td class="center">4</td>
    <td class="center">Выход</td>
  </tr>
  <tr>
    <td class="center">8</td>
    <td>Carry</td>
    <td class="center">Сигнал</td>
    <td class="center">1</td>
    <td class="center">Выход</td>
  </tr>
</table>
</div></div>

<p>Модель блока будет такой:</p>

<pre class="cpp">  <span class="kw">extern</span> <span class="str">"C"</span> <span class="kw">__declspec</span>(<span class="kw">dllexport</span>)
    <span class="kw">int</span> <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> TestCounter(<span class="kw">int</span> CallMode,
      <a class="hidden" href="RDS_BLOCKDATA.htm#ref2" title="Указатель на RDS_BLOCKDATA">RDS_PBLOCKDATA</a> BlockData,
      <a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> ExtParam)
  {
  <span class="rem">// </span><a class="hidden" href="pm_2_5_1.htm#light_ref9" title="Макросы для статических переменных блока"><span class="rem">Макроопределения для статических переменных</span></a>
  <span class="preproc">#define pStart ((char *)(BlockData-&gt;VarData))</span>
  <span class="preproc">#define Start  (*((char *)(pStart)))</span>
  <span class="preproc">#define Ready  (*((char *)(pStart+1)))</span>
  <span class="preproc">#define Reset  (*((char *)(pStart+2)))</span>
  <span class="preproc">#define Clk    (*((char *)(pStart+3)))</span>
  <span class="preproc">#define Count  (*((int *)(pStart+4)))</span>
  <span class="preproc">#define Carry  (*((char *)(pStart+8)))</span>
    <span class="kw">switch</span>(CallMode)
      { <span class="rem">// Проверка типа переменных</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_VARCHECK.htm" title="А.2.4.18. RDS_BFM_VARCHECK &ndash; проверка допустимости структуры статических переменных блока">RDS_BFM_VARCHECK</a>:
          <span class="kw">if</span>(strcmp((<span class="kw">char</span>*)ExtParam,<span class="str">"{SSSSIS}"</span>)==<span class="const">0</span>)
            <span class="kw">return</span> <a class="hidden" href="app_a_2_1.htm#ref2" title="Возврат RDS_BFR_DONE">RDS_BFR_DONE</a>;
          <span class="kw">return</span> <a class="hidden" href="RDS_BFM_VARCHECK.htm#light_ref3" title="Возврат RDS_BFR_BADVARSMSG">RDS_BFR_BADVARSMSG</a>;

        <span class="rem">// Выполнение такта моделирования</span>
        <span class="kw">case</span> <a class="hidden" href="RDS_BFM_MODEL.htm" title="А.2.4.9. RDS_BFM_MODEL &ndash; выполнение такта расчета">RDS_BFM_MODEL</a>:
          <span class="kw">if</span>(Reset) <span class="rem">// Поступил сигнал Reset</span>
            { Reset=<span class="const">0</span>;  <span class="rem">// Сброс этого сигнала</span>
              Clk=<span class="const">0</span>;    <span class="rem">// Сброс сигнала Clk</span>
              Count=<span class="const">0</span>;  <span class="rem">// Обнуление счетчика</span>
              Carry=<span class="const">0</span>;  <span class="rem">// Сброс сигнала переноса</span>
            }
          <span class="kw">else</span> <span class="kw">if</span>(Clk) <span class="rem">// Поступил сигнал Clk</span>
            { Clk=<span class="const">0</span>;    <span class="rem">// Сброс этого сигнала</span>
              Count++;  <span class="rem">// Увеличение счетчика</span>
              <span class="kw">if</span>(Count&gt;=<span class="const">10</span>)  <span class="rem">// Досчитали до 10</span>
                { Count=<span class="const">0</span>;      <span class="rem">// Обнуление счетчика</span>
                  Carry=<span class="const">1</span>;      <span class="rem">// Выдача сигнала переноса</span>
                }
            }
          <span class="kw">break</span>;
      }

    <span class="kw">return</span> <a class="hidden" href="app_a_2_1.htm#ref2" title="Возврат RDS_BFR_DONE">RDS_BFR_DONE</a>;
  <span class="rem">// Отмена макроопределений</span>
  <span class="preproc">#undef Carry</span>
  <span class="preproc">#undef Count</span>
  <span class="preproc">#undef Clk</span>
  <span class="preproc">#undef Reset</span>
  <span class="preproc">#undef Ready</span>
  <span class="preproc">#undef Start</span>
  <span class="preproc">#undef pStart</span>
  }
  <span class="rem">//=========================================</span></pre>

<p>При вызове этой модели с параметром <span class="cpp"><a href="RDS_BFM_VARCHECK.htm" title="А.2.4.18. RDS_BFM_VARCHECK &ndash; проверка допустимости структуры статических переменных блока">RDS_BFM_VARCHECK</a></span> производится сравнение переданной
строки типа переменных блока со строкой &laquo;{SSSSIS}&raquo;. Все переменные блока &ndash;
сигналы (&laquo;S&raquo;), кроме целой переменной <span class="cpp">Count</span>, которой соответствует символ
&laquo;I&raquo;. Сравнив строки, модель возвращает RDS соответствующую константу &ndash;
<span class="cpp">RDS_BFR_DONE</span>, если структура переменных блока правильная, и
<span class="cpp">RDS_BFR_BADVARSMSG</span> в противном случае.</p>

<p>При вызове модели с параметром <span class="cpp"><a href="RDS_BFM_MODEL.htm" title="А.2.4.9. RDS_BFM_MODEL &ndash; выполнение такта расчета">RDS_BFM_MODEL</a></span> для выполнения такта расчета сначала
проверяется, не поступил ли на вход блока сигнал сброса <span class="cpp">Reset</span>. Этот сигнал считается
более важным, поэтому его проверка производится до проверки сигнала <span class="cpp">Clk</span>. Если в одном
такте на вход блока придут оба сигнала, <span class="cpp">Reset</span> будет иметь приоритет. Если
<span class="cpp">Reset</span> имеет значение 1, он обнуляется, чтобы модель могла среагировать на него еще
раз (иначе единица останется на этом входе навсегда). Сигнал <span class="cpp">Clk</span> также сбрасывается
&ndash; если он поступил одновременно с <span class="cpp">Reset</span>, его нужно игнорировать. Затем
обнуляется счетчик <span class="cpp">Count</span> и сбрасывается сигнал переноса <span class="cpp">Carry</span>.
Сброс сигнала переноса может показаться излишним, поскольку выходные сигналы автоматически сбрасываются при
передаче по связям. Однако, если к выходу <span class="cpp">Carry</span> не было подключено ни одной связи,
его значение не будет никуда передаваться, и, следовательно, сбрасываться он также не будет. Если пользователь
остановит расчет и соединит сигнал <span class="cpp">Carry</span> с другими блоками, сохранившаяся в нем
единица будет немедленно передана на их входы при повторном запуске расчета, даже если на вход данного блока
поступит сигнал <span class="cpp">Reset</span>. Поэтому лучше подстраховаться и принудительно обнулить
<span class="cpp">Carry</span> при поступлении сигнала сброса.</p>

<p>Если сигнал сброса не поступал (<span class="cpp">Reset</span> имеет значение 0), модель проверяет значение
сигнала <span class="cpp">Clk</span>. Если он имеет ненулевое значение, он обнуляется, чтобы модель могла
среагировать на него в дальнейшем, и значение счетчика <span class="cpp">Count</span> увеличивается на 1.
Если значение <span class="cpp">Count</span> достигло 10, оно сбрасывается в 0 и взводится сигнал переноса
<span class="cpp">Carry</span>. Сбрасывать сигнал переноса не нужно &ndash; он либо сбросится автоматически,
если его значение будет передано по связям, либо останется взведенным, запомнив факт переполнения счетчика,
до тех пор, пока к нему не будет подключена какая-либо связь.</p>

<p>Для блока с этой моделью необходимо либо включить
<a href="pm_1_4.htm#ref6" title="Запуск модели каждый такт">запуск каждый такт расчета</a>, либо установить флаги
&laquo;<span class="menu">Пуск</span>&raquo; (см. <a href="pm_1_5.htm#pic2" title="Редактор переменных">рис.&nbsp;9</a>)
для входов <span class="cpp">Reset</span> и <span class="cpp">Clk</span>. Если этого не
сделать, модель будет запускаться только при срабатывании связи, соединенной со входом
<span class="cpp">Start</span>, что для данного блока не имеет никакого смысла. У блока есть два собственных
управляющих сигнала, поэтому его модель должна либо запускаться при их срабатывании (если для них установлены
флаги &laquo;<span class="menu">Пуск</span>&raquo;), либо проверять их значения в каждом такте расчета.</p>

<p>Следует помнить, что в RDS все события, произошедшие в одном такте расчета, считаются
произошедшими одновременно. Если в одном такте на оба сигнальных входа поступит по единице, модель должна
считать их пришедшими одновременно и действовать исходя из приоритета этих сигналов. В описанной модели
приоритетным считается сигнал <span class="cpp">Reset</span>, и поступивший одновременно с ним
<span class="cpp">Clk</span> будет проигнорирован.
<span id="light_ref4">Если при одновременном поступлении сигналов ни один из них игнорировать нельзя</span>, можно сначала сбросить счетчик,
а потом, реагируя на <span class="cpp">Clk</span>, увеличить
его на 1. В этом случае реакцию модели на такт расчета необходимо изменить следующим образом (выделено цветом):</p>

<pre class="cpp">      <span class="rem">// Выполнение такта моделирования</span>
      <span class="kw">case</span> <a class="hidden" href="RDS_BFM_MODEL.htm" title="А.2.4.9. RDS_BFM_MODEL &ndash; выполнение такта расчета">RDS_BFM_MODEL</a>:
        <span class="kw">if</span>(Reset)     <span class="rem">// Поступил сигнал Reset</span>
          { Reset=<span class="const">0</span>;  <span class="rem">// Сброс этого сигнала</span>
            Count=<span class="const">0</span>;  <span class="rem">// Обнуление счетчика</span>
            Carry=<span class="const">0</span>;  <span class="rem">// Сброс сигнала переноса</span>
            <span class="changes"><span class="rem">// Сигнал Clk теперь не сбрасывается </span></span>
          }
        <span class="changes"><span class="rem">// "else if(Clk)" заменено на "if(Clk)" </span></span>
        <span class="changes"><span class="kw">if</span>(Clk)</span>  <span class="rem">// Поступил сигнал Clk</span>
          { Clk=<span class="const">0</span>;    <span class="rem">// Сброс этого сигнала</span>
            Count++;  <span class="rem">// Увеличение счетчика</span>
            <span class="kw">if</span>(Count&gt;=<span class="const">10</span>) <span class="rem">// Досчитали до 10</span>
              { Count=<span class="const">0</span>;  <span class="rem">// Обнуление счетчика</span>
                Carry=<span class="const">1</span>;  <span class="rem">// Выдача сигнала переноса</span>
              }
          }
        <span class="kw">break</span>;</pre>

<p>Как и в предыдущем варианте, модель сначала проверяет значение сигнала <span class="cpp">Reset</span> и,
если оно равно единице, обнуляет счетчик. Однако, если раньше модель в этом случае сбрасывала
<span class="cpp">Clk</span> и завершалась, теперь она проверяет значение <span class="cpp">Clk</span> и
увеличивает счетчик независимо от состояния <span class="cpp">Reset</span>. Теперь при одновременном
поступлении сигналов значение <span class="cpp">Count</span> будет равно 1, а не 0, поскольку сначала оно
будет сброшено из-за сигнала <span class="cpp">Reset</span>, а потом увеличено на единицу из-за сигнала
<span class="cpp">Clk</span>.</p>

<p>Для проверки работы созданной модели можно собрать схему с
<a href="#pic3" title="Два последовательно соединенных счетчика">рис.&nbsp;19</a>. Если запустить расчет и нажимать на кнопку
&laquo;+1&raquo;, каждое нажатие должно приводить к увеличению числа на выходе первого счетчика
&ndash; оно отображается на верхнем индикаторе. Когда счетчик досчитает до девяти, следующее нажатие на кнопку
&laquo;+1&raquo; должно привести к обнулению выхода первого счетчика и увеличению выхода второго
(нижний индикатор). Нажатие кнопки &laquo;Сброс&raquo; должно приводить к обнулению выходов обоих счетчиков.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="pm_2_5_1.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="pm_2_5_3.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="pm_index.htm#light_htm:pm_2_5_2">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
