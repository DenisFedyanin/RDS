<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.5. Вмешательство в загрузку и сохранение схемы</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="pm_index.htm">Руководство программиста</a></p>
<div class="level"><p><a href="pm_index.htm#light_htm:pm_3">Глава 3. Управление RDS из других приложений</a></p>
<div class="level"><p>&sect;3.5. Вмешательство в загрузку и сохранение схемы</p>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="pm_3_4.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="pm_3_6_1.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="pm_index.htm#light_htm:pm_3_5">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
<div class="right">
<span class="curtab">Текст</span>
<span class="tab"><a href="pm_3_5_c.htm">С++</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Руководство программиста</h1>
<h2 class="off">Глава 3. Управление RDS из других приложений</h2>
<h3>&sect;3.5. Вмешательство в загрузку и сохранение схемы</h3>
<p class="abstract">Рассматриваются методы перехвата событий загрузки и сохранения схемы, которые позволяют 
            управляющему приложению вмешаться в эти процессы для самостоятельной организации хранения схем (например, 
            в базе данных). В рассматриваемый пример программы добавляются функции, позволяющие сохранять схему в 
            виде набора отдельных файлов, каждый из которых соответствует блоку или связи, и загружать схему из 
            такого набора.</p>


<p>Управляющее приложение может отдать управляемой копии RDS команду загрузить схему из указанного файла &ndash;
мы рассматривали функцию <span class="cpp"><a href="rdsctrlLoadSystemFromFile.htm" title="Б.3.5.6. rdsctrlLoadSystemFromFile &ndash; загрузить схему из файла">rdsctrlLoadSystemFromFile</a></span> в
<a href="pm_3_2.htm" title="&sect;3.2. Загрузка библиотеки и управление схемой">&sect;3.2</a>. При необходимости, приложение может и сохранить загруженную
схему в файл функцией <span class="cpp"><span id="light_ref1"><a href="rdsctrlSaveSystemToFile.htm" title="Б.3.5.15. rdsctrlSaveSystemToFile &ndash; сохранить схему в файл">rdsctrlSaveSystemToFile</a></span></span>, например, если пользователь внес
в нее какие-либо изменения. Кроме того, пользователь может сам загружать и сохранять схемы в управляемой копии
RDS с помощью соответствующих пунктов
<a href="um_2_1.htm" title="&sect;2.1. Главное окно и главное меню">главного меню</a>. В рассматриваемом нами примере приложения показ
главного окна RDS запрещен вызовом <span class="cpp"><a href="rdsctrlShowMainWindow.htm" title="Б.3.3.13. rdsctrlShowMainWindow &ndash; видимость главного окна RDS">rdsctrlShowMainWindow</a></span> с параметром
<span class="cpp">FALSE</span>, так что может показаться, что в нашем случае пользователь не сможет
загружать и сохранять схемы, поскольку главное меню, как и главное окно, ему недоступно. Однако, сочетания клавиш
<span class="keys">Ctrl</span>&nbsp;+&nbsp;<span class="keys">O</span> и <span class="keys">Ctrl</span>&nbsp;+&nbsp;<span class="keys">S</span>, соответствующие этим пунктам главного меню, все
равно будут работать даже при невидимом главном окне.</p>

<p>Тем не менее, разработчику управляющего приложения не всегда удобно хранить схемы в отдельно расположенных
файлах, и, тем более, давать пользователю полную свободу загрузки и сохранения этих схем. Если, например,
RDS в составе приложения используется для демонстрации схем соединения каких-либо объектов, все данные
этих объектов (а, значит, и схемы их соединения) обычно хранятся в базе данных. Таким образом, если пользоваться
файловыми функциями загрузки и сохранения, приложению придется выгружать схему из базы данных во временный
файл, после чего давать RDS команду загрузить схему из этого файла. Если пользователю разрешено
редактировать схему, приложению также придется записывать этот файл в базу данных после сохранения его
пользователем. И, конечно, приложение должно будет запретить пользователю загружать в управляемую копию
RDS &laquo;посторонние&raquo; схемы.</p>

<p>В библиотеке RdsCtrl.dll предусмотрено несколько способов облегчить жизнь разработчику управляющего приложения.
Прежде всего, можно запретить сохранение схем и их загрузку из файлов функциями
<span class="cpp"><span id="light_ref2"><a href="rdsctrlNoDirectSave.htm" title="Б.3.5.11. rdsctrlNoDirectSave &ndash; запрет сохранения схемы пользователем">rdsctrlNoDirectSave</a></span></span> и <span class="cpp"><span id="light_ref3"><a href="rdsctrlNoDirectLoad.htm" title="Б.3.5.10. rdsctrlNoDirectLoad &ndash; запрет загрузки схемы пользователем">rdsctrlNoDirectLoad</a></span></span> соответственно.
В эти функции передается идентификатор связи с RDS и логический параметр, запрещающий (<span class="cpp">TRUE</span>)
или разрешающий (<span class="cpp">FALSE</span>) работу с файлами схем. По умолчанию или после вызова
<span class="cpp"><a class="hidden" href="rdsctrlNoDirectLoad.htm" title="Б.3.5.10. rdsctrlNoDirectLoad &ndash; запрет загрузки схемы пользователем">rdsctrlNoDirectLoad</a></span> с параметром <span class="cpp">FALSE</span> RDS
будет работать в обычном режиме: при выборе пункта меню &laquo;<span class="menu">загрузить</span>&raquo; или нажатии
<span class="keys">Ctrl</span>&nbsp;+&nbsp;<span class="keys">O</span> появится стандартный диалог открытия файла, в котором пользователь сможет
выбрать файл схемы для загрузки. Если же вызвать <span class="cpp"><a class="hidden" href="rdsctrlNoDirectLoad.htm" title="Б.3.5.10. rdsctrlNoDirectLoad &ndash; запрет загрузки схемы пользователем">rdsctrlNoDirectLoad</a></span> с параметром
<span class="cpp">TRUE</span>, вместо показа пользователю диалога открытия RDS будет вызывать в
управляющем приложении событие <span class="cpp"><span id="light_ref4"><a href="RDSCTRLEVENT_LOADREQ.htm" title="Б.2.8. RDSCTRLEVENT_LOADREQ &ndash; запрос загрузки схемы">RDSCTRLEVENT_LOADREQ</a></span></span>. Реагируя на это событие,
приложение сможет само показать диалог открытия или дать пользователю выбрать схему каким-либо другим способом
(например, предъявив ему список схем, хранящихся в базе данных), после чего оно сможет передать выбранную схему в
RDS через временный файл или одним из способов, которые будут описаны ниже.</p>

<p>Точно так же, после вызова <span class="cpp"><a class="hidden" href="rdsctrlNoDirectSave.htm" title="Б.3.5.11. rdsctrlNoDirectSave &ndash; запрет сохранения схемы пользователем">rdsctrlNoDirectSave</a></span> с параметром <span class="cpp">TRUE</span>,
вместо сохранения схемы RDS будет вызывать в управляющем приложении событие
<span class="cpp"><span id="light_ref5"><a href="RDSCTRLEVENT_SAVEFILE.htm" title="Б.2.11. RDSCTRLEVENT_SAVEFILE &ndash; сохранение схемы">RDSCTRLEVENT_SAVEFILE</a></span></span>, в ответ на которое приложение сможет получить
содержимое схемы и записать его, например, в базу данных.</p>

<p>Передавать содержимое схемы из управляющего приложения в RDS и обратно можно не только через временный
файл. Можно, например, использовать функцию <span class="cpp"><span id="light_ref6"><a href="rdsctrlLoadSystemFromMem.htm" title="Б.3.5.7. rdsctrlLoadSystemFromMem &ndash; загрузить схему из области памяти">rdsctrlLoadSystemFromMem</a></span></span>, которая передает в
RDS схему, которая находится в памяти приложения в текстовом формате, и парную к ней
<span class="cpp"><span id="light_ref7"><a href="rdsctrlGetSystemContent.htm" title="Б.3.5.5. rdsctrlGetSystemContent &ndash; получить полный текст схемы">rdsctrlGetSystemContent</a></span></span>, которая возвращает текст схемы, загруженной в данный
момент в RDS, в виде строки. Эти функции несколько облегчают программирование, но, по своей сути,
они мало отличаются от сохранения схемы в текстовом формате в одном приложении с последующей загрузкой этого
текста в другом. Основной недостаток обоих этих способов загрузки и сохранения заключается в том, что при
их использовании вся схема рассматривается как единый объект, разбить который на отдельные блоки и связи
управляющее приложение сможет только с помощью разбора текстового формата RDS, что представляет собой
отдельную, достаточно объемную, задачу. В то же время, разработчику приложения часто удобнее считать каждый блок
схемы отдельным объектом, и хранить в базе данных не только описание этого блока, необходимое для его работы в
схеме в RDS, но и различные дополнительные данные, к которым модель блока сможет обращаться при работе.
В RdsCtrl.dll предусмотрен набор функций для поблочного сохранения схем, позволяющих получать информацию
о загруженной в RDS схеме блок за блоком, связь за связью, при этом для каждого блока и каждой связи
сообщается <a href="rdsBlockOrConnByExtId.htm#light_ref2" title="Внешние целые идентификаторы">целый идентификатор</a>, уникальный в пределах этой схемы.
Этот идентификатор можно использовать,
например, в ключе какой-либо таблицы базы данных, в которой хранится информация, связанная с этим блоком.
Идентификаторы ранее не упоминались в примерах, поскольку при написании моделей блоков они практически не
используются. Основное их назначение &ndash; однозначная идентификация блока или связи в схеме при внешнем
управлении. Идентификаторы блоков и связей в схеме не могут совпадать, то есть в схеме не может быть блока и
связи с одинаковыми идентификаторами. Корневая подсистема схемы всегда имеет идентификатор 0.</p>

<p>Для того, чтобы начать поблочное сохранение схемы, управляющее приложение должно вызвать функцию
<span class="cpp"><span id="light_ref8"><a href="rdsctrlStartBlockByBlockSave.htm" title="Б.3.5.18. rdsctrlStartBlockByBlockSave &ndash; начать поблочное сохранение схемы">rdsctrlStartBlockByBlockSave</a></span></span>, как всегда указав в ее параметрах идентификатор связи
с той копией RDS, откуда нужно будет получать данные. Эта функция подготовит
RdsCtrl.dll к передаче информации о загруженной схеме и заполнит все внутренние структуры данных,
необходимые для этой передачи. Результатом возврата функции будет общее число блоков данных (описаний блоков,
описаний связей и вспомогательных), из которых состоит загруженная схема &ndash; таким образом, возврат нуля
сигнализирует о невозможности получения информации о схеме (например, если схема не загружена).</p>

<p>Затем управляющее приложение должно в цикле вызывать функцию <span class="cpp"><span id="light_ref9"><a href="rdsctrlGetBlockByBlockSavePiece.htm" title="Б.3.5.4. rdsctrlGetBlockByBlockSavePiece &ndash; получить очередной объект при поблочном сохранении">rdsctrlGetBlockByBlockSavePiece</a></span></span>,
каждый вызов которой будет возвращать описание очередного блока или связи схемы. Порядок следования этих
описаний определяется RDS и не может быть изменен, задача приложения &ndash; обрабатывать полученное им
описание необходимым ему способом (например, записывая его в таблицу базы данных). Функция
<span class="cpp"><a class="hidden" href="rdsctrlGetBlockByBlockSavePiece.htm" title="Б.3.5.4. rdsctrlGetBlockByBlockSavePiece &ndash; получить очередной объект при поблочном сохранении">rdsctrlGetBlockByBlockSavePiece</a></span> принимает следующие параметры:</p>

<pre class="cpp">  <span class="kw">int</span> <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> <a class="hidden" href="rdsctrlGetBlockByBlockSavePiece.htm" title="Б.3.5.4. rdsctrlGetBlockByBlockSavePiece &ndash; получить очередной объект при поблочном сохранении">rdsctrlGetBlockByBlockSavePiece</a>(
    <span class="kw">int</span> link,         <span class="rem">// Связь с RDS</span>
    <a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> *pExtId,    <span class="rem">// Возвращаемый идентификатор объекта</span>
    <a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> *pParentId, <span class="rem">// Возвращаемый идентификатор родителя</span>
    <a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> text);     <span class="rem">// Возвращаемый текст описания</span></pre>

<p>В параметре <span class="cpp">link</span> передается идентификатор связи с копией RDS, данные схемы
которой запрашиваются. В параметре <span class="cpp">pExtId</span> передается указатель на целую переменную
типа <span class="cpp"><a href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a></span>, в которую функция запишет идентификатор возвращаемого объекта, если это
блок или связь. В параметре <span class="cpp">pParentId</span> передается такой же указатель на <span class="cpp"><a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a></span>,
через который функция возвращает идентификатор
<a href="pm_1_2.htm#ref7" title="Родительская подсистема">родительской подсистемы</a> возвращаемого объекта &ndash; эта информация
может потребоваться приложению для организации базы данных. Наконец, в параметре <span class="cpp">text</span>
передается указатель на объект для хранения строк, в который функция запишет текстовое описание возвращаемого объекта
при помощи <a href="pm_3_1.htm#light_ref4" title="Возврат строк в RdsCtrl.dll">функции обратного вызова</a>, ранее зарегистрированной вызовом
<span class="cpp"><a href="rdsctrlSetStringCallback.htm" title="Б.3.2.10. rdsctrlSetStringCallback &ndash; регистрация функции возврата строки">rdsctrlSetStringCallback</a></span>. Возвращает функция целый тип объекта, который указывает,
описание чего именно функция только что передала приложению. Тип может принимать одно из
следующих однобайтовых значений (эти константы описаны в
&laquo;<span class="file">RdsDef.h</span>&raquo;):</p>


  <div class="tablecenter"><div class="tcont">
  <table>
    <tr>
      <th>Константа</th>
      <th>Значение</th>
      <th>Объект</th>
      <th><span class="cpp">*pExtId</span></th>
      <th><span class="cpp">*pParentId</span></th>
    </tr>
    <tr>
      <td><span class="cpp"><span id="light_ref10">RDS_SFTAG_ROOT</span></span></td>
      <td class="center"><span class="cpp">0x15</span></td>
      <td><a href="pm_1_2.htm#ref5" title="Корневая подсистема">Корневая подсистема</a></td>
      <td class="center">0</td>
      <td class="center">0</td>
    </tr>
    <tr>
      <td><span class="cpp"><span id="light_ref11">RDS_SFTAG_SIMPLEBLOCK</span></span></td>
      <td class="center"><span class="cpp">0x10</span></td>
      <td><a href="pm_1_2.htm#light_ref3" title="Простой блок">Простой блок</a></td>
      <td class="center">Идентификатор объекта<br />(далее &ndash; <i>ИО</i>)</td>
      <td class="center">Идентификатор родительской подсистемы<br />(далее &ndash; <i>ИРП</i>)</td>
    </tr>
    <tr>
      <td><span class="cpp"><span id="light_ref12">RDS_SFTAG_SYSTEM</span></span></td>
      <td class="center"><span class="cpp">0x11</span></td>
      <td><a href="pm_1_2.htm#light_ref4" title="Подсистема">Подсистема</a></td>
      <td class="center"><i>ИО</i></td>
      <td class="center"><i>ИРП</i></td>
    </tr>
    <tr>
      <td><span class="cpp"><span id="light_ref13">RDS_SFTAG_INPUTBLOCK</span></span></td>
      <td class="center"><span class="cpp">0x12</span></td>
      <td><a href="pm_1_2.htm#light_ref6" title="Внешний вход подсистемы">Внешний вход</a></td>
      <td class="center"><i>ИО</i></td>
      <td class="center"><i>ИРП</i></td>
    </tr>
    <tr>
      <td><span class="cpp"><span id="light_ref14">RDS_SFTAG_OUTPUTBLOCK</span></span></td>
      <td class="center"><span class="cpp">0x13</span></td>
      <td><a href="pm_1_2.htm#light_ref8" title="Внешний выход подсистемы">Внешний выход</a></td>
      <td class="center"><i>ИО</i></td>
      <td class="center"><i>ИРП</i></td>
    </tr>
    <tr>
      <td><span class="cpp"><span id="light_ref15">RDS_SFTAG_BUSPORT</span></span></td>
      <td class="center"><span class="cpp">0x14</span></td>
      <td><a href="pm_1_2.htm#light_ref9" title="Ввод шины">Ввод шины</a></td>
      <td class="center"><i>ИО</i></td>
      <td class="center"><i>ИРП</i></td>
    </tr>
    <tr>
      <td><span class="cpp"><span id="light_ref16">RDS_SFTAG_CONNECTION</span></span></td>
      <td class="center"><span class="cpp">0x20</span></td>
      <td><a href="um_2_7_1.htm" title="&sect;2.7.1. Общие принципы создания связей">Связь</a></td>
      <td class="center"><i>ИО</i></td>
      <td class="center"><i>ИРП</i></td>
    </tr>
    <tr>
      <td><span class="cpp"><span id="light_ref17">RDS_SFTAG_BUS</span></span></td>
      <td class="center"><span class="cpp">0x21</span></td>
      <td><a href="um_2_8.htm" title="&sect;2.8. Использование шин">Шина</a></td>
      <td class="center"><i>ИО</i></td>
      <td class="center"><i>ИРП</i></td>
    </tr>
    <tr>
      <td><span class="cpp"><span id="light_ref18">RDS_SFTAG_CONNSTYLES</span></span></td>
      <td class="center"><span class="cpp">1</span></td>
      <td><a href="um_2_13.htm" title="&sect;2.13. Стили связей и шин">Стили связей</a></td>
      <td class="center">0</td>
      <td class="center">0</td>
    </tr>
    <tr>
      <td><span class="cpp"><span id="light_ref19">RDS_SFTAG_TYPES</span></span></td>
      <td class="center"><span class="cpp">2</span></td>
      <td>Описание <a href="um_2_14.htm" title="&sect;2.14. Создание и изменение структур">структур</a></td>
      <td class="center">0</td>
      <td class="center">0</td>
    </tr>
    <tr>
      <td><span class="cpp"><span id="light_ref20">RDS_SFTAG_EOF</span></span></td>
      <td class="center"><span class="cpp">0</span></td>
      <td>Конец данных</td>
      <td class="center">0</td>
      <td class="center">0</td>
    </tr>
  </table>
  </div></div>

<p>Следует отметить, что для корневой подсистемы схемы предусмотрен отдельный тип <span class="cpp">RDS_SFTAG_ROOT</span>.
Это связано с тем, что обычно управляющее приложение обрабатывает корневую подсистему отдельно и связывает с
ней информацию, относящуюся ко всей схеме в целом. Для корневой подсистемы не возвращается идентификатор
родительской подсистемы (точнее, возвращается нулевое значение), поскольку родительская подсистема у
нее отсутствует.</p>

<p>Типы <span class="cpp">RDS_SFTAG_CONNSTYLES</span> и <span class="cpp">RDS_SFTAG_TYPES</span> указывают на
возврат вспомогательных данных &ndash; набора описаний стилей связей и набора структур соответственно. Приложение
может не сохранять эти данные, поскольку вся информация о внешнем виде связей и структурах, используемых блоками,
содержится в описаниях этих связей и блоков. Описания стилей связей и структур всей схемы имеет смысл сохранять,
только если пользователь будет редактировать схему и создавать новые блоки и связи. Например, если пользователь
захочет добавить в свой блок переменную типа &laquo;Complex&raquo;, описание структуры
&laquo;Complex&raquo; должно быть в наборе структур схемы. Оно может оказаться там в двух случаях: либо
если в схеме уже есть блок, использующий эту структуру (тогда она добавится в общий список структур схемы
автоматически), либо если эта структуры когда-то была добавлена в общий набор структур схемы и этот набор
был загружен вместе со схемой.</p>

<p>Управляющее приложение должно вызвать функцию получения описания очередного объекта схемы
<span class="cpp"><a class="hidden" href="rdsctrlGetBlockByBlockSavePiece.htm" title="Б.3.5.4. rdsctrlGetBlockByBlockSavePiece &ndash; получить очередной объект при поблочном сохранении">rdsctrlGetBlockByBlockSavePiece</a></span> либо по числу блоков данных в схеме (это
число возвращается функцией <span class="cpp"><a class="hidden" href="rdsctrlStartBlockByBlockSave.htm" title="Б.3.5.18. rdsctrlStartBlockByBlockSave &ndash; начать поблочное сохранение схемы">rdsctrlStartBlockByBlockSave</a></span>), либо до тех пор,
пока она вместо типа объекта не вернет константу <span class="cpp">RDS_SFTAG_EOF</span>. После этого необходимо
вызвать функцию <span class="cpp"><span id="light_ref21"><a href="rdsctrlEndBlockByBlockSave.htm" title="Б.3.5.3. rdsctrlEndBlockByBlockSave &ndash; завершить поблочное сохранение схемы">rdsctrlEndBlockByBlockSave</a></span></span> для завершения поблочного сохранения
схемы и освобождения памяти, которую RdsCtrl.dll отвела под внутренние структуры данных (для
больших схем эти структуры могут занимать достаточно много места, поэтому лучше вызывать эту функцию сразу
после обработки последнего принятого блока данных). Таким образом, обычно процедура поблочного сохранения выглядит
примерно следующим образом (считаем, что <span class="cpp">RdsLink</span> &ndash; идентификатор связи с
работающей копией RDS):</p>

<pre class="cpp">  <a class="hidden" href="pm_3_3.htm#ref3" title="Вспомогательный класс для хранения строк">TDynString</a> objtext; <span class="rem">// Объект для хранения текста из</span>
                      <span class="rem">// рассмотренных выше примеров</span>
  <span class="kw">if</span>(!<a class="hidden" href="rdsctrlStartBlockByBlockSave.htm" title="Б.3.5.18. rdsctrlStartBlockByBlockSave &ndash; начать поблочное сохранение схемы">rdsctrlStartBlockByBlockSave</a>(RdsLink,<span class="const">0</span>))
    { <span class="rem">// &hellip; ошибка – получение данных схемы невозможно &hellip;</span>
    }
  <span class="kw">else</span>
    { <a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> id,parentid;
      <span class="kw">for</span>(;;)
        { <span class="rem">// Получаем очередной блок данных</span>
          <span class="kw">int</span> type=<a class="hidden" href="rdsctrlGetBlockByBlockSavePiece.htm" title="Б.3.5.4. rdsctrlGetBlockByBlockSavePiece &ndash; получить очередной объект при поблочном сохранении">rdsctrlGetBlockByBlockSavePiece</a>(
                       RdsLink,&amp;id,&amp;parentid,&amp;objtext);
          <span class="kw">if</span>(type==<span class="const">0</span>) <span class="rem">// RDS_SFTAG_EOF – данные кончились</span>
            <span class="kw">break</span>;
          <span class="rem">// &hellip; сохранение объекта типа type с идентификатором</span>
          <span class="rem">// id, идентификатором родителя parentid</span>
          <span class="rem">// и описанием objtext &hellip;</span>
        }
      <span class="rem">// Завершаем прием данных из RDS</span>
      <a class="hidden" href="rdsctrlEndBlockByBlockSave.htm" title="Б.3.5.3. rdsctrlEndBlockByBlockSave &ndash; завершить поблочное сохранение схемы">rdsctrlEndBlockByBlockSave</a>(RdsLink);
    }</pre>

<p>Вместо сравнения полученного типа объекта с нулем (<span class="cpp">RDS_SFTAG_EOF</span>) и прерывания бесконечного
цикла <span class="cpp">for(;;)</span> в случае совпадения, можно было бы использовать в качестве верхнего
предела цикла число, возвращенное <span class="cpp"><a class="hidden" href="rdsctrlStartBlockByBlockSave.htm" title="Б.3.5.18. rdsctrlStartBlockByBlockSave &ndash; начать поблочное сохранение схемы">rdsctrlStartBlockByBlockSave</a></span> &ndash;
здесь разработчик приложения может поступать так, как ему удобнее.</p>

<p>Поблочная загрузка схемы в работающую копию RDS производится примерно так же, как и сохранение. Сначала
нужно подготовить RdsCtrl.dll к приему данных о схеме вызовом
<span class="cpp"><span id="light_ref22"><a href="rdsctrlStartBlockByBlockLoad.htm" title="Б.3.5.18. rdsctrlStartBlockByBlockLoad &ndash; начать поблочную загрузку схемы">rdsctrlStartBlockByBlockLoad</a></span></span>, затем передать каждый объект по отдельности вызовами
<span class="cpp"><span id="light_ref23"><a href="rdsctrlSetBlockByBlockLoadPiece.htm" title="Б.3.5.16. rdsctrlSetBlockByBlockLoadPiece &ndash; передать очередной объект при поблочной загрузке">rdsctrlSetBlockByBlockLoadPiece</a></span></span> (переданная информация запоминается во внутренней памяти
RdsCtrl.dll), после чего завершить загрузку вызовом
<span class="cpp"><span id="light_ref24"><a href="rdsctrlEndBlockByBlockLoad.htm" title="Б.3.5.2. rdsctrlEndBlockByBlockLoad &ndash; завершить поблочную загрузку схемы">rdsctrlEndBlockByBlockLoad</a></span></span> &ndash; в этот момент накопленная в памяти
RdsCtrl.dll) информация будет передана в RDS для формирования схемы.</p>

<p>Функция <span class="cpp"><a class="hidden" href="rdsctrlSetBlockByBlockLoadPiece.htm" title="Б.3.5.16. rdsctrlSetBlockByBlockLoadPiece &ndash; передать очередной объект при поблочной загрузке">rdsctrlSetBlockByBlockLoadPiece</a></span> принимает три параметра:
идентификатор связи с RDS, тип передаваемого объекта (одну из констант
<span class="cpp">RDS_SFTAG_*</span>) и строку его описания. Порядок передачи описаний различных объектов
может быть произвольным (можно передать описание блока до того, как передано описание его родительской подсистемы,
и т.п.) Идентификатор объекта, как и идентификатор родительской подсистемы, не передается &ndash;
вся эта информация содержится в тексте описания самого объекта. Таким образом, управляющая программа не
может при передаче схемы в RDS поменять идентификаторы объектов &ndash; это может показаться искусственным
ограничением, но разрешение смены идентификаторов могло бы привести к нарушению их уникальности и проблемам
в работе схемы. Следует помнить, что идентификаторы блокам и связям присваиваются внутри RDS, и ни
управляющая программа, ни модели блоков никак не могут повлиять на этот процесс.</p>

<p>Функция <span class="cpp"><a class="hidden" href="rdsctrlEndBlockByBlockLoad.htm" title="Б.3.5.2. rdsctrlEndBlockByBlockLoad &ndash; завершить поблочную загрузку схемы">rdsctrlEndBlockByBlockLoad</a></span> возвращает логическое значение,
указывающее на успешность передачи схемы в RDS, и принимает два параметра:</p>

<pre class="cpp">  <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> <a class="hidden" href="rdsctrlEndBlockByBlockLoad.htm" title="Б.3.5.2. rdsctrlEndBlockByBlockLoad &ndash; завершить поблочную загрузку схемы">rdsctrlEndBlockByBlockLoad</a>(
    <span class="kw">int</span> link,    <span class="rem">// Связь с RDS</span>
    <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> apply); <span class="rem">// Передать (TRUE) или отменить (FALSE)</span></pre>

<p>В параметре <span class="cpp">apply</span> передается <span class="cpp">TRUE</span>, если из всех переданных
объектов необходимо сформировать схему, или <span class="cpp">FALSE</span>, если нужно отменить передачу и
уничтожить все накопленные в памяти данные. Процедура поблочной загрузки выглядит примерно так
(<span class="cpp">RdsLink</span> &ndash; идентификатор связи с RDS):</p>

<pre class="cpp">  <span class="rem">// Начинаем передачу данных объектов</span>
  <a class="hidden" href="rdsctrlStartBlockByBlockLoad.htm" title="Б.3.5.18. rdsctrlStartBlockByBlockLoad &ndash; начать поблочную загрузку схемы">rdsctrlStartBlockByBlockLoad</a>(RdsLink,<span class="const">0</span>);
  <span class="rem">// Передаем данные всех объектов в цикле</span>
  <span class="kw">for</span>(<i>&hellip; для всех объектов &hellip;</i>)
    <a class="hidden" href="rdsctrlSetBlockByBlockLoadPiece.htm" title="Б.3.5.16. rdsctrlSetBlockByBlockLoadPiece &ndash; передать очередной объект при поблочной загрузке">rdsctrlSetBlockByBlockLoadPiece</a>(RdsLink,<i>тип</i>,<i>строка_описания</i>);
  <span class="kw">if</span>(!<a class="hidden" href="rdsctrlEndBlockByBlockLoad.htm" title="Б.3.5.2. rdsctrlEndBlockByBlockLoad &ndash; завершить поблочную загрузку схемы">rdsctrlEndBlockByBlockLoad</a>(RdsLink,TRUE))
    { <span class="rem">// &hellip; ошибка сборки схемы &hellip;</span>
    }</pre>

<p>Добавим в рассматриваемый пример управляющего приложения возможность поблочного сохранения и загрузки схемы.
Мы не будем вводить в пример работу с базой данных &ndash; это неоправданно усложнило бы его. Вместо этого мы
поступим следующим образом: каждый объект схемы мы будем сохранять в отдельный текстовый файл, и, кроме того,
список имен файлов всех объектов тоже запишем в файл, по одному имени файла на строку. Это даст представление о
работе больших приложений, которые для хранения объектов схемы вместо файлов могут использовать записи в таблицах
базы данных.</p>

<p>Чтобы не добавлять в программу новые кнопки для вызова функций поблочного сохранения и загрузки схемы,
мы запретим в RDS сохранение и загрузку схем и введем в программе реакцию на на события
<span class="cpp"><a href="RDSCTRLEVENT_LOADREQ.htm" title="Б.2.8. RDSCTRLEVENT_LOADREQ &ndash; запрос загрузки схемы">RDSCTRLEVENT_LOADREQ</a></span> и <span class="cpp"><a href="RDSCTRLEVENT_SAVEFILE.htm" title="Б.2.11. RDSCTRLEVENT_SAVEFILE &ndash; сохранение схемы">RDSCTRLEVENT_SAVEFILE</a></span>. Таким образом,
если пользователь нажмет <span class="keys">Ctrl</span>&nbsp;+&nbsp;<span class="keys">O</span> или <span class="keys">Ctrl</span>&nbsp;+&nbsp;<span class="keys">S</span> (мы запрещаем показ главного окна
RDS, поэтому пункты меню &laquo;<span class="menu">загрузить</span>&raquo; и &laquo;<span class="menu">сохранить</span>&raquo; будут пользователю недоступны),
вместо загрузки или сохранения схемы вызовется реакция в нашей программе, где мы и будем выполнять все действия
для поблочной загрузки и сохранения.</p>

<p>Прежде всего, необходимо <span class="changes">добавить</span> в функцию
<span class="cpp">RegisterEvents</span> вызовы для запрещения загрузки и сохранения, а также регистрацию реакций
на новые события:</p>

<pre class="cpp">  <span class="rem">// Разрешение событий и регистрация функций реакций</span>
  <span class="kw">void</span> RegisterEvents(<span class="kw">void</span>)
  {
    <span class="rem">// Разрешить реакцию на события</span>
    <a class="hidden" href="rdsctrlEnableEvents.htm" title="Б.3.6.1. rdsctrlEnableEvents &ndash; разрешение реакции на события">rdsctrlEnableEvents</a>(RdsLink,TRUE);
    <span class="rem">// Событие завершения RDS</span>
    <a class="hidden" href="rdsctrlRegisterEventStdCallback.htm" title="Б.3.6.4. rdsctrlRegisterEventStdCallback &ndash; регистрация функции для реакции на событие">rdsctrlRegisterEventStdCallback</a>(RdsLink,
        <a class="hidden" href="RDSCTRLEVENT_CONNCLOSED.htm" title="Б.2.6. RDSCTRLEVENT_CONNCLOSED &ndash; завершение RDS">RDSCTRLEVENT_CONNCLOSED</a>,RdsExitEvent,NULL);
    <span class="rem">// Событие запуска расчета</span>
    <a class="hidden" href="rdsctrlRegisterEventStdCallback.htm" title="Б.3.6.4. rdsctrlRegisterEventStdCallback &ndash; регистрация функции для реакции на событие">rdsctrlRegisterEventStdCallback</a>(RdsLink,
        <a class="hidden" href="RDSCTRLEVENT_CALCSTART.htm" title="Б.2.4. RDSCTRLEVENT_CALCSTART &ndash; запуск расчета">RDSCTRLEVENT_CALCSTART</a>,CalcStartStopEvent,NULL);
    <span class="rem">// Событие завершения расчета</span>
    <a class="hidden" href="rdsctrlRegisterEventStdCallback.htm" title="Б.3.6.4. rdsctrlRegisterEventStdCallback &ndash; регистрация функции для реакции на событие">rdsctrlRegisterEventStdCallback</a>(RdsLink,
        <a class="hidden" href="RDSCTRLEVENT_CALCSTOP.htm" title="Б.2.5. RDSCTRLEVENT_CALCSTOP &ndash; остановка расчета">RDSCTRLEVENT_CALCSTOP</a>,CalcStartStopEvent,NULL);
    <span class="rem">// Сообщение от блока</span>
    <a class="hidden" href="rdsctrlRegisterBlockMsgCallback.htm" title="Б.3.6.2. rdsctrlRegisterBlockMsgCallback &ndash; регистрация функции для реакции на сообщение от блока">rdsctrlRegisterBlockMsgCallback</a>(RdsLink,BlockMsgEvent,NULL);

<div class="changes">    <span class="rem">// Запрет загрузки файла (вместо этого идет событие)</span>
    <a class="hidden" href="rdsctrlNoDirectLoad.htm" title="Б.3.5.10. rdsctrlNoDirectLoad &ndash; запрет загрузки схемы пользователем">rdsctrlNoDirectLoad</a>(RdsLink,TRUE);
    <span class="rem">// Запрет сохранения файла (вместо этого идет событие)</span>
    <a class="hidden" href="rdsctrlNoDirectSave.htm" title="Б.3.5.11. rdsctrlNoDirectSave &ndash; запрет сохранения схемы пользователем">rdsctrlNoDirectSave</a>(RdsLink,TRUE);
    <span class="rem">// Событие загрузки (нажатие "Ctrl+O")</span>
    <a class="hidden" href="rdsctrlRegisterEventStdCallback.htm" title="Б.3.6.4. rdsctrlRegisterEventStdCallback &ndash; регистрация функции для реакции на событие">rdsctrlRegisterEventStdCallback</a>(RdsLink,<a class="hidden" href="RDSCTRLEVENT_LOADREQ.htm" title="Б.2.8. RDSCTRLEVENT_LOADREQ &ndash; запрос загрузки схемы">RDSCTRLEVENT_LOADREQ</a>,
        LoadRequestCallback,NULL);
    <span class="rem">// Событие сохранения (нажатие "Ctrl+S")</span>
    <a class="hidden" href="rdsctrlRegisterEventStdCallback.htm" title="Б.3.6.4. rdsctrlRegisterEventStdCallback &ndash; регистрация функции для реакции на событие">rdsctrlRegisterEventStdCallback</a>(RdsLink,<a class="hidden" href="RDSCTRLEVENT_SAVEFILE.htm" title="Б.2.11. RDSCTRLEVENT_SAVEFILE &ndash; сохранение схемы">RDSCTRLEVENT_SAVEFILE</a>,
        SaveRequestCallback,NULL);</div>
  }
  <span class="rem">//=========================================</span></pre>

<p>В функциях <span class="cpp">SaveRequestCallback</span> и <span class="cpp">LoadRequestCallback</span>, которые
мы зарегистрировали в качестве реакций на новые события, мы будем показывать стандартный диалог выбора файла для
сохранения или загрузки. Для этого весьма желательно сделать так, чтобы на момент появления этого диалога на
экране наше приложение оказалось бы на переднем плане, иначе диалог окажется закрыт окнами подсистем RDS.
Для этого мы напишем специальную функцию <span class="cpp">BringAppToTop</span>:</p>

<pre class="cpp">  <span class="rem">// "Вытаскивание" приложения на передний план</span>
  <span class="kw">void</span> BringAppToTop(<span class="kw">void</span>)
  { <a class="hidden" href="app_ids.htm#light_ref18" title="Дескриптор окна">HWND</a> hCurrWnd;
    <span class="kw">int</span> iMyTID;
    <span class="kw">int</span> iCurrTID;
    hCurrWnd=GetForegroundWindow();
    iMyTID=GetCurrentThreadId();
    iCurrTID=GetWindowThreadProcessId(hCurrWnd,<span class="const">0</span>);
    AttachThreadInput(iMyTID,iCurrTID,TRUE);
    <span id="light_ref25">SetForegroundWindow</span>(MainWin);
    AttachThreadInput(iMyTID,iCurrTID,FALSE);
  }
  <span class="rem">//=========================================</span></pre>

<p>Эта функция обходит известную проблему Windows API, из-за которой в поздних версиях Windows неактивный (не
обрабатывающий пользовательский ввод) процесс не может переместить свое окно на передний план. Здесь мы временно
подключаем поток нашего процесса к обработке ввода вызовом функции <span class="cpp">AttachThreadInput</span>
с параметром <span class="cpp">TRUE</span>, после чего перемещаем главное окно нашей программы (его дескриптор
находится в глобальной переменной <span class="cpp">MainWin</span>) на передний план функцией
<span class="cpp">SetForegroundWindow</span> &ndash; Windows уже не будет препятствовать этому. Затем мы снова
отключаем наш поток от пользовательского ввода повторным вызовом <span class="cpp">AttachThreadInput</span> с
параметром <span class="cpp">FALSE</span>. Более подробно останавливаться на этой функции мы не будем
&ndash; желающие могут изучить описание функций Windows API и доступную информацию о проблемах с перемещением на
передний план окна неактивного процесса.</p>

<p>Теперь можно написать функцию реакции на событие сохранения схемы <span class="cpp">SaveRequestCallback</span>.
Ее нужно разместить перед функцией <span class="cpp">RegisterEvents</span>, чтобы на момент компиляции вызовов
регистрации реакций на события <span class="cpp">SaveRequestCallback</span> уже была известна компилятору.</p>

<pre class="cpp">  <span class="rem">// Реакция на событие – пользователь нажал "сохранить"</span>
  <span class="kw">void</span> <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> SaveRequestCallback(<span class="kw">int</span> link,<span class="kw">int</span> event,
          <a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> edata,<a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> aux)
  { <span class="rem">// Массивы для работы с именами файлов</span>
    <span class="kw">char</span> filename[MAX_PATH+<span class="const">1</span>]=<span class="str">""</span>,
         dirname[MAX_PATH+<span class="const">1</span>],
         auxname[MAX_PATH+<span class="const">1</span>],
         temp[MAX_PATH+<span class="const">1</span>],
         *s;
    OPENFILENAME ofn;
    <a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> attr;
    HANDLE flist;
    <span class="kw">int</span> dirlen;

    <span class="rem">// Помещаем наше приложение на передний план</span>
    BringAppToTop();

    <span class="rem">// Заполняем структуру OPENFILENAME для диалога сохранения</span>
    ZeroMemory(&amp;ofn,<span class="kw">sizeof</span>(ofn));
    ofn.lStructSize=<span class="kw">sizeof</span>(ofn);
    ofn.hwndOwner=MainWin;
    ofn.lpstrFile=filename;
    ofn.nMaxFile=<span class="kw">sizeof</span>(filename);
    ofn.lpstrFilter=<span class="str">"Спецформат (*.spc)\0*.spc\0Все файлы\0*.*\0"</span>;
    ofn.lpstrDefExt=<span class="str">"spc"</span>;
    ofn.nFilterIndex=<span class="const">1</span>;
    ofn.Flags=OFN_EXPLORER | OFN_OVERWRITEPROMPT;
    <span class="rem">// Вызываем стандартный диалог сохранения Windows</span>
    <span class="kw">if</span>(!GetSaveFileName(&amp;ofn))
      <span class="kw">return</span>;
    <span class="rem">// Пользователь выбрал в диалоге имя файла, оно записано в</span>
    <span class="rem">// массив filename. В этот файл мы запишем список всех</span>
    <span class="rem">// имен файлов объектов</span>

    <span class="rem">// Файлы объектов будут записаны в подпапку filename+".files"</span>
    <span class="rem">// (рядом с файлом filename)</span>
    <span class="kw">if</span>(strlen(filename)&gt;MAX_PATH+<span class="const">8</span>)
      { DisplayText(<span class="str">"Слишком длинный путь"</span>);
        <span class="kw">return</span>;
      }
    strcpy(dirname,filename);
    strcat(dirname,<span class="str">".files"</span>);
    <span class="rem">// В массиве dirname теперь находится имя подпапки объектов</span>
    CreateDirectory(dirname,NULL); <span class="rem">// Создаем эту папку</span>
    <span class="rem">// Проверяем, создалась ли папка</span>
    attr=GetFileAttributes(dirname);
    <span class="kw">if</span>(attr==<span class="const">0xFFFFFFFF</span> || (attr &amp; FILE_ATTRIBUTE_DIRECTORY)==<span class="const">0</span>)
      { <span class="rem">// Папка с именем dirname не существует</span>
        DisplayText(<span class="str">"Невозможно создать папку"</span>);
        <span class="kw">return</span>;
      }
    <span class="rem">// Папка есть (создана или существовала раньше)</span>
    strcat(dirname,<span class="str">"&#92;&#92;"</span>); <span class="rem">// Добавляем разделитель в конец имени</span>
    dirlen=strlen(dirname); <span class="rem">// Длина имени папки с завершающим разделителем</span>

    <span class="rem">// В файл filename мы будем записывать имена файлов объектов</span>
    <span class="rem">// без пути – по одному на строчку</span>

    <span class="rem">// Открываем файл списка для записи</span>
    flist=CreateFile(filename,GENERIC_WRITE,<span class="const">0</span>,NULL,
        CREATE_ALWAYS,<span class="const">0</span>,NULL);
    <span class="kw">if</span>(flist==INVALID_HANDLE_VALUE) <span class="rem">// Ошибка открытия файла</span>
      { DisplayText(<span class="str">"Невозможно записать главный файл"</span>);
        <span class="kw">return</span>;
      }

    <span class="rem">// Начинаем чтение содержимого схемы из RDS</span>
    <span class="kw">if</span>(!<a class="hidden" href="rdsctrlStartBlockByBlockSave.htm" title="Б.3.5.18. rdsctrlStartBlockByBlockSave &ndash; начать поблочное сохранение схемы">rdsctrlStartBlockByBlockSave</a>(RdsLink,<span class="const">0</span>))
      { DisplayText(<span class="str">"Невозможно получить данные"</span>);
        CloseHandle(flist);
        <span class="kw">return</span>;
      }

    <span class="rem">// Читаем данные, пока функция не вернет нулевой тип блока</span>
    <span class="kw">for</span>(;;)
      { <a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> extid,parentid,res,size;
        <a class="hidden" href="pm_3_3.htm#ref3" title="Вспомогательный класс для хранения строк">TDynString</a> text;
        HANDLE f;
        <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> ok;
        <span class="rem">// Получаем из RDS данные очередного объекта</span>
        <span class="kw">int</span> tag=<a class="hidden" href="rdsctrlGetBlockByBlockSavePiece.htm" title="Б.3.5.4. rdsctrlGetBlockByBlockSavePiece &ndash; получить очередной объект при поблочном сохранении">rdsctrlGetBlockByBlockSavePiece</a>(RdsLink,
            &amp;extid,&amp;parentid,&amp;text);
        <span class="kw">if</span>(tag==<span class="const">0</span>) <span class="rem">// Данные кончились</span>
          <span class="kw">break</span>;
        <span class="kw">if</span>(text.IsEmpty()) <span class="rem">// Возвращенный текст описания пуст</span>
          <span class="kw">continue</span>;
        <span class="rem">// Формируем имя файла из типа tag и идентификатора extid</span>
        sprintf(temp,<span class="str">"%d_%u.obj"</span>,tag,extid);
        <span class="kw">if</span>(strlen(temp)+dirlen&gt;MAX_PATH)
          { DisplayText(<span class="str">"слишком длинный путь"</span>);
            <span class="kw">break</span>;
          }
        <span class="rem">// Добавляем к имени файла путь к папке dirname</span>
        strcpy(auxname,dirname);
        strcat(auxname,temp);
        <span class="rem">// Записываем текст text в файл auxname</span>
        f=CreateFile(auxname,GENERIC_WRITE,<span class="const">0</span>,NULL,CREATE_ALWAYS,
          <span class="const">0</span>,NULL);
        <span class="kw">if</span>(f==INVALID_HANDLE_VALUE)
          { DisplayText(<span class="str">"Невозможно записать файл объекта"</span>);
            <span class="kw">break</span>;
          }
        size=strlen(text.c_str); <span class="rem">// Размер текста</span>
        ok=WriteFile(f,text.c_str,size,&amp;res,NULL);
        CloseHandle(f);
        <span class="kw">if</span>((!ok) || res!=size)
          { DisplayText(<span class="str">"Ошибка записи файла объекта"</span>);
            <span class="kw">break</span>;
          }
        <span class="rem">// Дописываем имя файла (temp) в главный файл-список</span>
        size=strlen(temp); <span class="rem">// Длина имени файла</span>
        ok=WriteFile(flist,temp,size,&amp;res,NULL);
        <span class="kw">if</span>(res!=size) ok=FALSE;
        <span class="rem">// После имени записываем перевод строки и возврат каретки</span>
        ok=ok &amp;&amp; WriteFile(flist,<span class="str">"\r\n"</span>,<span class="const">2</span>,&amp;res,NULL);
        <span class="kw">if</span>(res!=<span class="const">2</span>) ok=FALSE;
        <span class="kw">if</span>(!ok)
          DisplayText(<span class="str">"Ошибка записи имени в список"</span>);
      }
    <span class="rem">// Закрываем файл списка</span>
    CloseHandle(flist);
    <span class="rem">// Завершаем чтение данных схемы</span>
    <a class="hidden" href="rdsctrlEndBlockByBlockSave.htm" title="Б.3.5.3. rdsctrlEndBlockByBlockSave &ndash; завершить поблочное сохранение схемы">rdsctrlEndBlockByBlockSave</a>(RdsLink);
  }
  <span class="rem">//=========================================</span></pre>

<p>Хотя к получению данных из RDS в этой функции относятся всего три вызова, она получилась довольно
длинной &ndash; в основном, из-за работы с диалогом и файловых операций. Сначала мы помещаем наше приложение
на передний план вызовом написанной ранее вспомогательной функции <span class="cpp">BringAppToTop</span>, чтобы
диалог был виден пользователю, а затем заполняем структуру <span class="cpp">OPENFILENAME ofn</span> и передаем
ее в функцию Windows API <span class="cpp">GetSaveFileName</span>, которая откроет стандартный диалог сохранения.
Если пользователь закроет диалог, не выбрав имя файла для записи, функция вернет <span class="cpp">FALSE</span>,
и на этом наша реакция завершится. Если же пользователь выберет файл или введет его имя вручную, функция вернет
<span class="cpp">TRUE</span> и запишет имя этого файла в массив <span class="cpp">filename</span> (указатель на
этот массив мы передали через структуру <span class="cpp">ofn</span>). В этот файл мы будем записывать список
имен всех отдельных файлов объектов схемы.</p>

<p>Чтобы как-то упорядочить сохраняемую информацию, файлы объектов мы будем помещать в папку с именем
выбранного пользователем файла, к которому добавлен суффикс &laquo;.files&raquo;. Так часто делают web-браузеры
при сохранении сложных документов: все вспомогательные файлы, связанные со страницей (например, графику), они
помещают в отдельную папку с именем, близким к имени файла основного документа. В нашем случае, если, например,
пользователь выберет файл &laquo;<span class="file">C:\Work\test.spc</span>&raquo;, файлы объектов будут размещаться в папке
&laquo;<span class="file">C:\Work\test.spc.files\</span>&raquo;, а имена этих файлов без путей будут записаны в
выбранный пользователем файл &laquo;<span class="file">test.spc</span>&raquo;.</p>

<p>Прежде чем начать запись, нам нужно создать папку файлов объектов, если она еще не существует. Для
упрощения примера мы не будем проверять существование этой папки и создавать ее только в случае ее отсутствия. Вместо
этого мы сразу попытаемся ее создать (что не получится, если она уже есть), а затем проверим ее наличие
&ndash; нам все равно пришлось бы проверять успешность создания, а так мы обойдемся единственной проверкой.
Имя папки мы формируем в массиве <span class="cpp">dirname</span>, добавляя к имени файла из массива
<span class="cpp">filename</span> строку &laquo;.files&raquo; (при этом следя за тем, чтобы полный путь
к папке получился не длиннее стандартной константы <span class="cpp">MAX_PATH</span>). Затем мы пытаемся создать
папку вызовом <span class="cpp">CreateDirectory</span>, после чего проверяем ее существование при помощи функции
получения атрибутов файла (в данном случае &ndash; папки) <span class="cpp">GetFileAttributes</span>. Если эта
функция вместо атрибутов вернет <span class="cpp">0xFFFFFFFF</span>, значит, файла или папки с таким именем нет,
то есть создание папки по каким-то причинам не выполнено. Если среди атрибутов не будет
<span class="cpp">FILE_ATTRIBUTE_DIRECTORY</span>, значит, это не папка, а файл, то есть на момент нашей попытки
создания папки уже существовал файл с тем же именем. В обоих случаях мы завершаем нашу функцию с
сообщением об ошибке.</p>

<p>Далее мы добавляем в конец массива <span class="cpp">dirname</span> обратную косую черту и запоминаем длину
получившейся строки в переменной <span class="cpp">dirlen</span> &ndash; она понадобится нам, когда мы будем
формировать имена файлов объектов. Файл, выбранный пользователем, мы открываем для записи функцией
<span class="cpp">CreateFile</span> и помещаем его дескриптор в переменную <span class="cpp">flist</span>. По мере
записи объектов схемы мы будем записывать в него имена их файлов.</p>

<p>Теперь можно начинать чтение данных схемы из RDS. Мы вызываем
<span class="cpp"><a href="rdsctrlStartBlockByBlockSave.htm" title="Б.3.5.18. rdsctrlStartBlockByBlockSave &ndash; начать поблочное сохранение схемы">rdsctrlStartBlockByBlockSave</a></span> и, если она вернула ноль, завершаем функцию с
сообщением об ошибке: данные получить невозможно. Затем мы начинаем &laquo;бесконечный&raquo;
цикл <span class="cpp">for(;;)</span> &ndash; когда мы запишем все объекты схемы, мы прервем его оператором
<span class="cpp">break</span>. В цикле мы описываем некоторое количество вспомогательных переменных, после чего
вызываем функцию чтения данных очередного объекта схемы <span class="cpp"><a href="rdsctrlGetBlockByBlockSavePiece.htm" title="Б.3.5.4. rdsctrlGetBlockByBlockSavePiece &ndash; получить очередной объект при поблочном сохранении">rdsctrlGetBlockByBlockSavePiece</a></span>,
которая запишет тип объекта в переменную <span class="cpp">tag</span>, его идентификатор
&ndash; в переменную <span class="cpp">extid</span>, идентификатор родительской подсистемы &ndash; в
<span class="cpp">parentid</span> (здесь он нам не нужен, мы получаем его только для примера), а текст описания
объекта &ndash; в переменную <span class="cpp">text</span> типа <span class="cpp"><a href="pm_3_3.htm#ref3" title="Вспомогательный класс для хранения строк">TDynString</a></span> (при создании нашей
программы мы описали в ней класс <span class="cpp"><a class="hidden" href="pm_3_3.htm#ref3" title="Вспомогательный класс для хранения строк">TDynString</a></span> для хранения строк произвольной длины и
зарегистрировали в RdsCtrl.dll функцию записи строк в объекты этого класса,
см. <a href="pm_3_3.htm" title="&sect;3.3. Вызов функции блока загруженной схемы">&sect;3.3</a>). Если возвращенный функцией тип объекта
<span class="cpp">tag</span> равен нулю, то есть константе <span class="cpp">RDS_SFTAG_EOF</span>, мы прерываем
цикл: все объекты схемы считаны. В противном случае мы проверяем возвращенное текстовое описание на пустоту
(если описание объекта отсутствует, его незачем записывать в файл) и, если оно пустое, переходим в начало цикла
оператором <span class="cpp">continue</span>.</p>

<p>После того, как описание объекта считано, функцией <span class="cpp">sprintf</span> мы формируем в
массиве <span class="cpp">temp</span> из типа объекта и его идентификатора уникальное имя файла вида
&laquo;<span class="file"><i>тип</i>_<i>идентификатор</i>.obj</span>&raquo; Может показаться, что для уникальности имени файла
достаточно идентификатора объекта, но некоторые объекты схемы (стили связей и набор структур)
не имеют идентификаторов &ndash; для них возвращаются нулевые значения,
что совпадает с идентификатором корневой подсистемы. По этой причине мы добавляем к имени файла еще
и тип объекта &ndash; это сочетание всегда будет уникально. Кроме того, так мы по имени файла сразу сможем
понять, что за объект в нем находится. В массиве <span class="cpp">auxname</span> мы добавляем к имени
папки объектов <span class="cpp">dirname</span> созданное имя файла <span class="cpp">temp</span>, формируя,
таким образом, имя файла объекта с полным путем, и открываем этот файл для записи функцией
<span class="cpp">CreateFile</span>, присваивая полученный дескриптор переменной <span class="cpp">f</span>.
Затем мы записываем в открытый файл текст описания объекта из переменной <span class="cpp">text</span> функцией
<span class="cpp">WriteFile</span> и закрываем файл функцией <span class="cpp">CloseHandle</span>. Затем мы
проверяем успешность записи, сравнивая количество фактически записанных байтов с длиной строки и выводим сообщение
об ошибке при их несовпадении.</p>

<p>Теперь нам нужно дописать имя файла объекта без пути (<span class="cpp">temp</span>) в главный файл &ndash;
он сейчас открыт, и его дескриптор находится в переменной <span class="cpp">flist</span>. Мы записываем в
него содержимое строки <span class="cpp">temp</span> и символы перевода строки и возврата каретки
&laquo;\r\n&raquo;, которые обычно разделяют строки текстовых файлов. На этом тело цикла
<span class="cpp"></span> заканчивается.</p>

<p>После завершения цикла (то есть после записи всех объектов схемы) мы закрываем файл списка
<span class="cpp">flist</span> вызовом <span class="cpp"></span> и завершаем чтение данных схемы вызовом
<span class="cpp"><a href="rdsctrlEndBlockByBlockSave.htm" title="Б.3.5.3. rdsctrlEndBlockByBlockSave &ndash; завершить поблочное сохранение схемы">rdsctrlEndBlockByBlockSave</a></span>. На этом наша реакция заканчивается.</p>

<p>Таким образом, теперь, если пользователь нажмет в RDS <span class="keys">Ctrl</span>&nbsp;+&nbsp;<span class="keys">S</span>, наша управляющая программа
переместится на передний план и покажет диалог сохранения. Если пользователь выберет в нем файл для записи,
все объекты схемы запишутся в отдельные файлы в папку с именем выбранного пользователем файла и суффиксом
&laquo;.files&raquo;, а в сам файл запишется список этих объектов.</p>

<p>Теперь нам нужно выполнить обратную операцию: собрать схему из отдельных файлов объектов при нажатии
<span class="keys">Ctrl</span>&nbsp;+&nbsp;<span class="keys">O</span>. Мы зарегистрировали для этого функцию реакции
<span class="cpp">LoadRequestCallback</span>, но, прежде, чем мы ее напишем, нам нужно создать вспомогательную
функцию, которая будет загружать в память текстовый файл с заданным именем &ndash; она потребуется нам и
для загрузки файла со списком объектов, и для загрузки описаний самих объектов. Чтобы постоянно не отводить память
под очередной считываемый файл, мы будем передавать в функцию указатель на переменную, в которой будет храниться
указатель на динамически отведенный символьный буфер для файла, и указатель на переменную с текущим размером
этого буфера. Если буфер не отведен или его размер недостаточен для файла, который нужно считать, функция будет
самостоятельно отводить под него память оператором <span class="cpp">new[]</span> и корректировать значения переданных
ей переменных. Функция будет выглядеть так:</p>

<pre class="cpp">  <span class="rem">// Чтение текстового файла в память</span>
  <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> ReadFileToBuffer(
      <span class="kw">char</span> *filename, <span class="rem">// Имя файла</span>
      <span class="kw">char</span> **pBuffer, <span class="rem">// Указатель на указатель на буфер</span>
      <a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> *pSize)   <span class="rem">// Указатель на размер буфера</span>
  { HANDLE f;
    <a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> size,actread;
    <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> ok;

    <span class="rem">// Проверяем переданные параметры</span>
    <span class="kw">if</span>(pBuffer==NULL || pSize==NULL) <span class="rem">// Некуда загружать</span>
      <span class="kw">return</span> FALSE;

    <span class="rem">// Открываем файл для чтения</span>
    f=CreateFile(filename,GENERIC_READ,<span class="const">0</span>,NULL,OPEN_EXISTING,<span class="const">0</span>,NULL);
    <span class="kw">if</span>(f==INVALID_HANDLE_VALUE) <span class="rem">// Ошибка</span>
      <span class="kw">return</span> FALSE;

    <span class="rem">// Определяем размер файла</span>
    size=GetFileSize(f,NULL);
    <span class="kw">if</span>(size==<span class="const">0xFFFFFFFF</span>) <span class="rem">// Ошибка</span>
      { CloseHandle(f);
        <span class="kw">return</span> FALSE;
      }
    <span class="rem">// Переотводим буфер, если нужно</span>
    <span class="kw">if</span>((*pBuffer)==NULL || (*pSize)&lt;size+<span class="const">1</span>)
      { <span class="kw">if</span>(*pBuffer) <span class="rem">// Удаляем старый</span>
          <span class="kw">delete</span>[] (*pBuffer);
        *pBuffer=<span class="kw">new</span> <span class="kw">char</span>[*pSize=size+<span class="const">1</span>]; <span class="rem">// Отводим новый</span>
      }
    <span class="rem">// Читаем файл, если он не пустой</span>
    <span class="kw">if</span>(size)
      { <span class="kw">if</span>(ReadFile(f,*pBuffer,size,&amp;actread,NULL))
         ok=(actread==size);
        <span class="kw">else</span>
         ok=FALSE;
      }
    CloseHandle(f); <span class="rem">// Закрываем файл</span>
    (*pBuffer)[size]=<span class="const">0</span>; <span class="rem">// Дописываем 0, завершающий строку</span>
    <span class="kw">return</span> ok;
  }
  <span class="rem">//=========================================</span></pre>

<p>Эту функцию можно использовать следующим образом:</p>

<pre class="cpp">  <span class="kw">char</span> *buffer=NULL; <span class="rem">// Буфер (пока не отведен)</span>
  <a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> bufsize;     <span class="rem">// Размер буфера</span>
  <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> ok;
  &hellip;
  ok=ReadFileToBuffer(<span class="str">"file1.txt"</span>,&amp;buffer,&amp;bufsize);
  &hellip;
  ok=ReadFileToBuffer(<span class="str">"file2.txt"</span>,&amp;buffer,&amp;bufsize);
  &hellip;
  <span class="kw">if</span>(buffer) <span class="kw">delete</span>[] buffer;</pre>

<p>Сначала мы описываем указатель типа <span class="cpp">char*</span> на динамически отводимый буфер и
присваиваем ему <span class="cpp">NULL</span> &ndash; это даст функции понять, что буфер еще не отведен.
Для хранения текущего размера буфера мы вводим переменную <span class="cpp"></span> типа
<span class="cpp"><a href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a></span>. После этого мы можем произвольное число раз вызывать функцию
<span class="cpp">ReadFileToBuffer</span>, передавая ей указатели на <span class="cpp">buffer</span> и
<span class="cpp">bufsize</span>. Если очередной считываемый файл умещается в текущий буфер, функция просто
загрузит его туда. Если же файл не умещается или буфер еще не отводился
(<span class="cpp">buffer==NULL</span>), функция перед чтением отведет буфер заново и скорректирует
<span class="cpp"></span> и <span class="cpp">bufsize</span> так, что они будут соответствовать новому буферу.
После того, как работа с файлами завершена, буфер нужно будет освободить оператором <span class="cpp">delete[]</span>.</p>

<p>Теперь мы можем написать функцию реакции <span class="cpp">LoadRequestCallback</span>. Как и
<span class="cpp">SaveRequestCallback</span>, ее нужно разместить перед функцией <span class="cpp">RegisterEvents</span>.</p>

<pre class="cpp">  <span class="rem">// Реакция на событие – пользователь нажал "загрузить"</span>
  <span class="kw">void</span> <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> LoadRequestCallback(<span class="kw">int</span> link,<span class="kw">int</span> event,
          <a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> edata,<a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> aux)
  { <span class="rem">// Массивы для работы с именами файлов</span>
    <span class="kw">char</span> filename[MAX_PATH+<span class="const">1</span>]=<span class="str">""</span>,
         temp[MAX_PATH+<span class="const">1</span>],
         dirname[MAX_PATH+<span class="const">1</span>],
         auxname[MAX_PATH+<span class="const">1</span>];
    OPENFILENAME ofn;
    <span class="kw">char</span> *List=NULL,*Text=NULL,*fn;
    <a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> ListSize=<span class="const">0</span>,TextSize=<span class="const">0</span>;
    <span class="kw">int</span> dirlen,tag;
    <a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> attr;

    <span class="rem">// Заполняем структуру OPENFILENAME</span>
    ZeroMemory(&amp;ofn,<span class="kw">sizeof</span>(ofn));
    ofn.lStructSize=<span class="kw">sizeof</span>(ofn);
    ofn.hwndOwner=MainWin;
    ofn.lpstrFile=filename;
    ofn.nMaxFile=<span class="kw">sizeof</span>(filename);
    ofn.lpstrFilter=<span class="str">"Спецформат (*.spc)\0*.spc\0Все файлы\0*.*\0"</span>;
    ofn.nFilterIndex=<span class="const">1</span>;
    ofn.Flags=OFN_EXPLORER | OFN_FILEMUSTEXIST;

    <span class="rem">// Помещаем наше приложение на передний план</span>
    BringAppToTop();

    <span class="rem">// Вызываем стандартный диалог открытия</span>
    <span class="kw">if</span>(!GetOpenFileName(&amp;ofn))
      <span class="kw">return</span>;
    <span class="rem">// Пользователь выбрал файл filename</span>

    <span class="rem">// Формируем из имени файла имя папки объектов</span>
    <span class="kw">if</span>(strlen(filename)&gt;MAX_PATH+<span class="const">8</span>)
      { DisplayText(<span class="str">"Слишком длинный путь"</span>);
        <span class="kw">return</span>;
      }
    strcpy(dirname,filename);
    strcat(dirname,<span class="str">".files"</span>);
    <span class="rem">// Проверяем есть ли папка</span>
    attr=GetFileAttributes(dirname);
    <span class="kw">if</span>(attr==<span class="const">0xFFFFFFFF</span> || (attr &amp; FILE_ATTRIBUTE_DIRECTORY)==<span class="const">0</span>)
      { DisplayText(<span class="str">"Отсутстует папка объектов"</span>);
        <span class="kw">return</span>;
      }
    strcat(dirname,<span class="str">"&#92;&#92;"</span>); <span class="rem">// Добавляем "&#92;" в конец имени</span>
    dirlen=strlen(dirname); <span class="rem">// Длина пути к папке</span>

    <span class="rem">// Считываем файл со списком объектов в буфер List</span>
    <span class="kw">if</span>(!ReadFileToBuffer(filename,&amp;List,&amp;ListSize))
      { DisplayText(<span class="str">"Ошибка чтения списка файлов"</span>);
        <span class="kw">if</span>(List) <span class="kw">delete</span>[] List;
        <span class="kw">return</span>;
      }
    <span class="rem">// Список считан в буфер – разбираем его и грузим объекты</span>

    <span class="rem">// Начинаем загрузку в RDS</span>
    <a class="hidden" href="rdsctrlStartBlockByBlockLoad.htm" title="Б.3.5.18. rdsctrlStartBlockByBlockLoad &ndash; начать поблочную загрузку схемы">rdsctrlStartBlockByBlockLoad</a>(RdsLink,<span class="const">0</span>);

    <span class="rem">// В цикле берем из списка имя за именем</span>
    fn=List;
    <span class="kw">for</span>(;;)
      { <span class="kw">int</span> n;
        <span class="rem">// Пропускаем пустые строки, если они есть</span>
        fn+=strspn(fn,<span class="str">"\r\n"</span>);
        <span class="rem">// Определяем длину до перевода строки</span>
        n=strcspn(fn,<span class="str">"\r\n"</span>); <span class="rem">// В n – длина имени файла</span>
        <span class="kw">if</span>(n==<span class="const">0</span>) <span class="rem">// Список кончился</span>
          <span class="kw">break</span>;
        <span class="kw">if</span>(n+dirlen&gt;MAX_PATH)
          { DisplayText(<span class="str">"Слишком длинный путь"</span>);
            <span class="kw">break</span>;
          }
        <span class="rem">// Копируем имя файла объекта (без пути) в temp</span>
        strncpy(temp,fn,n);
        temp[n]=<span class="const">0</span>;
        fn+=n; <span class="rem">// Продвигаем указатель на следующее имя файла</span>
        <span class="rem">// Формируем в auxname полный путь к файлу объекта</span>
        strcpy(auxname,dirname);
        strcat(auxname,temp);
        <span class="rem">// Считываем файл объекта в буфер Text</span>
        <span class="kw">if</span>(!ReadFileToBuffer(auxname,&amp;Text,&amp;TextSize))
          { DisplayText(<span class="str">"Ошибка чтения файла объекта"</span>);
            <span class="kw">break</span>;
          }
        <span class="rem">// Файл считан – передаем описание объекта в RDS</span>
        tag=atoi(temp); <span class="rem">// Тип объекта – первое число в имени файла</span>
        <a class="hidden" href="rdsctrlSetBlockByBlockLoadPiece.htm" title="Б.3.5.16. rdsctrlSetBlockByBlockLoadPiece &ndash; передать очередной объект при поблочной загрузке">rdsctrlSetBlockByBlockLoadPiece</a>(RdsLink,tag,Text);
      }

    <span class="rem">// Освобождаем буферы</span>
    <span class="kw">if</span>(List) <span class="kw">delete</span>[] List;
    <span class="kw">if</span>(Text) <span class="kw">delete</span>[] Text;

    <span class="rem">// Все считано – собираем схему из объектов</span>
    <span class="kw">if</span>(!<a class="hidden" href="rdsctrlEndBlockByBlockLoad.htm" title="Б.3.5.2. rdsctrlEndBlockByBlockLoad &ndash; завершить поблочную загрузку схемы">rdsctrlEndBlockByBlockLoad</a>(RdsLink,TRUE))
      DisplayText(<span class="str">"Ошибка сборки загруженных данных"</span>);
  }
  <span class="rem">//=========================================</span></pre>

<p>Начало этой функции очень похоже на <span class="cpp">SaveRequestCallback</span>: здесь мы тоже помещаем
окно нашей программы на передний план и открываем диалог, но только не диалог сохранения, а диалог открытия
файла. Затем мы уже описанными способом формируем имя папки объектов из имени выбранного пользователем файла
и проверяем существование этой папки &ndash; если ее нет, загрузка невозможна.</p>

<p>Далее мы загружаем файл, выбранный пользователем, в текстовый буфер <span class="cpp">List</span> функцией
<span class="cpp">ReadFileToBuffer</span> и начинаем поблочную загрузку схемы функцией
<span class="cpp"><a href="rdsctrlStartBlockByBlockLoad.htm" title="Б.3.5.18. rdsctrlStartBlockByBlockLoad &ndash; начать поблочную загрузку схемы">rdsctrlStartBlockByBlockLoad</a></span>. Далее в цикле <span class="cpp">for(;;)</span> мы берем
из загруженного списка по одному имени, используя для поиска символов перевода строки, отделяющих одно имя
от другого, стандартные функции работы со строками <span class="cpp">strspn</span> и <span class="cpp">strcspn</span>.
Мы не будем подробно останавливаться на работе этих функций, желающие могут найти их подробные описания в справочниках
по языку C. В результате этих манипуляций со строками в переменной <span class="cpp">fn</span> окажется указатель
на начало очередного имени файла, а в переменной <span class="cpp">n</span> &ndash; длина этого имени. Если
<span class="cpp">n</span> равно нулю, значит, список кончился &ndash; в этом случае мы прерываем цикл оператором
<span class="cpp">break</span>. В противном случае мы копируем имя файла в массив <span class="cpp">temp</span> и
продвигаем <span class="cpp">fn</span> на <span class="cpp">n</span> символов вперед, то есть на начало следующего
имени файла. Затем в массиве <span class="cpp">auxname</span> мы формируем полный путь к файлу объекта, добавляя
путь к папке объектов <span class="cpp">dirname</span> к считанному из списка имени файла <span class="cpp">temp</span>,
и загружаем этот файл в буфер <span class="cpp">Text</span> вызовом <span class="cpp">ReadFileToBuffer</span>. Мы
специально написали эту функцию так, чтобы она, при необходимости, увеличивала размер буфера, поэтому мы все время
передаем в нее указатели на переменные <span class="cpp">Text</span> (указатель на буфер) и
<span class="cpp">TextSize</span> (текущий размер буфера), а она сама изменит их значения, если очередной
загружаемый файл не уместится в буфер.</p>

<p>После того, как файл объекта загружен, мы получаем тип этого объекта <span class="cpp">tag</span> из
имени файла при помощи стандартной функции преобразования строки в число <span class="cpp">atoi</span>: имена файлов
объектов мы формируем из типа и идентификатора, разделенных подчеркиванием, поэтому первое число в имени
файла будет типом объекта. Тип загруженного объекта <span class="cpp">tag</span> и его текстовое описание
<span class="cpp">Text</span> мы передаем в RdsCtrl.dll вызовом
<span class="cpp"><a href="rdsctrlSetBlockByBlockLoadPiece.htm" title="Б.3.5.16. rdsctrlSetBlockByBlockLoadPiece &ndash; передать очередной объект при поблочной загрузке">rdsctrlSetBlockByBlockLoadPiece</a></span> и заканчиваем тело цикла, то есть переходим к
загрузке следующего объекта из списка.</p>

<p>После завершения цикла <span class="cpp">for(;;)</span> мы освобождаем оба использованных для загрузки
файлов буфера операторами <span class="cpp">delete[]</span> и, вызвав
<span class="cpp"><a href="rdsctrlEndBlockByBlockLoad.htm" title="Б.3.5.2. rdsctrlEndBlockByBlockLoad &ndash; завершить поблочную загрузку схемы">rdsctrlEndBlockByBlockLoad</a></span> с параметром <span class="cpp">TRUE</span>, даем команду
собрать схему из загруженных объектов. В случае ошибки функция вернет <span class="cpp">FALSE</span>, и мы
выведем сообщение пользователю функцией <span class="cpp">DisplayText</span>.</p>

<p>Теперь при нажатии <span class="keys">Ctrl</span>&nbsp;+&nbsp;<span class="keys">O</span> в RDS наше приложение будет выходить на передний
план и показывать диалог открытия файла. Если пользователь выберет в этом диалоге какой-нибудь из файлов,
сохраненных ранее при помощи <span class="keys">Ctrl</span>&nbsp;+&nbsp;<span class="keys">S</span> (мы используем для них расширения &laquo;<span class="file">spc</span>&raquo;),
наша программа соберет в RDS схему из отдельных файлов объектов, список которых находится в выбранном
пользователем файле.</p>

<p>Рассмотренный пример имеет множество недостатков. Например, если пользователь загрузит сохраненную
таким образом схему, удалит какой-нибудь блок и снова сохранит ее, файл объекта, соответствующий удаленному блоку,
не будет стерт. Тем не менее, он иллюстрирует основные методы перехвата загрузки и сохранения схемы, разборку
схемы на отдельные объекты и ее повторную сборку из них, которые могут быть полезны при включении
RDS в состав каких-либо программных комплексов.</p>

<p>Нужно отметить, что, помимо рассмотренного метода сохранения и загрузки схемы в виде набора объектов,
можно также использовать функции <span class="cpp"><a href="rdsctrlSaveSystemTagged.htm" title="Б.3.5.12. rdsctrlSaveSystemTagged &ndash; записать схему в файл в специальном двоичном формате">rdsctrlSaveSystemTagged</a></span> /
<span class="cpp"><a href="rdsctrlLoadSystemTagged.htm" title="Б.3.5.8. rdsctrlLoadSystemTagged &ndash; загрузить схему из файла в специальном двоичном формате">rdsctrlLoadSystemTagged</a></span> и их расширенные версии с похожими названиями, которые подробно описаны
в <a href="app_index.htm#light_htm:app_b_3_5" title="Б.3.5. Функции загрузки и сохранения схемы">приложении Б.3.5</a>.
Эти функции позволяют сразу записать весь набор объектов в файл или разделяемую область памяти и загрузить их
оттуда &ndash; в некоторых случаях это удобнее, чем получать из RdsCtrl.dll по одному объекту за вызов.
Разработчик управляющего приложения может использовать любые из этих функций или их комбинации.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="pm_3_4.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="pm_3_6_1.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="pm_index.htm#light_htm:pm_3_5">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
