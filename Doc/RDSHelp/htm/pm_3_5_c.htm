<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.5. Вмешательство в загрузку и сохранение схемы</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="pm_index.htm">Руководство программиста</a></p>
<div class="level"><p><a href="pm_index.htm#light_htm:pm_3">Глава 3. Управление RDS из других приложений</a></p>
<div class="level"><p>&sect;3.5. Вмешательство в загрузку и сохранение схемы</p>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="pm_3_4.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="pm_3_6_1.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="pm_index.htm#light_htm:pm_3_5">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
<div class="right">
<span class="tab"><a href="pm_3_5.htm">Текст</a></span>
<span class="curtab">С++</span>
</div>
</div>

<div class="text">

p>Полный исходный текст приложения Windows, управляющего RDS через библиотеку RdsCtrl.dll.
Приложение перехватывает команды загрузки и сохранения схемы, выполняя их самостоятельно.</p>

<p>Изменения относительно приложения, рассмотренного в
<a href="pm_3_4.htm" title="&sect;3.4. Реакция на события и сообщения от блоков">&sect;3.4</a>, выделены <span class="changes">цветом</span>.</p>

<pre class="cpp">  <span class="rem">// Управляющее приложение (передача данных блоку)</span>
  <span class="rem">// Скомпилированный EXE должен запускаться из папки RDS</span>
  <span class="rem">//=====================================================================</span>
  <span class="rem">// Описания, необходимые для используемого компилятора</span>
  <span class="rem">// (в других компиляторах они не понадобятся или будут другими)</span>
  <span class="preproc">#define _WIN32_WINNT 0x0400</span>
  <span class="preproc">#define WINVER 0x0400</span>
  <span class="rem">// Необходимые для приложения файлы заголовков</span>
  <span class="preproc">#include &lt;windows.h&gt;</span>
  <span class="preproc">#include &lt;Commctrl.h&gt;</span>
  <span class="preproc">#include &lt;stdio.h&gt;</span>
  <span class="rem">//=========================================</span>
  <span class="rem">// Описания, необходимые для работы с RdsCtrl.dll</span>
  <a class="hidden" href="pm_3_2.htm#ref3" title="Доступ к функциям библиотеки RdsCtrl.dll"><span class="preproc">#define RDSCTRL_SERV_FUNC_BODY GetRdsCtrlFuncs</span></a>
  <span class="preproc">#include &lt;RdsCtrl.h&gt;</span>
  <span class="rem">//=========================================</span>

  <span class="rem">// Вспомогательный класс для более удобного хранения</span>
  <span class="rem">// строк произвольной длины</span>
  <span class="kw">class</span> <a class="hidden" href="pm_3_3.htm#ref3" title="Вспомогательный класс для хранения строк">TDynString</a>
  { <span class="kw">public</span>:
      <span class="rem">// Указатель на динамическую строку</span>
      <span class="kw">char</span> *c_str;
      <span class="rem">// Освободить память</span>
      <span class="kw">void</span> Free(<span class="kw">void</span>)
        { <span class="kw">if</span>(c_str) <span class="kw">delete</span>[] c_str;
          c_str=NULL; };
      <span class="rem">// Записать строку в объект</span>
      <span class="kw">void</span> Set(<span class="kw">char</span> *s)
        { Free(); <span class="rem">// Освободить старую</span>
          <span class="kw">if</span>(s!=NULL) <span class="rem">// Отвести память и скопировать новую</span>
            { c_str=<span class="kw">new</span> <span class="kw">char</span>[strlen(s)+<span class="const">1</span>];
              strcpy(c_str,s);
            }
        };
      <span class="rem">// Строка пустая?</span>
      <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> IsEmpty(<span class="kw">void</span>)
        { <span class="kw">return</span> c_str==NULL || (*c_str)==<span class="const">0</span>;};
      <span class="rem">// Конструктор и деструктор</span>
      TDynString(<span class="kw">void</span>){c_str=NULL;};
      ~TDynString(){Free();};
  };
  <span class="rem">//=========================================</span>

  <span class="rem">// Идентификаторы кнопок и полей окна программы</span>
  <span class="preproc">#define IDC_OPENBUTTON  101</span>
  <span class="preproc">#define IDC_CLOSEBUTTON 102</span>
  <span class="preproc">#define IDC_LABEL1      103</span>
  <span class="preproc">#define IDC_LABEL2      104</span>
  <span class="preproc">#define IDC_LABEL3      105</span>
  <span class="preproc">#define IDC_BLKNAMEEDIT 106</span>
  <span class="preproc">#define IDC_VALUEEDIT   107</span>
  <span class="preproc">#define IDC_STRINGEDIT  108</span>
  <span class="preproc">#define IDC_CALLBUTTON  109</span>
  <span class="preproc">#define IDC_STARTBUTTON 110</span>
  <span class="preproc">#define IDC_STOPBUTTON  111</span>
  <span class="preproc">#define IDC_FINDBUTTON  112</span>
  <span class="rem">//=========================================</span>

  <span class="rem">// Буфер для индицируемого программой текста</span>
  <span class="kw">char</span> buffer[<span class="const">2000</span>]=<span class="str">"Программа запущена"</span>;
  <span class="rem">// Главное окно программы (для доступа к нему из функций)</span>
  <a class="hidden" href="app_ids.htm#light_ref18" title="Дескриптор окна">HWND</a> MainWin;
  <span class="rem">//=========================================</span>
  <span class="rem">// Глобальные переменные для связи с RDS</span>
  HMODULE RdsCtrl=NULL; <span class="rem">// Модуль библиотеки RdsCtrl.dll</span>
  <span class="kw">int</span> RdsLink=-<span class="const">1</span>;       <span class="rem">// Связь с RDS</span>
  <span class="rem">//=========================================</span>

<div class="changes">  <span class="rem">// "Вытаскивание" приложения на передний план</span>
  <span class="kw">void</span> BringAppToTop(<span class="kw">void</span>)
  { <a class="hidden" href="app_ids.htm#light_ref18" title="Дескриптор окна">HWND</a> hCurrWnd;
    <span class="kw">int</span> iMyTID;
    <span class="kw">int</span> iCurrTID;
    hCurrWnd=GetForegroundWindow();
    iMyTID=GetCurrentThreadId();
    iCurrTID=GetWindowThreadProcessId(hCurrWnd,<span class="const">0</span>);
    AttachThreadInput(iMyTID,iCurrTID,TRUE);
    SetForegroundWindow(MainWin);
    AttachThreadInput(iMyTID,iCurrTID,FALSE);
  }
  <span class="rem">//=========================================</span></div>
<div class="changes">  <span class="rem">// Чтение текстового файла в память</span>
  <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> ReadFileToBuffer(
      <span class="kw">char</span> *filename, <span class="rem">// Имя файла</span>
      <span class="kw">char</span> **pBuffer, <span class="rem">// Указатель на указатель на буфер</span>
      <a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> *pSize)   <span class="rem">// Указатель на размер буфера</span>
  { HANDLE f;
    <a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> size,actread;
    <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> ok;

    <span class="rem">// Проверяем переданные параметры</span>
    <span class="kw">if</span>(pBuffer==NULL || pSize==NULL) <span class="rem">// Некуда загружать</span>
      <span class="kw">return</span> FALSE;

    <span class="rem">// Открываем файл для чтения</span>
    f=CreateFile(filename,GENERIC_READ,<span class="const">0</span>,NULL,OPEN_EXISTING,<span class="const">0</span>,NULL);
    <span class="kw">if</span>(f==INVALID_HANDLE_VALUE) <span class="rem">// Ошибка</span>
      <span class="kw">return</span> FALSE;

    <span class="rem">// Определяем размер файла</span>
    size=GetFileSize(f,NULL);
    <span class="kw">if</span>(size==<span class="const">0xFFFFFFFF</span>) <span class="rem">// Ошибка</span>
      { CloseHandle(f);
        <span class="kw">return</span> FALSE;
      }
    <span class="rem">// Переотводим буфер, если нужно</span>
    <span class="kw">if</span>((*pBuffer)==NULL || (*pSize)&lt;size+<span class="const">1</span>)
      { <span class="kw">if</span>(*pBuffer) <span class="rem">// Удаляем старый</span>
          <span class="kw">delete</span>[] (*pBuffer);
        *pBuffer=<span class="kw">new</span> <span class="kw">char</span>[*pSize=size+<span class="const">1</span>]; <span class="rem">// Отводим новый</span>
      }
    <span class="rem">// Читаем файл, если он не пустой</span>
    <span class="kw">if</span>(size)
      { <span class="kw">if</span>(ReadFile(f,*pBuffer,size,&amp;actread,NULL))
         ok=(actread==size);
        <span class="kw">else</span>
         ok=FALSE;
      }
    CloseHandle(f); <span class="rem">// Закрываем файл</span>
    (*pBuffer)[size]=<span class="const">0</span>; <span class="rem">// Дописываем 0, завершающий строку</span>
    <span class="kw">return</span> ok;
  }
  <span class="rem">//=========================================</span></div>
  <span class="rem">// Функция вывода текстового сообщения в окне программы</span>
  <span class="kw">void</span> DisplayText(<span class="kw">char</span> *text)
  { <a class="hidden" href="app_ids.htm#light_ref23" title="Координаты прямоугольника в Windows API">RECT</a> rect;
    <span class="rem">// Определяем размер клиентской области окна</span>
    GetClientRect(MainWin,&amp;rect);
    <span class="rem">// Ограничиваем область снизу (ниже будут располагаться кнопки)</span>
    rect.bottom=<span class="const">30</span>;
    <span class="kw">if</span>(text) <span class="rem">// Копируем текст в буфер</span>
      { strncpy(buffer,text,<span class="kw">sizeof</span>(buffer)-<span class="const">1</span>);
        buffer[<span class="kw">sizeof</span>(buffer)-<span class="const">1</span>]=<span class="const">0</span>; <span class="rem">// Если строка слишком длинная</span>
      }
    <span class="kw">else</span>
      strcpy(buffer,<span class="str">"(NULL)"</span>);
    <span class="rem">// Указываем Windows, что область rect нужно перерисовать</span>
    InvalidateRect(MainWin,&amp;rect,TRUE);
  }
  <span class="rem">//=========================================</span>

  <span class="rem">// Отклик на событие - завершение RDS</span>
  <span class="kw">void</span> <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> RdsExitEvent(<span class="kw">int</span> Link,<span class="kw">int</span> Event,
        <a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> EvData,<a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> AuxData)
  {
    DisplayText(<span class="str">"Процесс RDS завершился"</span>);
  }
  <span class="rem">//=========================================</span>

  <span class="rem">// Отклик на событие – запуск и остановка расчета</span>
  <span class="kw">void</span> <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> CalcStartStopEvent(<span class="kw">int</span> Link,<span class="kw">int</span> Event,
        <a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> EvData,<a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> AuxData)
  {
    <span class="kw">switch</span>(Event)
      { <span class="kw">case</span> <a class="hidden" href="RDSCTRLEVENT_CALCSTART.htm" title="Б.2.4. RDSCTRLEVENT_CALCSTART &ndash; запуск расчета">RDSCTRLEVENT_CALCSTART</a>: <span class="rem">// Запуск</span>
          DisplayText(<span class="str">"Расчет запущен"</span>);
          <span class="kw">break</span>;
        <span class="kw">case</span> <a class="hidden" href="RDSCTRLEVENT_CALCSTOP.htm" title="Б.2.5. RDSCTRLEVENT_CALCSTOP &ndash; остановка расчета">RDSCTRLEVENT_CALCSTOP</a>:  <span class="rem">// Остановка</span>
          DisplayText(<span class="str">"Расчет остановлен"</span>);
          <span class="kw">break</span>;
      }
  }
  <span class="rem">//=========================================</span>

  <span class="rem">// Отклик на событие – сообщение от блока</span>
  <span class="kw">void</span> <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> BlockMsgEvent(<span class="kw">int</span> Link,<a class="hidden" href="app_ids.htm#light_ref20" title="Указатель на строку (char*)">LPSTR</a> BlockName,
    <span class="kw">int</span> IMsg,<a class="hidden" href="app_ids.htm#light_ref20" title="Указатель на строку (char*)">LPSTR</a> SMsg,<a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> AuxData)
  {
    <span class="rem">// Заносим имя блока в одноименное поле ввода</span>
    SetDlgItemText(MainWin,IDC_BLKNAMEEDIT,BlockName);
    <span class="rem">// Заносим IMsg в поле ввода "число"</span>
    SetDlgItemInt(MainWin,IDC_VALUEEDIT,IMsg,TRUE);
    <span class="rem">// Заносим полученный текст в поле ввода "строка"</span>
    SetDlgItemText(MainWin,IDC_STRINGEDIT,SMsg);

    DisplayText(<span class="str">"Получено сообщение от блока"</span>);
  }
  <span class="rem">//=========================================</span>

<div class="changes">  <span class="rem">// Реакция на событие – пользователь нажал "сохранить"</span>
  <span class="kw">void</span> <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> SaveRequestCallback(<span class="kw">int</span> link,<span class="kw">int</span> event,
          <a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> edata,<a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> aux)
  { <span class="rem">// Массивы для работы с именами файлов</span>
    <span class="kw">char</span> filename[MAX_PATH+<span class="const">1</span>]=<span class="str">""</span>,
         dirname[MAX_PATH+<span class="const">1</span>],
         auxname[MAX_PATH+<span class="const">1</span>],
         temp[MAX_PATH+<span class="const">1</span>],
         *s;
    OPENFILENAME ofn;
    <a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> attr;
    HANDLE flist;
    <span class="kw">int</span> dirlen;

    <span class="rem">// Помещаем наше приложение на передний план</span>
    BringAppToTop();

    <span class="rem">// Заполняем структуру OPENFILENAME для диалога сохранения</span>
    ZeroMemory(&amp;ofn,<span class="kw">sizeof</span>(ofn));
    ofn.lStructSize=<span class="kw">sizeof</span>(ofn);
    ofn.hwndOwner=MainWin;
    ofn.lpstrFile=filename;
    ofn.nMaxFile=<span class="kw">sizeof</span>(filename);
    ofn.lpstrFilter=<span class="str">"Спецформат (*.spc)\0*.spc\0Все файлы\0*.*\0"</span>;
    ofn.lpstrDefExt=<span class="str">"spc"</span>;
    ofn.nFilterIndex=<span class="const">1</span>;
    ofn.Flags=OFN_EXPLORER | OFN_OVERWRITEPROMPT;
    <span class="rem">// Вызываем стандартный диалог сохранения Windows</span>
    <span class="kw">if</span>(!GetSaveFileName(&amp;ofn))
      <span class="kw">return</span>;
    <span class="rem">// Пользователь выбрал в диалоге имя файла, оно записано в</span>
    <span class="rem">// массив filename. В этот файл мы запишем список всех</span>
    <span class="rem">// имен файлов объектов</span>

    <span class="rem">// Файлы объектов будут записаны в подпапку filename+".files"</span>
    <span class="rem">// (рядом с файлом filename)</span>
    <span class="kw">if</span>(strlen(filename)&gt;MAX_PATH+<span class="const">8</span>)
      { DisplayText(<span class="str">"Слишком длинный путь"</span>);
        <span class="kw">return</span>;
      }
    strcpy(dirname,filename);
    strcat(dirname,<span class="str">".files"</span>);
    <span class="rem">// В массиве dirname теперь находится имя подпапки объектов</span>
    CreateDirectory(dirname,NULL); <span class="rem">// Создаем эту папку</span>
    <span class="rem">// Проверяем, создалась ли папка</span>
    attr=GetFileAttributes(dirname);
    <span class="kw">if</span>(attr==<span class="const">0xFFFFFFFF</span> || (attr &amp; FILE_ATTRIBUTE_DIRECTORY)==<span class="const">0</span>)
      { <span class="rem">// Папка с именем dirname не существует</span>
        DisplayText(<span class="str">"Невозможно создать папку"</span>);
        <span class="kw">return</span>;
      }
    <span class="rem">// Папка есть (создана или существовала раньше)</span>
    strcat(dirname,<span class="str">"&#92;&#92;"</span>); <span class="rem">// Добавляем разделитель в конец имени</span>
    dirlen=strlen(dirname); <span class="rem">// Длина имени папки с завершающим разделителем</span>

    <span class="rem">// В файл filename мы будем записывать имена файлов объектов</span>
    <span class="rem">// без пути – по одному на строчку</span>

    <span class="rem">// Открываем файл списка для записи</span>
    flist=CreateFile(filename,GENERIC_WRITE,<span class="const">0</span>,NULL,
        CREATE_ALWAYS,<span class="const">0</span>,NULL);
    <span class="kw">if</span>(flist==INVALID_HANDLE_VALUE) <span class="rem">// Ошибка открытия файла</span>
      { DisplayText(<span class="str">"Невозможно записать главный файл"</span>);
        <span class="kw">return</span>;
      }

    <span class="rem">// Начинаем чтение содержимого схемы из RDS</span>
    <span class="kw">if</span>(!<a class="hidden" href="rdsctrlStartBlockByBlockSave.htm" title="Б.3.5.18. rdsctrlStartBlockByBlockSave &ndash; начать поблочное сохранение схемы">rdsctrlStartBlockByBlockSave</a>(RdsLink,<span class="const">0</span>))
      { DisplayText(<span class="str">"Невозможно получить данные"</span>);
        CloseHandle(flist);
        <span class="kw">return</span>;
      }

    <span class="rem">// Читаем данные, пока функция не вернет нулевой тип блока</span>
    <span class="kw">for</span>(;;)
      { <a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> extid,parentid,res,size;
        <a class="hidden" href="pm_3_3.htm#ref3" title="Вспомогательный класс для хранения строк">TDynString</a> text;
        HANDLE f;
        <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> ok;
        <span class="rem">// Получаем из RDS данные очередного объекта</span>
        <span class="kw">int</span> tag=<a class="hidden" href="rdsctrlGetBlockByBlockSavePiece.htm" title="Б.3.5.4. rdsctrlGetBlockByBlockSavePiece &ndash; получить очередной объект при поблочном сохранении">rdsctrlGetBlockByBlockSavePiece</a>(RdsLink,
            &amp;extid,&amp;parentid,&amp;text);
        <span class="kw">if</span>(tag==<span class="const">0</span>) <span class="rem">// Данные кончились</span>
          <span class="kw">break</span>;
        <span class="kw">if</span>(text.IsEmpty()) <span class="rem">// Возвращенный текст описания пуст</span>
          <span class="kw">continue</span>;
        <span class="rem">// Формируем имя файла из типа tag и идентификатора extid</span>
        sprintf(temp,<span class="str">"%d_%u.obj"</span>,tag,extid);
        <span class="kw">if</span>(strlen(temp)+dirlen&gt;MAX_PATH)
          { DisplayText(<span class="str">"слишком длинный путь"</span>);
            <span class="kw">break</span>;
          }
        <span class="rem">// Добавляем к имени файла путь к папке dirname</span>
        strcpy(auxname,dirname);
        strcat(auxname,temp);
        <span class="rem">// Записываем текст text в файл auxname</span>
        f=CreateFile(auxname,GENERIC_WRITE,<span class="const">0</span>,NULL,CREATE_ALWAYS,
          <span class="const">0</span>,NULL);
        <span class="kw">if</span>(f==INVALID_HANDLE_VALUE)
          { DisplayText(<span class="str">"Невозможно записать файл объекта"</span>);
            <span class="kw">break</span>;
          }
        size=strlen(text.c_str); <span class="rem">// Размер текста</span>
        ok=WriteFile(f,text.c_str,size,&amp;res,NULL);
        CloseHandle(f);
        <span class="kw">if</span>((!ok) || res!=size)
          { DisplayText(<span class="str">"Ошибка записи файла объекта"</span>);
            <span class="kw">break</span>;
          }
        <span class="rem">// Дописываем имя файла (temp) в главный файл-список</span>
        size=strlen(temp); <span class="rem">// Длина имени файла</span>
        ok=WriteFile(flist,temp,size,&amp;res,NULL);
        <span class="kw">if</span>(res!=size) ok=FALSE;
        <span class="rem">// После имени записываем перевод строки и возврат каретки</span>
        ok=ok &amp;&amp; WriteFile(flist,<span class="str">"\r\n"</span>,<span class="const">2</span>,&amp;res,NULL);
        <span class="kw">if</span>(res!=<span class="const">2</span>) ok=FALSE;
        <span class="kw">if</span>(!ok)
          DisplayText(<span class="str">"Ошибка записи имени в список"</span>);
      }
    <span class="rem">// Закрываем файл списка</span>
    CloseHandle(flist);
    <span class="rem">// Завершаем чтение данных схемы</span>
    <a class="hidden" href="rdsctrlEndBlockByBlockSave.htm" title="Б.3.5.3. rdsctrlEndBlockByBlockSave &ndash; завершить поблочное сохранение схемы">rdsctrlEndBlockByBlockSave</a>(RdsLink);
  }
  <span class="rem">//=========================================</span></div>
<div class="changes">  <span class="rem">// Реакция на событие – пользователь нажал "загрузить"</span>
  <span class="kw">void</span> <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> LoadRequestCallback(<span class="kw">int</span> link,<span class="kw">int</span> event,
          <a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> edata,<a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> aux)
  { <span class="rem">// Массивы для работы с именами файлов</span>
    <span class="kw">char</span> filename[MAX_PATH+<span class="const">1</span>]=<span class="str">""</span>,
         temp[MAX_PATH+<span class="const">1</span>],
         dirname[MAX_PATH+<span class="const">1</span>],
         auxname[MAX_PATH+<span class="const">1</span>];
    OPENFILENAME ofn;
    <span class="kw">char</span> *List=NULL,*Text=NULL,*fn;
    <a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> ListSize=<span class="const">0</span>,TextSize=<span class="const">0</span>;
    <span class="kw">int</span> dirlen,tag;
    <a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> attr;

    <span class="rem">// Заполняем структуру OPENFILENAME</span>
    ZeroMemory(&amp;ofn,<span class="kw">sizeof</span>(ofn));
    ofn.lStructSize=<span class="kw">sizeof</span>(ofn);
    ofn.hwndOwner=MainWin;
    ofn.lpstrFile=filename;
    ofn.nMaxFile=<span class="kw">sizeof</span>(filename);
    ofn.lpstrFilter=<span class="str">"Спецформат (*.spc)\0*.spc\0Все файлы\0*.*\0"</span>;
    ofn.nFilterIndex=<span class="const">1</span>;
    ofn.Flags=OFN_EXPLORER | OFN_FILEMUSTEXIST;

    <span class="rem">// Помещаем наше приложение на передний план</span>
    BringAppToTop();

    <span class="rem">// Вызываем стандартный диалог открытия</span>
    <span class="kw">if</span>(!GetOpenFileName(&amp;ofn))
      <span class="kw">return</span>;
    <span class="rem">// Пользователь выбрал файл filename</span>

    <span class="rem">// Формируем из имени файла имя папки объектов</span>
    <span class="kw">if</span>(strlen(filename)&gt;MAX_PATH+<span class="const">8</span>)
      { DisplayText(<span class="str">"Слишком длинный путь"</span>);
        <span class="kw">return</span>;
      }
    strcpy(dirname,filename);
    strcat(dirname,<span class="str">".files"</span>);
    <span class="rem">// Проверяем есть ли папка</span>
    attr=GetFileAttributes(dirname);
    <span class="kw">if</span>(attr==<span class="const">0xFFFFFFFF</span> || (attr &amp; FILE_ATTRIBUTE_DIRECTORY)==<span class="const">0</span>)
      { DisplayText(<span class="str">"Отсутстует папка объектов"</span>);
        <span class="kw">return</span>;
      }
    strcat(dirname,<span class="str">"&#92;&#92;"</span>); <span class="rem">// Добавляем "&#92;" в конец имени</span>
    dirlen=strlen(dirname); <span class="rem">// Длина пути к папке</span>

    <span class="rem">// Считываем файл со списком объектов в буфер List</span>
    <span class="kw">if</span>(!ReadFileToBuffer(filename,&amp;List,&amp;ListSize))
      { DisplayText(<span class="str">"Ошибка чтения списка файлов"</span>);
        <span class="kw">if</span>(List) <span class="kw">delete</span>[] List;
        <span class="kw">return</span>;
      }
    <span class="rem">// Список считан в буфер – разбираем его и грузим объекты</span>

    <span class="rem">// Начинаем загрузку в RDS</span>
    <a class="hidden" href="rdsctrlStartBlockByBlockLoad.htm" title="Б.3.5.18. rdsctrlStartBlockByBlockLoad &ndash; начать поблочную загрузку схемы">rdsctrlStartBlockByBlockLoad</a>(RdsLink,<span class="const">0</span>);

    <span class="rem">// В цикле берем из списка имя за именем</span>
    fn=List;
    <span class="kw">for</span>(;;)
      { <span class="kw">int</span> n;
        <span class="rem">// Пропускаем пустые строки, если они есть</span>
        fn+=strspn(fn,<span class="str">"\r\n"</span>);
        <span class="rem">// Определяем длину до перевода строки</span>
        n=strcspn(fn,<span class="str">"\r\n"</span>); <span class="rem">// В n – длина имени файла</span>
        <span class="kw">if</span>(n==<span class="const">0</span>) <span class="rem">// Список кончился</span>
          <span class="kw">break</span>;
        <span class="kw">if</span>(n+dirlen&gt;MAX_PATH)
          { DisplayText(<span class="str">"Слишком длинный путь"</span>);
            <span class="kw">break</span>;
          }
        <span class="rem">// Копируем имя файла объекта (без пути) в temp</span>
        strncpy(temp,fn,n);
        temp[n]=<span class="const">0</span>;
        fn+=n; <span class="rem">// Продвигаем указатель на следующее имя файла</span>
        <span class="rem">// Формируем в auxname полный путь к файлу объекта</span>
        strcpy(auxname,dirname);
        strcat(auxname,temp);
        <span class="rem">// Считываем файл объекта в буфер Text</span>
        <span class="kw">if</span>(!ReadFileToBuffer(auxname,&amp;Text,&amp;TextSize))
          { DisplayText(<span class="str">"Ошибка чтения файла объекта"</span>);
            <span class="kw">break</span>;
          }
        <span class="rem">// Файл считан – передаем описание объекта в RDS</span>
        tag=atoi(temp); <span class="rem">// Тип объекта – первое число в имени файла</span>
        <a class="hidden" href="rdsctrlSetBlockByBlockLoadPiece.htm" title="Б.3.5.16. rdsctrlSetBlockByBlockLoadPiece &ndash; передать очередной объект при поблочной загрузке">rdsctrlSetBlockByBlockLoadPiece</a>(RdsLink,tag,Text);
      }

    <span class="rem">// Освобождаем буферы</span>
    <span class="kw">if</span>(List) <span class="kw">delete</span>[] List;
    <span class="kw">if</span>(Text) <span class="kw">delete</span>[] Text;

    <span class="rem">// Все считано – собираем схему из объектов</span>
    <span class="kw">if</span>(!<a class="hidden" href="rdsctrlEndBlockByBlockLoad.htm" title="Б.3.5.2. rdsctrlEndBlockByBlockLoad &ndash; завершить поблочную загрузку схемы">rdsctrlEndBlockByBlockLoad</a>(RdsLink,TRUE))
      DisplayText(<span class="str">"Ошибка сборки загруженных данных"</span>);
  }
  <span class="rem">//=========================================</span></div>
  <span class="rem">// Разрешение событий и регистрация их функций</span>
  <span class="kw">void</span> RegisterEvents(<span class="kw">void</span>)
  {
    <span class="rem">// Разрешить реакцию на события</span>
    <a class="hidden" href="rdsctrlEnableEvents.htm" title="Б.3.6.1. rdsctrlEnableEvents &ndash; разрешение реакции на события">rdsctrlEnableEvents</a>(RdsLink,TRUE);
    <span class="rem">// Событие завершения RDS</span>
    <a class="hidden" href="rdsctrlRegisterEventStdCallback.htm" title="Б.3.6.4. rdsctrlRegisterEventStdCallback &ndash; регистрация функции для реакции на событие">rdsctrlRegisterEventStdCallback</a>(RdsLink,
      <a class="hidden" href="RDSCTRLEVENT_CONNCLOSED.htm" title="Б.2.6. RDSCTRLEVENT_CONNCLOSED &ndash; завершение RDS">RDSCTRLEVENT_CONNCLOSED</a>,RdsExitEvent,NULL);
    <span class="rem">// Событие запуска расчета</span>
    <a class="hidden" href="rdsctrlRegisterEventStdCallback.htm" title="Б.3.6.4. rdsctrlRegisterEventStdCallback &ndash; регистрация функции для реакции на событие">rdsctrlRegisterEventStdCallback</a>(RdsLink,
      <a class="hidden" href="RDSCTRLEVENT_CALCSTART.htm" title="Б.2.4. RDSCTRLEVENT_CALCSTART &ndash; запуск расчета">RDSCTRLEVENT_CALCSTART</a>,CalcStartStopEvent,NULL);
    <span class="rem">// Событие завершения расчета</span>
    <a class="hidden" href="rdsctrlRegisterEventStdCallback.htm" title="Б.3.6.4. rdsctrlRegisterEventStdCallback &ndash; регистрация функции для реакции на событие">rdsctrlRegisterEventStdCallback</a>(RdsLink,
      <a class="hidden" href="RDSCTRLEVENT_CALCSTOP.htm" title="Б.2.5. RDSCTRLEVENT_CALCSTOP &ndash; остановка расчета">RDSCTRLEVENT_CALCSTOP</a>,CalcStartStopEvent,NULL);
    <span class="rem">// Сообщение от блока</span>
    <a class="hidden" href="rdsctrlRegisterBlockMsgCallback.htm" title="Б.3.6.2. rdsctrlRegisterBlockMsgCallback &ndash; регистрация функции для реакции на сообщение от блока">rdsctrlRegisterBlockMsgCallback</a>(RdsLink,BlockMsgEvent,NULL);

<div class="changes">    <span class="rem">// Запрет загрузки файла (вместо этого идет событие)</span>
    <a class="hidden" href="rdsctrlNoDirectLoad.htm" title="Б.3.5.10. rdsctrlNoDirectLoad &ndash; запрет загрузки схемы пользователем">rdsctrlNoDirectLoad</a>(RdsLink,TRUE);
    <span class="rem">// Запрет сохранения файла (вместо этого идет событие)</span>
    <a class="hidden" href="rdsctrlNoDirectSave.htm" title="Б.3.5.11. rdsctrlNoDirectSave &ndash; запрет сохранения схемы пользователем">rdsctrlNoDirectSave</a>(RdsLink,TRUE);
    <span class="rem">// Событие загрузки (нажатие "Ctrl+O")</span>
    <a class="hidden" href="rdsctrlRegisterEventStdCallback.htm" title="Б.3.6.4. rdsctrlRegisterEventStdCallback &ndash; регистрация функции для реакции на событие">rdsctrlRegisterEventStdCallback</a>(RdsLink,<a class="hidden" href="RDSCTRLEVENT_LOADREQ.htm" title="Б.2.8. RDSCTRLEVENT_LOADREQ &ndash; запрос загрузки схемы">RDSCTRLEVENT_LOADREQ</a>,
        LoadRequestCallback,NULL);
    <span class="rem">// Событие сохранения (нажатие "Ctrl+S")</span>
    <a class="hidden" href="rdsctrlRegisterEventStdCallback.htm" title="Б.3.6.4. rdsctrlRegisterEventStdCallback &ndash; регистрация функции для реакции на событие">rdsctrlRegisterEventStdCallback</a>(RdsLink,<a class="hidden" href="RDSCTRLEVENT_SAVEFILE.htm" title="Б.2.11. RDSCTRLEVENT_SAVEFILE &ndash; сохранение схемы">RDSCTRLEVENT_SAVEFILE</a>,
        SaveRequestCallback,NULL);</div>
  }
  <span class="rem">//=========================================</span>

  <span class="rem">// Функция возврата строки</span>
  <span class="kw">void</span> <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> ReturnString(<a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> ptr,<a class="hidden" href="app_ids.htm#light_ref20" title="Указатель на строку (char*)">LPSTR</a> str)
  {
    <a class="hidden" href="pm_3_3.htm#ref3" title="Вспомогательный класс для хранения строк">TDynString</a> *pDS=(<a class="hidden" href="pm_3_3.htm#ref3" title="Вспомогательный класс для хранения строк">TDynString</a>*)ptr;
    <span class="kw">if</span>(pDS) pDS-&gt;Set(str);
  }
  <span class="rem">//=========================================</span>

  <span class="rem">// Загрузка RdsCtrl.dll и создание связи</span>
  <span class="kw">void</span> InitRdsCtrl(<span class="kw">void</span>)
  {
    <span class="kw">if</span>(RdsCtrl==NULL) <span class="rem">// Библиотека еще не загружена</span>
      { <span class="kw">char</span> rdsctrldll[MAX_PATH+<span class="const">1</span>],*s;
        <span class="rem">// Считаем, что наша программа находится в одной папке с RDS</span>
        <span class="rem">// Получаем путь к RdsCtrl.dll из пути к нашей программе</span>
        GetModuleFileName(NULL,rdsctrldll,MAX_PATH);
        s=strrchr(rdsctrldll,<span class="str">'&#92;&#92;'</span>); <span class="rem">// Ищем последний '&#92;'</span>
        <span class="kw">if</span>(!s) <span class="rem">// Ошибка</span>
          { DisplayText(<span class="str">"Библиотека не найдена"</span>);
            <span class="kw">return</span>;
          }
        <span class="rem">// Заменяем имя файла в пути</span>
        strcpy(s+<span class="const">1</span>,<span class="str">"RdsCtrl.dll"</span>);

        <span class="rem">// Загружаем библиотеку RdsCtrl.dll</span>
        RdsCtrl=LoadLibrary(rdsctrldll);
        <span class="kw">if</span>(RdsCtrl==NULL) <span class="rem">// Загрузка не удалась</span>
          { DisplayText(<span class="str">"Ошибка загрузки RdsCtrl.dll"</span>);
            <span class="kw">return</span>;
          }
        <span class="rem">// Получаем доступ к функциям библиотеки</span>
        <span class="kw">if</span>(!GetRdsCtrlFuncs(RdsCtrl))
          { <span class="rem">// Ошибка</span>
            DisplayText(<span class="str">"Нет доступа к функциям RdsCtrl.dll"</span>);
            <span class="rem">// Выгружаем библиотеку - она бесполезна</span>
            FreeLibrary(RdsCtrl);
            RdsCtrl=NULL;
            <span class="kw">return</span>;
          }
        <span class="rem">// Доступ к функциям получен – можно их вызывать</span>

        <span class="rem">// Установка функции возврата строки</span>
        <a class="hidden" href="rdsctrlSetStringCallback.htm" title="Б.3.2.10. rdsctrlSetStringCallback &ndash; регистрация функции возврата строки">rdsctrlSetStringCallback</a>(ReturnString);
        <span class="rem">// Сброс идентификатора связи (если он почему-то не сброшен)</span>
        RdsLink=-<span class="const">1</span>;
      } <span class="rem">// if(RdsCtrl==NULL)</span>

    <span class="rem">// Создание связи с RDS</span>
    <span class="kw">if</span>(RdsLink&lt;<span class="const">0</span>) <span class="rem">// Связь не создана</span>
      { <span class="rem">// Создаем связь (rds.exe пока не запускается)</span>
        RdsLink=<a class="hidden" href="rdsctrlCreateLink.htm" title="Б.3.2.3. rdsctrlCreateLink &ndash; создать связь с RDS">rdsctrlCreateLink</a>();
        <span class="kw">if</span>(RdsLink&lt;<span class="const">0</span>) <span class="rem">// Ошибка</span>
          { DisplayText(<span class="str">"Ошибка создания связи с RDS"</span>);
            <span class="kw">return</span>;
          }
        <span class="rem">// Запрет главного окна RDS</span>
        <a class="hidden" href="rdsctrlShowMainWindow.htm" title="Б.3.3.13. rdsctrlShowMainWindow &ndash; видимость главного окна RDS">rdsctrlShowMainWindow</a>(RdsLink,FALSE);
        <span class="rem">// Регистрация откликов на события</span>
        RegisterEvents();
      }
  }
  <span class="rem">//=========================================</span>

  <span class="rem">// Функция, вызываемая перед завершением программы</span>
  <span class="kw">void</span> BeforeExit(<span class="kw">void</span>)
  {
    <span class="kw">if</span>(RdsCtrl!=NULL) <span class="rem">// Библиотека загружена</span>
      { <span class="kw">if</span>(RdsLink&gt;=<span class="const">0</span>) <span class="rem">// Создана связь с RDS</span>
          { <span class="rem">// Завершаем RDS</span>
            <a class="hidden" href="rdsctrlClose.htm" title="Б.3.2.1. rdsctrlClose &ndash; завершить RDS">rdsctrlClose</a>(RdsLink);
            <span class="rem">// Удаляем связь</span>
            <a class="hidden" href="rdsctrlDeleteLink.htm" title="Б.3.2.4. rdsctrlDeleteLink &ndash; уничтожить связь с RDS">rdsctrlDeleteLink</a>(RdsLink);
            RdsLink=-<span class="const">1</span>;
          }
        <span class="rem">// Выгружаем библиотеку</span>
        FreeLibrary(RdsCtrl);
        RdsCtrl=NULL;
      }
  }
  <span class="rem">//=========================================</span>

  <span class="rem">// Открыть файл схемы (filename – имя файла)</span>
  <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> LoadScheme(<span class="kw">char</span> *filename)
  { <span class="kw">if</span>(RdsCtrl==NULL || RdsLink&lt;<span class="const">0</span>)
      { <span class="rem">// Библиотека RdsCtrl.dll еще не загружена</span>
        InitRdsCtrl(); <span class="rem">// Загружаем</span>
        <span class="kw">if</span>(RdsCtrl==NULL) <span class="rem">// Ошибка</span>
          <span class="kw">return</span> FALSE;
        <span class="rem">// Запускаем rds.exe</span>
        <span class="kw">if</span>(!<a class="hidden" href="rdsctrlConnect.htm" title="Б.3.2.2. rdsctrlConnect &ndash; запустить RDS">rdsctrlConnect</a>(RdsLink))
          { DisplayText(<span class="str">"Ошибка запуска RDS"</span>);
            <span class="kw">return</span> FALSE;
          }
      }
    <span class="rem">// Если rds.exe не работает (пользователь вышел из RDS),</span>
    <span class="rem">// перезапускаем RDS</span>
    <a class="hidden" href="rdsctrlRestoreConnection.htm" title="Б.3.2.8. rdsctrlRestoreConnection &ndash; перезапустить RDS при необходимости">rdsctrlRestoreConnection</a>(RdsLink);

    <span class="rem">// RDS работает - загружаем схему</span>
    <span class="kw">if</span>(!<a class="hidden" href="rdsctrlLoadSystemFromFile.htm" title="Б.3.5.6. rdsctrlLoadSystemFromFile &ndash; загрузить схему из файла">rdsctrlLoadSystemFromFile</a>(RdsLink,filename,FALSE))
      { <span class="rem">// Ошибка загрузки</span>
        DisplayText(<span class="str">"Ошибка загрузки схемы"</span>);
        <span class="kw">return</span> FALSE;
      }
    <span class="rem">// Переходим в режим моделирования</span>
    <a class="hidden" href="rdsctrlSetCalcMode.htm" title="Б.3.4.27. rdsctrlSetCalcMode &ndash; включить режим моделирования">rdsctrlSetCalcMode</a>(RdsLink);
    <span class="kw">return</span> TRUE;
  }
  <span class="rem">//=========================================</span>

  <span class="rem">// Нажатие кнопки "Открыть"</span>
  <span class="kw">void</span> OpenButtonClick(<span class="kw">void</span>)
  { <span class="kw">char</span> filename[MAX_PATH+<span class="const">1</span>]=<span class="str">""</span>; <span class="rem">// Буфер для имени файла</span>
    OPENFILENAME ofn;
    <span class="rem">// Заполняем структуру OPENFILENAME</span>
    ZeroMemory(&amp;ofn,<span class="kw">sizeof</span>(ofn));
    ofn.lStructSize=<span class="kw">sizeof</span>(ofn);
    ofn.hwndOwner=MainWin;
    ofn.lpstrFile=filename;
    ofn.nMaxFile=<span class="kw">sizeof</span>(filename);
    ofn.lpstrFilter=<span class="str">"Схемы (*.rds)\0*.rds\0Все файлы\0*.*\0"</span>;
    ofn.nFilterIndex=<span class="const">1</span>;
    ofn.Flags=OFN_EXPLORER | OFN_FILEMUSTEXIST;
    <span class="rem">// Вызываем стандартный диалог открытия файла</span>
    <span class="kw">if</span>(GetOpenFileName(&amp;ofn)) <span class="rem">// Пользователь выбрал файл</span>
      { <span class="rem">// Загружаем схему</span>
        <span class="kw">if</span>(LoadScheme(filename))
          DisplayText(filename);
      }
  }
  <span class="rem">//=========================================</span>

  <span class="rem">// Нажатие кнопки "Закрыть"</span>
  <span class="kw">void</span> CloseButtonClick(<span class="kw">void</span>)
  { <span class="kw">if</span>(RdsLink&gt;=<span class="const">0</span>) <span class="rem">// Есть связь</span>
      { <a class="hidden" href="rdsctrlClose.htm" title="Б.3.2.1. rdsctrlClose &ndash; завершить RDS">rdsctrlClose</a>(RdsLink); <span class="rem">// Завершаем RDS</span>
        DisplayText(<span class="str">"Схема закрыта"</span>);
      }
  }
  <span class="rem">//=========================================</span>

  <span class="rem">// Нажатие кнопки "Вызвать"</span>
  <span class="kw">void</span> CallBlockClick(<span class="kw">void</span>)
  {
    <span class="rem">// Массивы для имени блока и передаваемой строки</span>
    <span class="kw">char</span> blockname[<span class="const">1000</span>],text[<span class="const">1000</span>];
    <span class="rem">// Передаваемое и возвращаемое числа</span>
    <span class="kw">int</span> value,retcode;
    <span class="rem">// Объект для возвращаемой строки</span>
    <a class="hidden" href="pm_3_3.htm#ref3" title="Вспомогательный класс для хранения строк">TDynString</a> retstr;

    <span class="kw">if</span>(RdsLink&lt;<span class="const">0</span>) <span class="rem">// Связь не создана</span>
      <span class="kw">return</span>;

    <span class="rem">// Получаем содержимое полей ввода окна</span>
    GetDlgItemText(MainWin,IDC_BLKNAMEEDIT,
        blockname,<span class="kw">sizeof</span>(blockname)-<span class="const">1</span>);
    value=(<span class="kw">int</span>)GetDlgItemInt(MainWin,IDC_VALUEEDIT,NULL,TRUE);
    GetDlgItemText(MainWin,IDC_STRINGEDIT,text,<span class="kw">sizeof</span>(text)-<span class="const">1</span>);
    <span class="rem">// Теперь имя вызываемого блока записано в массив blockname,</span>
    <span class="rem">// передаваемое число – в переменную value, передаваемая</span>
    <span class="rem">// строка – в массив text</span>

    <span class="rem">// Вызываем блок</span>
    retcode=<a class="hidden" href="rdsctrlCallBlockFunctionEx.htm" title="Б.3.4.7. rdsctrlCallBlockFunctionEx &ndash; передача блоку числа и строки">rdsctrlCallBlockFunctionEx</a>(
        RdsLink,   <span class="rem">// Связь с RDS</span>
        blockname, <span class="rem">// Полное имя блока</span>
        value,     <span class="rem">// Передаваемое целое число</span>
        text,      <span class="rem">// Передаваемая строка</span>
        &amp;retstr);  <span class="rem">// Указатель на объект для возврата строки</span>
    <span class="kw">if</span>(retcode==-<span class="const">1</span>)
      DisplayText(<span class="str">"Блок не найден"</span>);
    <span class="kw">else</span> <span class="rem">// Выводим возвращенную строку в окне программы</span>
      DisplayText(retstr.c_str);
  }
  <span class="rem">//=========================================</span>

  <span class="rem">// Нажатие кнопки "Старт"</span>
  <span class="kw">void</span> StartClick(<span class="kw">void</span>)
  { <span class="kw">if</span>(RdsLink&gt;=<span class="const">0</span>) <span class="rem">// Есть связь</span>
      <a class="hidden" href="rdsctrlStartCalc.htm" title="Б.3.4.32. rdsctrlStartCalc &ndash; запустить расчет">rdsctrlStartCalc</a>(RdsLink);
  }
  <span class="rem">//=========================================</span>

  <span class="rem">// Нажатие кнопки "Стоп"</span>
  <span class="kw">void</span> StopClick(<span class="kw">void</span>)
  { <span class="kw">if</span>(RdsLink&gt;=<span class="const">0</span>) <span class="rem">// Есть связь</span>
     <a class="hidden" href="rdsctrlStopCalc.htm" title="Б.3.4.33. rdsctrlStopCalc &ndash; остановить расчет">rdsctrlStopCalc</a>(RdsLink);
  }
  <span class="rem">//=========================================</span>

  <span class="rem">// Нажатие кнопки "Найти"</span>
  <span class="kw">void</span> FindFuncClick(<span class="kw">void</span>)
  {
    <span class="kw">char</span> funcname[<span class="const">1000</span>], <span class="rem">// Массив для имени операции</span>
         *s;
    <a class="hidden" href="pm_3_3.htm#ref3" title="Вспомогательный класс для хранения строк">TDynString</a> list; <span class="rem">// Сюда запишется возвращаемый список имен</span>

    <span class="kw">if</span>(RdsLink&lt;<span class="const">0</span>) <span class="rem">// Нет связи с RDS</span>
      <span class="kw">return</span>;

    <span class="rem">// Копируем строку из поля ввода "Строка" в массив funcname</span>
    GetDlgItemText(MainWin,IDC_STRINGEDIT,funcname,
            <span class="kw">sizeof</span>(funcname)-<span class="const">1</span>);

    <span class="rem">// Ищем блоки, поддерживающие эту функцию</span>
    <span class="kw">if</span>(!<a class="hidden" href="rdsctrlFindOpSetProviders.htm" title="Б.3.4.16. rdsctrlFindOpSetProviders &ndash; поиск блоков, выполняющих операцию">rdsctrlFindOpSetProviders</a>(
            RdsLink,                <span class="rem">// Связь с RDS</span>
            <span class="str">""</span>,                     <span class="rem">// Начиная с корневой подсистемы</span>
            funcname,               <span class="rem">// Имя операции</span>
            <a class="hidden" href="rdsctrlFindOpSetProviders.htm#light_ref1" title="RDSCTRL_FOSP_RECURSIVE">RDSCTRL_FOSP_RECURSIVE</a>, <span class="rem">// С поиском во вложенных</span>
            &amp;list))         <span class="rem">// Сюда запишется возвращаемый список</span>
      { DisplayText(<span class="str">"Функция не поддерживается"</span>);
        <span class="kw">return</span>;
      }

    <span class="rem">// В строке list может быть список имен блоков.</span>
    <span class="rem">// Оставляем только первый его элемент</span>
    <span class="kw">if</span>(list.c_str==NULL) <span class="rem">// Нет строки</span>
      <span class="kw">return</span>;
    <span class="rem">// Ищем первый разделитель (перевод строки)</span>
    s=strchr(list.c_str,<span class="str">'\n'</span>);
    <span class="rem">// Заменяем найденный разделитель на 0 (конец текста)</span>
    <span class="kw">if</span>(s) *s=<span class="const">0</span>;

    <span class="rem">// Заносим первое имя из списка в поле ввода имени блока</span>
    SetDlgItemText(MainWin,IDC_BLKNAMEEDIT,list.c_str);
  }
  <span class="rem">//=========================================</span>

  <span class="rem">// Процедура обработки сообщений главного окна</span>
  LRESULT CALLBACK MainWndProc(
        <a class="hidden" href="app_ids.htm#light_ref18" title="Дескриптор окна">HWND</a> hWindow, <span class="rem">// Окно</span>
        UINT msg,     <span class="rem">// Сообщение</span>
        WPARAM wParam,LPARAM lParam) <span class="rem">// Параметры</span>
  { <a class="hidden" href="app_ids.htm#light_ref17" title="Дескриптор модуля">HINSTANCE</a> app;
    PAINTSTRUCT ps;
    <a class="hidden" href="app_ids.htm#light_ref16" title="Контекст устройства Windows">HDC</a> hDC;
    <a class="hidden" href="app_ids.htm#light_ref23" title="Координаты прямоугольника в Windows API">RECT</a> rect;

    <span class="kw">switch</span>(msg)
      { <span class="rem">// Создание окна</span>
        <span class="kw">case</span> WM_CREATE:
          <span class="rem">// Запоминаем идентификатор окна в глобальной переменной</span>
          MainWin=hWindow;
          <span class="rem">// Получаем идентификатор приложения</span>
          app=(<a class="hidden" href="app_ids.htm#light_ref17" title="Дескриптор модуля">HINSTANCE</a>)GetWindowLong(hWindow,GWL_HINSTANCE);
          <span class="rem">// Создаем кнопки и поля ввода</span>
          <span class="rem">// Кнопка "Открыть"</span>
          CreateWindow(<span class="str">"BUTTON"</span>,<span class="str">"Открыть"</span>, <span class="rem">// Имя класса и текст</span>
            WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON, <span class="rem">// Стили</span>
            <span class="const">0</span>,<span class="const">30</span>,<span class="const">100</span>,<span class="const">24</span>,                   <span class="rem">// x,y,ширина,высота</span>
            hWindow,                       <span class="rem">// Родительское окно</span>
            (HMENU)IDC_OPENBUTTON,         <span class="rem">// Идентификатор кнопки</span>
            app,NULL);
          <span class="rem">// Кнопка "Закрыть"</span>
          CreateWindow(<span class="str">"BUTTON"</span>,<span class="str">"Закрыть"</span>,
            WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
            <span class="const">101</span>,<span class="const">30</span>,<span class="const">100</span>,<span class="const">24</span>,hWindow,
            (HMENU)IDC_CLOSEBUTTON,app,NULL);
          <span class="rem">// Кнопка "Старт"</span>
          CreateWindow(<span class="str">"BUTTON"</span>,<span class="str">"Старт"</span>,
            WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
            <span class="const">222</span>,<span class="const">30</span>,<span class="const">90</span>,<span class="const">24</span>,hWindow,
            (HMENU)IDC_STARTBUTTON,app,NULL);
          <span class="rem">// Кнопка "Стоп"</span>
          CreateWindow(<span class="str">"BUTTON"</span>,<span class="str">"Стоп"</span>,
            WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
            <span class="const">313</span>,<span class="const">30</span>,<span class="const">90</span>,<span class="const">24</span>,hWindow,
            (HMENU)IDC_STOPBUTTON,app,NULL);
          <span class="rem">// Надпись "Имя блока"</span>
          CreateWindow(<span class="str">"STATIC"</span>,<span class="str">"Имя блока:"</span>,
           WS_VISIBLE | WS_CHILD | SS_LEFTNOWORDWRAP,
           <span class="const">0</span>,<span class="const">55</span>,<span class="const">100</span>,<span class="const">24</span>,hWindow,(HMENU)IDC_LABEL1,app,NULL);
          <span class="rem">// Поле ввода для имени блока</span>
          CreateWindow(<span class="str">"EDIT"</span>,NULL,
            WS_VISIBLE | WS_CHILD | WS_BORDER | ES_AUTOHSCROLL,
            <span class="const">101</span>,<span class="const">55</span>,<span class="const">201</span>,<span class="const">24</span>,hWindow,(HMENU)IDC_BLKNAMEEDIT,app,NULL);
          <span class="rem">// Надпись "Число"</span>
          CreateWindow(<span class="str">"STATIC"</span>,<span class="str">"Число:"</span>,
            WS_VISIBLE | WS_CHILD | SS_LEFTNOWORDWRAP,
            <span class="const">0</span>,<span class="const">80</span>,<span class="const">100</span>,<span class="const">24</span>,hWindow,(HMENU)IDC_LABEL3,app,NULL);
          <span class="rem">// Поле ввода числа</span>
          CreateWindow(<span class="str">"EDIT"</span>,NULL,WS_VISIBLE | WS_CHILD | WS_BORDER,
            <span class="const">101</span>,<span class="const">80</span>,<span class="const">201</span>,<span class="const">24</span>,hWindow,(HMENU)IDC_VALUEEDIT,app,NULL);
          <span class="rem">// Надпись "Строка"</span>
          CreateWindow(<span class="str">"STATIC"</span>,<span class="str">"Строка:"</span>,
            WS_VISIBLE | WS_CHILD | SS_LEFTNOWORDWRAP,
            <span class="const">0</span>,<span class="const">105</span>,<span class="const">100</span>,<span class="const">24</span>,hWindow,(HMENU)IDC_LABEL2,app,NULL);
          <span class="rem">// Поле ввода строки</span>
          CreateWindow(<span class="str">"EDIT"</span>,NULL,
            WS_VISIBLE | WS_CHILD | WS_BORDER | ES_AUTOHSCROLL,
            <span class="const">101</span>,<span class="const">105</span>,<span class="const">201</span>,<span class="const">24</span>,hWindow,(HMENU)IDC_STRINGEDIT,app,NULL);
          <span class="rem">// Кнопка вызова блока</span>
          CreateWindow(<span class="str">"BUTTON"</span>,<span class="str">"Вызвать"</span>,
            WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
            <span class="const">303</span>,<span class="const">55</span>,<span class="const">100</span>,<span class="const">24</span>,hWindow,(HMENU)IDC_CALLBUTTON,app,NULL);
          <span class="rem">// Кнопка поиска блока</span>
          CreateWindow(<span class="str">"BUTTON"</span>,<span class="str">"Найти"</span>,
            WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
            <span class="const">303</span>,<span class="const">105</span>,<span class="const">100</span>,<span class="const">24</span>,hWindow,(HMENU)IDC_FINDBUTTON,app,NULL);
          <span class="kw">break</span>;

        <span class="rem">// Закрытие окна</span>
        <span class="kw">case</span> WM_DESTROY:
          <span class="rem">// Выгрузка библиотеки, если она загружена</span>
          BeforeExit();
          PostQuitMessage(<span class="const">0</span>);
          <span class="kw">return</span> <span class="const">0</span>;

        <span class="rem">// Перерисовка окна</span>
        <span class="kw">case</span> WM_PAINT:
          <span class="rem">// Получаем контекст для рисования</span>
          hDC = BeginPaint(hWindow,&amp;ps);
          <span class="rem">// Получаем размеры внутреннего прямоугольника</span>
          GetClientRect(hWindow,&amp;rect);
          rect.bottom=<span class="const">30</span>; <span class="rem">// Обрезаем снизу</span>
          <span class="rem">// Выводим текст из buffer</span>
          DrawText(hDC,buffer,-<span class="const">1</span>,&amp;rect,
              DT_SINGLELINE | DT_CENTER | DT_VCENTER);
          <span class="rem">// Завершаем рисование</span>
          EndPaint(hWindow,&amp;ps);
          <span class="kw">return</span> <span class="const">0</span>;

        <span class="rem">// Команда от органов управления</span>
        <span class="kw">case</span> WM_COMMAND:
          <span class="kw">if</span>(HIWORD(wParam) == BN_CLICKED) <span class="rem">// Нажатие кнопки</span>
            { <span class="kw">switch</span> (LOWORD(wParam))
                { <span class="kw">case</span> IDC_OPENBUTTON:  OpenButtonClick();  <span class="kw">break</span>;
                  <span class="kw">case</span> IDC_CLOSEBUTTON: CloseButtonClick(); <span class="kw">break</span>;
                  <span class="kw">case</span> IDC_CALLBUTTON:  CallBlockClick();   <span class="kw">break</span>;
                  <span class="kw">case</span> IDC_STARTBUTTON: StartClick();       <span class="kw">break</span>;
                  <span class="kw">case</span> IDC_STOPBUTTON:  StopClick();        <span class="kw">break</span>;
                  <span class="kw">case</span> IDC_FINDBUTTON:  FindFuncClick();    <span class="kw">break</span>;
                }
            }
          <span class="kw">break</span>;
      }
    <span class="rem">// Вызов обработки сообщения по умолчанию</span>
    <span class="kw">return</span> DefWindowProc(hWindow,msg,wParam,lParam);
  }
  <span class="rem">//=========================================</span>

  <span class="rem">// Главная функция приложения</span>
  <span class="kw">int</span> WINAPI WinMain(<a class="hidden" href="app_ids.htm#light_ref17" title="Дескриптор модуля">HINSTANCE</a> hInstance,
          <a class="hidden" href="app_ids.htm#light_ref17" title="Дескриптор модуля">HINSTANCE</a> hPrevInstance,
          PSTR szCmdLine,
          <span class="kw">int</span> iCmdShow)
  { <span class="kw">static</span> <span class="kw">char</span> appName[] = <span class="str">"Управление RDS"</span>,
                className[]=<span class="str">"RDSControlTestWindow"</span>;
    WNDCLASSEX myWin;
    <a class="hidden" href="app_ids.htm#light_ref18" title="Дескриптор окна">HWND</a> hWindow;
    MSG msg;

    <span class="rem">// Создание окна</span>
    myWin.cbSize=<span class="kw">sizeof</span>(myWin);
    myWin.style=CS_HREDRAW | CS_VREDRAW;
    myWin.lpfnWndProc=MainWndProc;
    myWin.cbClsExtra=<span class="const">0</span>;
    myWin.cbWndExtra=<span class="const">0</span>;
    myWin.hInstance=hInstance;
    myWin.hIcon=<span class="const">0</span>;
    myWin.hIconSm =<span class="const">0</span>;
    myWin.hCursor=<span class="const">0</span>;
    myWin.hbrBackground=(HBRUSH)(COLOR_WINDOW+<span class="const">1</span>);
    myWin.lpszMenuName=<span class="const">0</span>;
    myWin.lpszClassName=className;
    <span class="kw">if</span> (!RegisterClassEx(&amp;myWin)) <span class="kw">return</span> <span class="const">0</span>;
    hWindow=CreateWindow(className,appName,
      WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,
      <span class="const">0</span>,<span class="const">0</span>,hInstance,<span class="const">0</span>);
    <span class="rem">// Открытие созданного окна</span>
    ShowWindow(hWindow,iCmdShow);
    UpdateWindow(hWindow);

    <span class="rem">// Инициализация стандартных компонентов</span>
    INITCOMMONCONTROLSEX icc;
    icc.dwSize=<span class="kw">sizeof</span>(icc);
    icc.dwICC=ICC_WIN95_CLASSES;
    <span class="kw">if</span>(!InitCommonControlsEx(&amp;icc))
      DisplayText(<span class="str">"Ошибка InitCommonControlsEx"</span>);

    <span class="rem">// Цикл обработки сообщений приложения</span>
    <span class="kw">while</span>(GetMessage(&amp;msg,<span class="const">0</span>,<span class="const">0</span>,<span class="const">0</span>))
      { TranslateMessage(&amp;msg);
        DispatchMessage(&amp;msg);
      }
    <span class="kw">return</span> <span class="const">0</span>;
  }
  <span class="rem">//=========================================</span></pre>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="pm_3_4.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="pm_3_6_1.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="pm_index.htm#light_htm:pm_3_5">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
