<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;4.1. Принцип работы модулей автокомпиляции</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="pm_index.htm">Руководство программиста</a></p>
<div class="level"><p><a href="pm_index.htm#light_htm:pm_4">Глава 4. Создание модулей автоматической компиляции</a></p>
<div class="level"><p>&sect;4.1. Принцип работы модулей автокомпиляции</p>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="pm_3_6_6.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="pm_4_2.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="pm_index.htm#light_htm:pm_4_1">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Руководство программиста</h1>
<h2>Глава 4. Создание модулей автоматической компиляции</h2>
<p class="abstract">Описывается принцип создания модулей автокомпиляции, которые по введенному пользователем тексту могут формировать и компилировать модель блока. Рассматривается пример такого модуля для создания простых моделей в синтаксисе языка C.</p>
<h3>&sect;4.1. Принцип работы модулей автокомпиляции</h3>
<p class="abstract">Рассматривается структура данных модуля автокомпиляции и его функции, описывается последовательность 
            вызовов функции модуля при подключении и отключении моделей и выполнении компиляции.</p>


<p>Модули автоматической компиляции предназначены для того, чтобы облегчить создание моделей блоков пользователям,
мало знакомым с программированием. Чтобы написать модель, даже если это простейшая функция, вычисляющая сумму двух
входов блока и выдающая ее на выход, необходимо правильно оформить
<a href="pm_2_2.htm" title="&sect;2.2. Главная функция DLL и файлы заголовков">главную функцию</a> динамически загружаемой библиотеки (DLL) и собственно
<a href="pm_2_3.htm" title="&sect;2.3. Структура функции модели блока">функцию модели блока</a> с учетом всех особенностей синтаксиса используемого
языка программирования (описания экспортированной функции, включения всех необходимых заголовочных файлов и т.д.)
Чаще всего пользователь не горит желанием изучать всю эту &laquo;лишнюю&raquo; для него информацию &ndash;
он хочет просто указать с помощью какого-либо простого интерфейса, что блок имеет входы
&laquo;<span class="rdsvar">x1</span>&raquo; и &laquo;<span class="rdsvar">x2</span>&raquo;, выход &laquo;<span class="rdsvar">y</span>&raquo;, и выполняет операцию
&laquo;<span class="cpp">y=x1+x2</span>&raquo;. В этом ему может помочь грамотно написанный модуль автокомпиляции.</p>

<p>Модуль автокомпиляции нужен для того, чтобы преобразовать введенные пользователем тексты и
данные, каким-либо образом описывающие работу блока, в полноценную библиотеку с экспортированной функцией
модели, которая может быть загружена в RDS и подключена к указанным пользователем блокам. При этом
RDS совершенно не важно, как именно пользователь описывает алгоритм работы блока и как эти алгоритмы
трансформируются в готовую библиотеку &ndash; всем этим должен заниматься модуль автокомпиляции. Обычно имеет
смысл дать пользователю возможность писать основные, самые важные, фрагменты модели блока на каком-либо
языке программирования высокого уровня, а затем автоматически собирать из них полный исходный текст библиотеки
со всеми необходимыми описаниями и вызывать внешний компилятор для ее сборки: так достигается баланс между
удобством пользователя и простотой реализации модуля. Именно так устроены модули автокомпиляции,
<a href="um_3_1.htm" title="&sect;3.1. Принцип действия стандартного модуля автокомпиляции">входящие в комплект RDS</a>: они предоставляют пользователю редактор,
в котором он записывает реакции блока на различные события в синтаксисе языка C (при этом он может
пользоваться функциями из стандартных библиотек, функциями Windows API и
<a href="app_index.htm#light_htm:app_a_5" title="А.5. Сервисные функции RDS">сервисными функциями</a>
RDS), после чего собирают из них библиотеку с функцией модели, вызывая
один из стандартных компиляторов.</p>

<p><span id="ref1">Модуль</span>
автокомпиляции представляет собой
экспортированную из какой-либо библиотеки
<span id="light_ref1">функцию следующего вида</span>:</p>

<pre class="cpp">  <span class="kw">extern</span> <span class="str">"C"</span> <span class="kw">__declspec</span>(<span class="kw">dllexport</span>) <span class="kw">int</span> <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> <i>имя_функции_модуля</i>(
    <span class="kw">int</span> CallMode,                   <span class="rem">// Режим вызова</span>
    <a class="hidden" href="RDS_COMPMODULEDATA.htm#ref2" title="Указатель на RDS_COMPMODULEDATA">RDS_PCOMPMODULEDATA</a> ModuleData, <span class="rem">// Данные модуля</span>
    <a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> ExtParam)                <span class="rem">// Дополнительные параметры</span></pre>

<p>Как только в схеме появляется блок, для которого установлена автоматическая компиляция модели каким-либо
модулем, RDS загружает библиотеку с функцией этого модуля и начинает вызывать эту функцию для
выполнения различных действий в ответ на системные события (подключение моделей к блокам и их отключение, компиляция
модели, вызов редактора и т.п.). Можно заметить, что функция модуля автокомпиляции очень похожа на функцию
модели блока &ndash; как и в функцию модели, в нее передается целый идентификатор события
<span class="cpp">CallMode</span>, на которое должен отреагировать модуль, указатель
<span class="cpp">ModuleData</span> на структуру данных объекта (в данном случае объектом является модуль
автокомпиляции, а не блок схемы) и указатель <span class="cpp">ExtParam</span> на дополнительные параметры,
тип и структура которых зависит от конкретного события. Разумеется, события, на которые реагирует модуль
автокомпиляции, отличаются от событий, на которые реагирует функция модели.</p>

<p>Прежде, чем модуль автокомпиляции можно будет использовать в блоках схемы, его необходимо зарегистрировать в
RDS, открыв окно со списком модулей пунктом меню
&laquo;<span class="menu">Сервис | Автокомпиляция&hellip;</span>&raquo;
(<a href="#pic1" title="Окно списка модулей автокомпиляции">рис.&nbsp;130</a>)
и добавив новый модуль кнопкой &laquo;<span class="menu">+</span>&raquo;. В нижней части окна для добавленного модуля нужно указать
имя файла библиотеки, в которой находится его функция (можно использовать
<a href="rdsGetFullFilePath.htm#ref1" title="Символические обозначения стандартных путей">условные обозначения стандартных путей</a>, например,
&laquo;$DLL$&raquo;), экспортированное имя функции модуля в этой библиотеке и название, под которым
пользователь будет видеть этот модуль в интерфейсах RDS.</p>

<div class="pic"><div class="container" id="pic1">
<img src="../img/AutocompModules.png" width="533" height="370" alt="Окно списка модулей автокомпиляции" />
<p id="light_pic1">Рис.&nbsp;130. Окно списка модулей автокомпиляции</p>
</div></div>


<p><span id="ref2">В</span>
этом же окне можно настраивать модули автокомпиляции (двойным щелчком на названии модуля в списке
или специальной кнопкой в правой части окна). В RDS нет собственного интерфейса для настройки модулей,
его должна обеспечить функция настраиваемого модуля. Когда пользователь вызывает настройку какого-либо модуля,
RDS, в свою очередь, вызывает его функцию с параметром <span class="cpp">CallMode</span>, равным
<span class="cpp"><span id="light_ref3"><a href="RDS_COMPM_SETUP.htm" title="А.3.4.19. RDS_COMPM_SETUP &ndash; настройка модуля автокомпиляции">RDS_COMPM_SETUP</a></span></span> (все константы и структуры, используемые для создания модулей
автокомпиляции, описаны в файле &laquo;<span class="file"><span id="light_ref2">RdsComp.h</span></span>&raquo;).
Реагируя на этот вызов, функция должна самостоятельно обеспечить пользователю возможность ввода параметров,
необходимых для работы модуля, например, открыв какое-либо окно с полями ввода. Если на момент настройки
библиотека с модулем не загружена, RDS загружает ее перед вызовом функции и выгружает после него.
При этом сразу после загрузки функция модуля вызывается с параметром
<span class="cpp"><span id="light_ref4"><a href="RDS_COMPM_INIT.htm" title="А.3.4.10. RDS_COMPM_INIT &ndash; инициализация модуля">RDS_COMPM_INIT</a></span></span>, а перед выгрузкой &ndash; с параметром
<span class="cpp"><span id="light_ref5"><a href="RDS_COMPM_CLEANUP.htm" title="А.3.4.4. RDS_COMPM_CLEANUP &ndash; очистка данных модуля">RDS_COMPM_CLEANUP</a></span></span> для инициализации данных модуля и их очистки соответственно
(инициализация и очистка данных модуля рассмотрены в <a href="pm_4_2.htm" title="&sect;4.2. Инициализация, очистка и настройка параметров модуля">&sect;4.2</a>).</p>

<p><span id="ref6">В</span>
<span id="ref7">отличие</span>
от функции модели блока, функция модуля автокомпиляции должна заботиться еще и о том, как и
где она будет хранить настроечные параметры модуля. Если параметры блока обычно сохраняются в файле схемы,
в которой находится этот блок, с параметрами модуля автокомпиляции так поступать нельзя: они не связаны
с конкретной схемой и относятся ко всему модулю в целом. Кроме того, они могут различаться на разных машинах
(например, путь к исполняемому файлу используемого внешнего компилятора зависит от того, в какую
папку он установлен на данной машине), поэтому при переносе схемы с машины на машину параметры модулей
автокомпиляции не должны переноситься вместе с ней. Чаще всего функция хранит параметры своего модуля
в каком-либо файле в стандартной <span id="light_ref6">папке настроек</span> RDS
(символическое имя &laquo;<span id="light_ref7">$INI$</span>&raquo;), и всей работой с
этим файлом занимается самостоятельно.</p>

<p>Для того, чтобы связать блок с автоматически компилируемой моделью, пользователь должен на вкладке
&laquo;<span class="menu">Компиляция</span>&raquo; окна параметров блока
(<a href="#pic2" title="Подключение автокомпилируемой модели к блоку">рис.&nbsp;131</a>)
выбрать модуль, который будет обслуживать модель блока, и указать имя этой модели.</p>

<div class="pic"><div class="container" id="pic2">
<img src="../img/Autocomp_param_general.png" width="534" height="300" alt="Подключение автокомпилируемой модели к блоку" />
<p id="light_pic2">Рис.&nbsp;131. Подключение автокомпилируемой модели к блоку</p>
</div></div>


<p>С точки зрения RDS, имя модели &ndash; это просто строка символов, не чувствительная к регистру
(имена &laquo;Model&raquo;, &laquo;model&raquo; и &laquo;MODEL&raquo; будут считаться именами одной
и той же модели). Сами модели блоков, как и параметры модулей, не сохраняются в файле схемы вместе с
параметрами блока, к которому они подключены. Дело в том, что одна и та же модель может использоваться в
разных схемах, и, если бы ее текст хранился в каждой из этих схем независимо, для изменения модели пришлось
бы менять ее текст во всех этих схемах. Поэтому в схеме сохраняется только имя модели, имя библиотеки с
обслуживающим ее модулем автокомпиляции и имя функции этого модуля. Модуль автокомпиляции должен самостоятельно
организовать хранение текста модели, с которым работает пользователь, и уметь вызывать нужную модель по
имени. Чаще всего каждая модель хранится в отдельном файле, и в качестве ее имени используется имя этого файла
&ndash; такой подход позволяет реализовать поиск и хранение моделей очень просто. Тем не менее,
разработчик модуля автокомпиляции может выбрать и другие способы хранения &ndash; например, хранить модель в
таблице какой-либо базы данных, а в качестве имени модели использовать уникальный ключ (идентификатор) записи
таблицы. RDS никак не ограничивает разработчика в этом вопросе.</p>

<p>Таким образом, хранение автоматически компилируемых моделей отдельно от схемы приводит к тому, что
внесение изменений в какую-либо модель отражается на всех схемах, которые эту модель используют. При этом
следует помнить, что для переноса схемы с автокомпилируемыми моделями на другую машину необходимо скопировать на
нее не только файл схемы, но и все используемые этой схемой модели. Либо, если на другой машине не
нужна автоматическая компиляция, отключить ее в параметрах всех блоков &ndash; при этом блоки останутся
связанными с уже скомпилированными библиотеками, но исходный текст модели им будет уже не нужен. Разумеется,
скомпилированные библиотеки нужно будет скопировать на другую машину вместе со схемой.</p>

<p>На вкладке &laquo;<span class="menu">Компиляция</span>&raquo; окна параметров блока имя модели может вводиться вручную или
выбираться при помощи кнопок &laquo;<span class="menu">Обзор</span>&raquo; (для подключения к блоку существующей модели) и
&laquo;<span class="menu">Новый</span>&raquo; (для создания новой модели). RDS не обрабатывает нажатия этих кнопок,
они передаются в функцию модуля автокомпиляции, как и нажатие кнопки
&laquo;<span class="menu">Сохранить как</span>&raquo;, которая позволяет сохранить используемую модель под другим именем. Модуль
должен сам выполнить все необходимые действия по подключению новой модели, показу необходимых для этого
диалогов и т.д. При необходимости модуль может запретить эти кнопки, если он не поддерживает
соответствующие функции, а также задать название поля ввода имени модели (например, выбранный
на <a href="#pic2" title="Подключение автокомпилируемой модели к блоку">рис.&nbsp;131</a> модуль хранит модели в файлах, поэтому
в качестве названия поля ввода он установил строку
&laquo;Файл исходного текста&raquo;).</p>

<p>Каждый модуль автокомпиляции может одновременно обслуживать произвольное число моделей, каждая из
которых может быть подключена к произвольному числу блоков
(<a href="#pic3" title="Структура данных модуля автокомпиляции">рис.&nbsp;132</a>).</p>

<div class="pic"><div class="container" id="pic3">
<img src="../img/AutocompStruct.png" width="643" height="580" alt="Структура данных модуля автокомпиляции" />
<p id="light_pic3">Рис.&nbsp;132. Структура данных модуля автокомпиляции</p>
</div></div>


<p>При загрузке модуля автокомпиляции для него создается структура
<span class="cpp"><span id="light_ref8"><a href="RDS_COMPMODULEDATA.htm" title="А.3.2. RDS_COMPMODULEDATA &ndash; структура данных модуля">RDS_COMPMODULEDATA</a></span></span>, которая хранится в памяти до момента его выгрузки, то есть
до тех пор, пока последняя модель, обслуживаемая этим модулем, не будет отключена от блока. Описание этой
структуры в файле &laquo;<span class="file">RdsComp.h</span>&raquo; имеет следующий вид:</p>

<pre class="cpp">  <span class="kw">typedef</span> <span class="kw">struct</span>
  { <a class="hidden" href="app_ids.htm#light_ref9" title="Идентификатор модуля автокомпиляции">RDS_COMPHANDLE</a> Module; <span class="rem">// Уникальный идентификатор модуля</span>
    <a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> ModuleData;     <span class="rem">// Личная область данных модуля</span>
    <a class="hidden" href="app_ids.htm#light_ref20" title="Указатель на строку (char*)">LPSTR</a> DllFullPath;     <span class="rem">// Полный путь к DLL модуля</span>
    <a class="hidden" href="app_ids.htm#light_ref20" title="Указатель на строку (char*)">LPSTR</a> DllFuncName;     <span class="rem">// Имя функции DLL модуля</span>
    <span class="kw">int</span> NModels;           <span class="rem">// Число моделей, обслуживаемых модулем</span>
  } <a class="hidden" href="RDS_COMPMODULEDATA.htm" title="А.3.2. RDS_COMPMODULEDATA &ndash; структура данных модуля">RDS_COMPMODULEDATA</a>;
  <span class="kw">typedef</span> <a class="hidden" href="RDS_COMPMODULEDATA.htm" title="А.3.2. RDS_COMPMODULEDATA &ndash; структура данных модуля">RDS_COMPMODULEDATA</a> *<a class="hidden" href="RDS_COMPMODULEDATA.htm#ref2" title="Указатель на RDS_COMPMODULEDATA">RDS_PCOMPMODULEDATA</a>; <span class="rem">// Указатель</span></pre>

<p>Указатель на эту структуру передается во втором параметре
<a href="#ref1" title="Общий вид функции модуля автоматической компиляции">функции</a> модуля автокомпиляции. В поле
<span class="cpp">ModuleData</span> функция может записать указатель на личную область данных модуля,
в которой она может хранить, например, его настроечные параметры. RDS не обрабатывает это поле структуры,
поэтому отведением памяти под личную область и ее освобождением должна заниматься функция модуля,
точно так же, как функция модели блока
<a href="pm_2_4.htm" title="&sect;2.4. Инициализация и очистка данных блока">отводит и освобождает память</a> под личную область данных блока.
Все остальные поля структуры функция модуля может только читать &ndash; они заполняются
RDS автоматически.</p>

<p><span id="ref9">Для</span> каждой модели, обслуживаемой модулем, в памяти хранится
<span id="light_ref9">структура <span class="cpp"><span id="light_ref10"><a href="RDS_COMPMODELDATA.htm" title="А.3.3. RDS_COMPMODELDATA &ndash; структура данных модели">RDS_COMPMODELDATA</a></span></span></span>. Она создается
RDS при первом подключении модели к какому-либо блоку и хранится в памяти до тех пор, пока в
схеме остаются блоки, подключенные к этой модели. Функция модуля автокомпиляции в любой момент может получить
указатель на структуру любой из своих моделей, вызвав сервисную функцию
<span class="cpp"><span id="light_ref11"><a href="rdscompGetModelData.htm" title="А.5.34.5. rdscompGetModelData &ndash; обслуживаемая модулем модель по номеру">rdscompGetModelData</a></span></span> и указав в ее параметре идентификатор модуля и номер
модели (общее число моделей, обслуживаемых модулем в данный момент, всегда хранится в поле
<span class="cpp">NModels</span> структуры данных модуля <span class="cpp"><a class="hidden" href="RDS_COMPMODULEDATA.htm" title="А.3.2. RDS_COMPMODULEDATA &ndash; структура данных модуля">RDS_COMPMODULEDATA</a></span>).
Структура <span class="cpp"><a class="hidden" href="RDS_COMPMODELDATA.htm" title="А.3.3. RDS_COMPMODELDATA &ndash; структура данных модели">RDS_COMPMODELDATA</a></span> описана в файле
&laquo;<span class="file">RdsComp.h</span>&raquo; следующим образом:</p>

<pre class="cpp">  <span class="kw">typedef</span> <span class="kw">struct</span>
  { <a class="hidden" href="app_ids.htm#light_ref10" title="Идентификатор автокомпилируемой модели">RDS_MODELHANDLE</a> Model; <span class="rem">// Уникальный идентификатор модели</span>
    <a class="hidden" href="app_ids.htm#light_ref20" title="Указатель на строку (char*)">LPSTR</a> ModelName;       <span class="rem">// Имя модели</span>
    <a class="hidden" href="app_ids.htm#light_ref20" title="Указатель на строку (char*)">LPSTR</a> ModelNameUC;     <span class="rem">// Имя модели в верхнем регистре</span>
    <a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> ModelData;      <span class="rem">// Личная область данных модели</span>
    <span class="kw">int</span> NBlocks;           <span class="rem">// Число блоков, связанных с моделью</span>
    <a class="hidden" href="app_ids.htm#light_ref9" title="Идентификатор модуля автокомпиляции">RDS_COMPHANDLE</a> Module; <span class="rem">// Идентификатор обслуживающего модуля</span>
    <span class="rem">// Параметры скомпилированной модели</span>
    <a class="hidden" href="app_ids.htm#light_ref20" title="Указатель на строку (char*)">LPSTR</a> CompDllName;     <span class="rem">// DLL скомпилированной модели</span>
    <a class="hidden" href="app_ids.htm#light_ref20" title="Указатель на строку (char*)">LPSTR</a> CompDllFunc;     <span class="rem">// Имя экспортированной функции</span>
    <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> Valid;            <span class="rem">// Признак необходимости компиляции</span>

    <a class="hidden" href="app_ids.htm#light_ref20" title="Указатель на строку (char*)">LPSTR</a> AltModelName;    <span class="rem">// Альтернативное имя модели</span>
    <span class="kw">int</span> Tag;               <span class="rem">// Пользовательское поле</span>
  } <a class="hidden" href="RDS_COMPMODELDATA.htm" title="А.3.3. RDS_COMPMODELDATA &ndash; структура данных модели">RDS_COMPMODELDATA</a>;
  <span class="kw">typedef</span> <a class="hidden" href="RDS_COMPMODELDATA.htm" title="А.3.3. RDS_COMPMODELDATA &ndash; структура данных модели">RDS_COMPMODELDATA</a> *<a class="hidden" href="RDS_COMPMODELDATA.htm#ref2" title="Указатель на RDS_COMPMODELDATA">RDS_PCOMPMODELDATA</a>; <span class="rem">// Указатель</span></pre>

<p>Как и у модуля автокомпиляции, у модели может быть личная область данных, в которой функция модуля
может хранить какие-либо необходимые для компиляции этой модели данные. Как обычно, отведением и
освобождением памяти под эту область функция модуля должна заниматься самостоятельно: при первом подключении
модели к блоку функция модуля вызывается с параметром
<span class="cpp"><span id="light_ref12"><a href="RDS_COMPM_MODELINIT.htm" title="А.3.4.13. RDS_COMPM_MODELINIT &ndash; инициализация модели">RDS_COMPM_MODELINIT</a></span></span>, в этот момент она может отвести память под личную
область модели и записать указатель на нее в поле <span class="cpp">ModelData</span> структуры
<span class="cpp"><a class="hidden" href="RDS_COMPMODELDATA.htm" title="А.3.3. RDS_COMPMODELDATA &ndash; структура данных модели">RDS_COMPMODELDATA</a></span> (см. <a href="#pic3" title="Структура данных модуля автокомпиляции">рис.&nbsp;132</a>).
При отключении модели от последнего блока схемы функция модуля будет вызвана с параметром
<span class="cpp"><span id="light_ref13"><a href="RDS_COMPM_MODELCLEANUP.htm" title="А.3.4.12. RDS_COMPM_MODELCLEANUP &ndash; очистка данных модели">RDS_COMPM_MODELCLEANUP</a></span></span>, и должна будет освободить отведенную под личную область
данных модели память.</p>

<p><span id="ref14">Кроме</span>
поля <span class="cpp">ModelData</span> функция модуля может изменять в этой структуре еще
только два поля: признак необходимости компиляции <span class="cpp">Valid</span> (его использование будет
описано ниже) и целое поле <span class="cpp" id="light_ref14">Tag</span>, которое никак не обрабатывается
RDS и может использоваться разработчиком модуля по своему усмотрению. Все остальные поля либо устанавливаются
RDS, либо меняются функцией модуля не непосредственно, а через вызовы специальных сервисных функций.</p>

<p>В поля <span class="cpp">ModelName</span> и <span class="cpp">ModelNameUC</span> RDS
записывает указатели на строки в своей внутренней памяти, содержащие имя модели в том виде, в
котором его ввел пользователь, и преобразованное в верхний регистр соответственно (как было указано выше,
имя модели не чувствительно к регистру). Функция модуля никак не может изменить эти строки, они заполняются
автоматически при первом подключении модели к блоку схемы.</p>

<p>В целом поле <span class="cpp">NBlocks</span> содержится общее число блоков схемы, к которым
подключена данная модель. Это поле изменяется автоматически при подключении модели к блокам и
отключении от них. Функция модуля может получить идентификатор любого из использующих данную модель блоков
и описание этого блока, вызвав сервисную функцию <span class="cpp"><span id="light_ref15"><a href="rdscompGetModelBlock.htm" title="А.5.34.4. rdscompGetModelBlock &ndash; обслуживаемый моделью блок по номеру">rdscompGetModelBlock</a></span></span> и передав
ей идентификатор модели, номер блока и, при необходимости, указатель на структуру описания блока
<span class="cpp"><span id="light_ref16"><a href="RDS_BLOCKDESCRIPTION.htm#ref1" title="Структура RDS_BLOCKDESCRIPTION">RDS_BLOCKDESCRIPTION</a></span></span>.</p>

<p>В полях <span class="cpp">CompDllName</span> и <span class="cpp">CompDllFunc</span> содержатся указатели
на строки, содержащие имя DLL, которая будет создана в результате компиляции данной модели, и имя
экспортированной из нее функции блока. Эти имена устанавливаются функцией модуля перед компиляцией
при помощи сервисной функции <span class="cpp"><span id="light_ref17"><a href="rdscompSetModelFunction.htm" title="А.5.34.13. rdscompSetModelFunction &ndash; установить имена DLL и функции скомпилированной модели">rdscompSetModelFunction</a></span></span>, после компиляции
RDS использует их, чтобы загрузить новую модель и подключить ее ко всем использующим ее блокам.
Логическое поле <span class="cpp">Valid</span> обычно используется для того, чтобы зря не компилировать
модели, текст и параметры которых не изменились: при подготовке к компиляции функция модуля записывает в
это поле значение <span class="cpp">FALSE</span>, если требуется компиляция, и <span class="cpp">TRUE</span>,
если модель с момента прошлой компиляции не менялась. Если исходные тексты моделей хранятся в файлах,
необходимость компиляции проще всего выяснить, сравнив время последнего изменения файла исходного текста модели
с временем последнего изменения скомпилированной DLL. Если текст модели менялся позднее, чем была записана
DLL, значит, он изменился, и DLL необходимо скомпилировать заново.</p>

<p><span id="ref18">В</span>
поле <span class="cpp">AltModelName</span> хранится указатель на строку, представляющую собой так
называемое <span id="light_ref18">&laquo;альтернативное имя&raquo; модели</span>. Это имя устанавливается сервисной функцией
<span class="cpp"><span id="light_ref19"><a href="rdscompSetAltModelName.htm" title="А.5.34.11. rdscompSetAltModelName &ndash; установить альтернативное имя модели">rdscompSetAltModelName</a></span></span> и запоминается в файле схемы вместе с
&laquo;нормальным&raquo; именем модели. Пользователь не видит альтернативное имя модели и установить его
не может (при подключении модели через окно параметров блока, как на
<a href="#pic2" title="Подключение автокомпилируемой модели к блоку">рис.&nbsp;131</a>, альтернативному имени присваивается пустая
строка). Поскольку исходные тексты моделей хранятся отдельно от файлов схем, альтернативное имя является
единственной возможностью записать в файл схемы какую-либо информацию, относящуюся к модели. Разработчик модуля
автокомпиляции может использовать его по своему усмотрению, RDS это альтернативное имя никак
не обрабатывает. Например, если тексты моделей хранятся в файлах, в альтернативном имени можно хранить
полный путь к такому файлу, а в &laquo;нормальном имени&raquo; &ndash; короткий путь, возможно,
с использованием символических констант.</p>

<p>Допустим например, что файл схемы имеет имя &laquo;<span class="file">scheme.rds</span>&raquo;, файл модели &ndash;
&laquo;<span class="file">model.mod</span>&raquo;, и оба они находятся в папке
&laquo;<span class="file">d:\data\files</span>&raquo;. В этом случае в качестве имени модели целесообразно использовать текст
&laquo;model.mod&raquo; &ndash; поскольку сервисные функции RDS позволяют автоматически добавлять к
именам файлов без путей путь к папке, в которой находится файл загруженной схемы, схема будет работать до
тех пор, пока файл схемы и файл модели находятся в одной и той же папке, куда бы они ни были скопированы. Однако,
если пользователь скопирует файл схемы в другую папку, а файл модели скопировать забудет, модуль автокомпиляции
&laquo;потеряет&raquo; файл модели: файл теперь находится не в папке файла схемы, и имени файла без
пути для его загрузки уже недостаточно. Из этого положения можно выйти, записывая в альтернативное имя модели
путь к папке, в которой находится файл модели на момент последней удачной загрузки, то есть
&laquo;d:\data\files&raquo;. В этом случае модуль автокомпиляции должен быть написан так, чтобы, не
обнаружив файл модели в ожидаемом месте (в данном случае &ndash; в папке файла схемы), он искал его в папке,
указанной в строке альтернативного имени модели. Разумеется, разработчик может придумать и другие
способы использования альтернативного имени.</p>

<p>Наконец, целое поле <span class="cpp">Tag</span> структуры
<span class="cpp"><a class="hidden" href="RDS_COMPMODELDATA.htm" title="А.3.3. RDS_COMPMODELDATA &ndash; структура данных модели">RDS_COMPMODELDATA</a></span> может использоваться разработчиком по своему усмотрению.
Функция модуля может записывать в это поле что угодно &ndash; RDS его никак не обрабатывает.</p>

<p>Автокомпилируемая модель может подключаться к блоку по нескольким причинам. Кроме явного включения
автокомпиляции в параметрах блока
(см. <a href="#pic2" title="Подключение автокомпилируемой модели к блоку">рис.&nbsp;131</a>), модели подключаются к блокам при
загрузке схемы, при вставке блока из буфера обмена или из библиотеки блоков и т.п. Независимо от причины,
при этом выполняется следующая последовательность действий:</p>

<ol>
  <li>Если выбранный модуль автокомпиляции еще не используется в схеме, его DLL загружается в память RDS,
  для него создается структура <span class="cpp"><a class="hidden" href="RDS_COMPMODULEDATA.htm" title="А.3.2. RDS_COMPMODULEDATA &ndash; структура данных модуля">RDS_COMPMODULEDATA</a></span>, после чего функция модуля
  вызывается с параметром <span class="cpp"><a class="hidden" href="RDS_COMPM_INIT.htm" title="А.3.4.10. RDS_COMPM_INIT &ndash; инициализация модуля">RDS_COMPM_INIT</a></span>. В этот момент она обычно создает
  личную область данных модуля и загружает в нее настроечные параметры, необходимые для его работы.</li>

  <li>Функция модуля вызывается с параметром <span class="cpp"><span id="light_ref20"><a href="RDS_COMPM_CANATTACHBLK.htm" title="А.3.4.2. RDS_COMPM_CANATTACHBLK &ndash; проверка возможности подключения модели к блоку">RDS_COMPM_CANATTACHBLK</a></span></span>, и в нее
  передается имя модели и идентификатор блока, к которому будет подключаться эта модель. Структура данных модели
  <span class="cpp"><a class="hidden" href="RDS_COMPMODELDATA.htm" title="А.3.3. RDS_COMPMODELDATA &ndash; структура данных модели">RDS_COMPMODELDATA</a></span> на этот момент может быть еще не создана. Реагируя на
  этот вызов, функция модуля должна проверить принципиальную возможность подключения данной модели к
  данному блоку. Например, модель, использующая <a href="pm_1_5.htm" title="&sect;1.5. Статические переменные блоков, входы и выходы">статические переменные</a>,
  не может подключаться к <a href="pm_1_2.htm#light_ref4" title="Подсистема">подсистемам</a>,
  <a href="pm_1_2.htm#light_ref6" title="Внешний вход подсистемы">внешним входам</a>/<a href="pm_1_2.htm#light_ref8" title="Внешний выход подсистемы">выходам</a> и
  <a href="pm_1_2.htm#light_ref9" title="Ввод шины">вводам шин</a>, поскольку их структура переменных устроена не так,
  как у <a href="pm_1_2.htm#light_ref3" title="Простой блок">простых блоков</a>. Если подключение модели к блоку невозможно,
  функция либо возвращает сообщение об ошибке, либо вызывает сервисную функцию
  <span class="cpp"><span id="light_ref21"><a href="rdscompAttachDifferentModel.htm" title="А.5.34.1. rdscompAttachDifferentModel &ndash; замена имени подключаемой модели">rdscompAttachDifferentModel</a></span></span>, сообщая RDS, что, хотя модель с данным
  именем подключить нельзя, вместо нее можно подключить модель с другим именем (например, если файл,
  соответствующий имени модели, отсутствует, но по альтернативному имени можно найти другой, как
  в примере, описанном выше).</li>

  <li>Если данная модель еще не подключалась ни к одному блоку схемы, для нее создается структура
  <span class="cpp"><a class="hidden" href="RDS_COMPMODELDATA.htm" title="А.3.3. RDS_COMPMODELDATA &ndash; структура данных модели">RDS_COMPMODELDATA</a></span>, функция модуля вызывается с параметром
  <span class="cpp"><span id="light_ref22"><a href="RDS_COMPM_MODELINIT.htm" title="А.3.4.13. RDS_COMPM_MODELINIT &ndash; инициализация модели">RDS_COMPM_MODELINIT</a></span></span>, и в нее передается указатель на структуру данных модели.
  Реагируя на этот вызов, функция может создать для модели личную область данных, если это необходимо.</li>

  <li>Функция модуля вызывается с параметром <span class="cpp"><span id="light_ref23"><a href="RDS_COMPM_ATTACHBLOCK.htm" title="А.3.4.1. RDS_COMPM_ATTACHBLOCK &ndash; подключение модели к блоку">RDS_COMPM_ATTACHBLOCK</a></span></span> и в нее
  передается указатель на структуру данных модели <span class="cpp"><a class="hidden" href="RDS_COMPMODELDATA.htm" title="А.3.3. RDS_COMPMODELDATA &ndash; структура данных модели">RDS_COMPMODELDATA</a></span>
  и идентификатор блока, к которому она подключается.</li>
</ol>

<p class="noindent">При отключении автокомпилируемой модели от блока (опять же, причины отключения
могут быть различными: выключение автокомпиляции в параметрах блока, удаление блока, завершение RDS и т.п.)
выполняется следующая последовательность действий:</p>

<ol>
  <li>Функция модуля автокомпиляции вызывается с параметром <span class="cpp"><span id="light_ref24"><a href="RDS_COMPM_DETACHBLOCK.htm" title="А.3.4.7. RDS_COMPM_DETACHBLOCK &ndash; отключение модели от блока">RDS_COMPM_DETACHBLOCK</a></span></span>,
  и в нее передается указатель на структуру данных модели <span class="cpp"><a class="hidden" href="RDS_COMPMODELDATA.htm" title="А.3.3. RDS_COMPMODELDATA &ndash; структура данных модели">RDS_COMPMODELDATA</a></span> и
  идентификатор блока, от которого она сейчас будет отключена.</li>

  <li>Если это был последний блок, с которым связана данная модель, функция модуля вызывается с параметром
  <span class="cpp"><span id="light_ref25"><a href="RDS_COMPM_MODELCLEANUP.htm" title="А.3.4.12. RDS_COMPM_MODELCLEANUP &ndash; очистка данных модели">RDS_COMPM_MODELCLEANUP</a></span></span>, при этом в нее передается указатель на структуру данных
  модели <span class="cpp"><a class="hidden" href="RDS_COMPMODELDATA.htm" title="А.3.3. RDS_COMPMODELDATA &ndash; структура данных модели">RDS_COMPMODELDATA</a></span>. Реагируя на этот вызов, функция должна уничтожить личную
  область данных, если она создавалась для этой модели. После этого структура данных модели уничтожается.</li>

  <li>Если данный модуль компиляции больше не используется в схеме (то есть последняя модель этого модуля
  отключена от последнего использовавшего ее блока), функция модуля вызывается с параметром
  <span class="cpp"><a href="RDS_COMPM_CLEANUP.htm" title="А.3.4.4. RDS_COMPM_CLEANUP &ndash; очистка данных модуля">RDS_COMPM_CLEANUP</a></span>, после чего данные модуля уничтожаются и его DLL
  выгружается из памяти. Реагируя на вызов <span class="cpp"><a class="hidden" href="RDS_COMPM_CLEANUP.htm" title="А.3.4.4. RDS_COMPM_CLEANUP &ndash; очистка данных модуля">RDS_COMPM_CLEANUP</a></span>, функция должна уничтожить
  личную область данных модуля, если она создавалась.</li>
</ol>

<p class="noindent">Таким образом, функция модуля автокомпиляции всегда получает информацию о
загрузке и выгрузке своего модуля, о создании структур данных новых моделей и уничтожении более не
используемых, и о подключении моделей к новым блокам и их отключении.</p>

<p>RDS вызывает модуль автокомпиляции для компиляции обслуживаемых им моделей в четырех случаях:
после загрузки схемы или блока, при переходе из режима <a href="pm_1_3.htm#ref1" title="Режим редактирования">редактирования</a>
в режим <a href="pm_1_3.htm#ref2" title="Режим моделирования">моделирования</a> и при выборе пользователем пунктов меню
&laquo;<span class="menu">Система | Компилировать модели</span>&raquo; или
&laquo;<span class="menu">Система | Перекомпилировать все модели</span>&raquo;. В последнем случае подразумевается, что модуль
должен скомпилировать даже те модели, которые не менялись с момента прошлой компиляции &ndash;
это может быть полезно, например, при сбое системных часов, когда время записи скомпилированной DLL модели
оказывается большим времени изменения ее текста из-за того, что время изменения текста показывается неправильно.
За компиляцию моделей отвечают два последовательных вызова функции модуля: сначала функция вызывается с
параметром <span class="cpp"><span id="light_ref26"><a href="RDS_COMPM_PREPARE.htm" title="А.3.4.16. RDS_COMPM_PREPARE &ndash; подготовка модели к компиляции">RDS_COMPM_PREPARE</a></span></span> для каждой модели по отдельности, а затем
&ndash; для всех моделей сразу с параметром <span class="cpp"><span id="light_ref27"><a href="RDS_COMPM_COMPILE.htm" title="А.3.4.6. RDS_COMPM_COMPILE &ndash; компиляция моделей">RDS_COMPM_COMPILE</a></span></span>.</p>

<p><span id="ref28">При</span>
вызове функции модуля с параметром <span class="cpp">CallMode</span>, равным
<span class="cpp"><a class="hidden" href="RDS_COMPM_PREPARE.htm" title="А.3.4.16. RDS_COMPM_PREPARE &ndash; подготовка модели к компиляции">RDS_COMPM_PREPARE</a></span>, функция модуля должна проверить необходимость компиляции конкретной
модели, и подготовить ее для этого, если необходимо. В <a href="#ref1" title="Общий вид функции модуля автоматической компиляции">параметре</a>
<span class="cpp">ExtParam</span> при этом передается указатель на
<span id="light_ref28">структуру <span class="cpp"><span id="light_ref29"><a href="RDS_COMPM_PREPARE.htm#ref1" title="Структура RDS_COMPPREPAREDATA">RDS_COMPPREPAREDATA</a></span></span></span>, содержащую два поля:</p>

<pre class="cpp">  <span class="kw">typedef</span> <span class="kw">struct</span>
  { <a class="hidden" href="RDS_COMPMODELDATA.htm#ref2" title="Указатель на RDS_COMPMODELDATA">RDS_PCOMPMODELDATA</a> Model; <span class="rem">// Указатель на структуру данных модели</span>
    <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> Rebuild              <span class="rem">// TRUE, если необходимо принудительно</span>
                              <span class="rem">// компилировать все модели</span>
  } <a class="hidden" href="RDS_COMPM_PREPARE.htm#ref1" title="Структура RDS_COMPPREPAREDATA">RDS_COMPPREPAREDATA</a>;
  <span class="kw">typedef</span> <a class="hidden" href="RDS_COMPM_PREPARE.htm#ref1" title="Структура RDS_COMPPREPAREDATA">RDS_COMPPREPAREDATA</a> *<a class="hidden" href="RDS_COMPM_PREPARE.htm#ref2" title="Указатель на RDS_COMPPREPAREDATA">RDS_PCOMPPREPAREDATA</a>; <span class="rem">// Указатель</span></pre>

<p>В поле <span class="cpp">Model</span> этой структуры содержится указатель на структуру данных модели,
а в логическом поле <span class="cpp">Rebuild</span> &ndash; <span class="cpp">TRUE</span>, если пользователь выбрал
пункт меню &laquo;<span class="menu">Система | Перекомпилировать все модели</span>&raquo; (то есть если модель нужно
компилировать даже тогда, когда функция модуля не видит в этом необходимости) и
<span class="cpp">FALSE</span> в противном случае. Реагируя на этот вызов, функция должна установить поле
<span class="cpp">Valid</span> в структуре, указатель на которую находится в поле
<span class="cpp">Model</span>. Если данная модель должна быть скомпилирована,
<span class="cpp">Valid</span> нужно присвоить <span class="cpp">FALSE</span>, если же компилировать не нужно,
<span class="cpp">Valid</span> присваивается <span class="cpp">TRUE</span>.</p>

<p><span id="ref30">Если</span> в результате вызовов функции модуля с параметром
<span class="cpp"><a class="hidden" href="RDS_COMPM_PREPARE.htm" title="А.3.4.16. RDS_COMPM_PREPARE &ndash; подготовка модели к компиляции">RDS_COMPM_PREPARE</a></span> хотя бы в одной структуре модели поле
<span class="cpp">Valid</span> получило значение <span class="cpp">FALSE</span>, или если пользователем
была выбрана принудительная компиляция всех моделей, функция вызывается с параметром
<span class="cpp"><span id="light_ref31"><a href="RDS_COMPM_COMPILE.htm" title="А.3.4.6. RDS_COMPM_COMPILE &ndash; компиляция моделей">RDS_COMPM_COMPILE</a></span></span>. В параметре
<span class="cpp">ExtParam</span> при этом передается указатель на
<span id="">структуру
<span class="cpp"><span id="light_ref32"><a href="RDS_COMPM_COMPILE.htm#ref3" title="Структура RDS_COMPILEDATA">RDS_COMPILEDATA</a></span></span></span>:</p>

<pre class="cpp">  <span class="kw">typedef</span> <span class="kw">struct</span>
  { <span class="rem">// Массив указателей на структуры моделей, которые необходимо</span>
    <span class="rem">// компилировать</span>
    <a class="hidden" href="RDS_COMPMODELDATA.htm#ref2" title="Указатель на RDS_COMPMODELDATA">RDS_PCOMPMODELDATA</a> *InvalidModels;
    <span class="kw">int</span> IMCount;  <span class="rem">// Размер массива (число моделей)</span>
    <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> Rebuild; <span class="rem">// TRUE – принудительная компиляция</span>
  } <a class="hidden" href="RDS_COMPM_COMPILE.htm#ref3" title="Структура RDS_COMPILEDATA">RDS_COMPILEDATA</a>;
  <span class="kw">typedef</span> <a class="hidden" href="RDS_COMPM_COMPILE.htm#ref3" title="Структура RDS_COMPILEDATA">RDS_COMPILEDATA</a> *<a class="hidden" href="RDS_COMPM_COMPILE.htm#ref4" title="Указатель на RDS_COMPILEDATA">RDS_PCOMPILEDATA</a>; <span class="rem">// Указатель</span></pre>

<p>В поле <span class="cpp">InvalidModels</span> находится указатель на массив указателей на
структуры данных (<span class="cpp"><a class="hidden" href="RDS_COMPMODELDATA.htm" title="А.3.3. RDS_COMPMODELDATA &ndash; структура данных модели">RDS_COMPMODELDATA</a></span>) моделей, которые должны быть скомпилированы,
а в поле <span class="cpp">IMCount</span> &ndash; размер этого массива. Функция модуля должна
перебрать все модели в этом массиве и скомпилировать каждую из них. Перед этим вызовом RDS выгружает
из памяти все DLL этих моделей, и снова загружает их только после того, как функция модуля вернет ему
управление &ndash; таким образом, DLL не будут заблокированы, и функция сможет заменить их на новые,
полученные в результате компиляции. В поле <span class="cpp">Rebuild</span> передается признак принудительной
компиляции всех моделей, но функция модуля может его игнорировать, поскольку в любом случае в массиве
<span class="cpp">InvalidModels</span> будет находиться список моделей, которые нужно компилировать,
независимо от того, попали они туда из-за того, что при вызове с параметром
<span class="cpp"><a class="hidden" href="RDS_COMPM_PREPARE.htm" title="А.3.4.16. RDS_COMPM_PREPARE &ndash; подготовка модели к компиляции">RDS_COMPM_PREPARE</a></span> флаг <span class="cpp">Valid</span> в их структурах
был установлен в <span class="cpp">FALSE</span>, или из-за того, что пользователь приказал компилировать все
модели схемы.</p>

<p>Кроме описанных выше вызовов, функция модуля также вызывается для открытия редактора модели, при изменении
пользователем какой-либо структуры в списке типов переменных (если эта структура используется в моделях,
модуль должен скомпилировать их заново), при изменении режима RDS, при сохранении блока с автокомпилируемой
моделью, для запроса разрешенности кнопок на вкладке
&laquo;<span class="menu">Компиляция</span>&raquo; в окне параметров блока
(<a href="#pic2" title="Подключение автокомпилируемой модели к блоку">рис.&nbsp;131</a>) и т.д. Все возможные режимы ее вызова подробно рассмотрены
в <a href="app_index.htm#light_htm:app_a_3" title="А.3. События модуля автокомпиляции и связанные с ними структуры">приложениях</a>.</p>

<p>В <a href="pm_4_2.htm" title="&sect;4.2. Инициализация, очистка и настройка параметров модуля">&sect;4.2</a> и далее рассматривается относительно простой
пример, иллюстрирующий работу модуля автокомпиляции.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="pm_3_6_6.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="pm_4_2.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="pm_index.htm#light_htm:pm_4_1">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
