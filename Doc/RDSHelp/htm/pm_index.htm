<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>Руководство программиста</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p>Руководство программиста</p>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="disbutton">&lt;&lt;</span>
<span class="button"><a href="pm_1_1.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm">Описание пользователя</a></span>
<span class="disbutton">Руководство программиста</span>
<span class="button"><a href="app_index.htm">Приложения</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

  
<div class="text">
<h1>Руководство программиста</h1>

</div>

<div class="toc">
<div class="level">
<p><a href="pm_1_1.htm" id="light_htm:pm_1">Глава 1. Устройство RDS</a></p>
<p class="abstract">В этой главе рассматривается основные принципы работы RDS: модули, из которых состоит приложение, внутреннее устройство блоков схемы, режимы работы, способы взаимодействия блоков с пользователем. Вводятся основные термины, которые будут использованы в следующих главах.</p>
<div class="level">
<p><a href="pm_1_1.htm" id="light_htm:pm_1_1">&sect;1.1. Общая структура RDS</a></p>
<p class="abstract">Кратко описывается структура RDS как приложения Windows: перечислены основные папки и файлы приложения.</p>
</div>
<div class="level">
<p><a href="pm_1_2.htm" id="light_htm:pm_1_2">&sect;1.2. Блоки RDS и их типы</a></p>
<p class="abstract">Описываются типы блоков, из которых состоит схема RDS, и особенности каждого из этих типов.</p>
</div>
<div class="level">
<p><a href="pm_1_3.htm" id="light_htm:pm_1_3">&sect;1.3. Режимы работы RDS</a></p>
<p class="abstract">Описываются три режима работы RDS и циклический вызов моделей блоков в режиме расчета.</p>
</div>
<div class="level">
<p><a href="pm_1_4.htm" id="light_htm:pm_1_4">&sect;1.4. Параметры и внешний вид блоков</a></p>
<p class="abstract">Описывается внутренняя структура блоков RDS, способы задания их внешнего вида в окне подсистем, возможности взаимодействия блоков с пользователем.</p>
</div>
<div class="level">
<p><a href="pm_1_5.htm" id="light_htm:pm_1_5">&sect;1.5. Статические переменные блоков, входы и выходы</a></p>
<p class="abstract">Описывается структура и возможные типы статических переменных блока, то есть тех переменных, которые обычно существуют все время жизни блока и не создаются и не уничтожаются в процессе работы схемы. Входы и выходы блока, к которым могут присоединяться связи, всегда являются статическими переменными. Описывается способ формирования строки типа, используемой для проверки правильности структуры переменных.</p>
</div>
<div class="level">
<p><a href="pm_1_6.htm" id="light_htm:pm_1_6">&sect;1.6. Взаимодействие блоков между собой</a></p>
<p class="abstract">Описываются способы взаимодействия блоков друг с другом через динамические переменные, которые создаются в процессе работы одним блоком подсистемы и автоматически становятся доступными для других блоков. Использование динамических переменных для передачи данных не загромождает подсистему лишними связями и не требует запуска режима расчета, что иногда может оказаться очень удобным.</p>
</div>
<div class="level">
<p><a href="pm_1_7.htm" id="light_htm:pm_1_7">&sect;1.7. Реакция на действия пользователя</a></p>
<p class="abstract">Описываются способы реакции модели блока на действия пользователя: нажатие кнопок и перемещение курсора мыши, нажатие и отпускание клавиш клавиатуры. Также описывается создание собственных пунктов меню блока и функции настройки параметров.</p>
</div>
<div class="level">
<p><a href="pm_1_8.htm" id="light_htm:pm_1_8">&sect;1.8. Открытие окон в модели блока</a></p>
<p class="abstract">Описываются особенности открытия модальных (блокирующих доступ к остальным окнам приложения до своего закрытия) и немодальных (позволяющих переключаться в другие окна) окон из программы модели блока и связанные с этим проблемы, на которые следует обратить внимание. Различные примеры работы с окнами в моделях блоков приведены в <a href="pm_index.htm#light_htm:pm_2_7" title="&sect;2.7. Настройка параметров блока">&sect;2.7</a>.</p>
</div>
</div>
<div class="level">
<p><a href="pm_2_1.htm" id="light_htm:pm_2">Глава 2. Создание моделей блоков</a></p>
<p class="abstract">В главе подробно разбираются различные аспекты написания моделей блоков, реакции на системные события, вызов сервисных функций RDS. Приводятся примеры исходных текстов моделей на языке C++ с подробным описанием работы этих моделей.</p>
<div class="level">
<p><a href="pm_2_1.htm" id="light_htm:pm_2_1">&sect;2.1. Программы моделей и DLL</a></p>
<p class="abstract">Описывается общий принцип размещения моделей в динамически подключаемых библиотеках (DLL) и способ компиляции примеров моделей, рассматриваемых в этой главе.</p>
</div>
<div class="level">
<p><a href="pm_2_2.htm" id="light_htm:pm_2_2">&sect;2.2. Главная функция DLL и файлы заголовков</a></p>
<p class="abstract">Описывается главная функция DLL, которую должна иметь каждая библиотека с моделями блоков, а также реализация взаимодействия программы модели с главной программой RDS при помощи сервисных функций. Приводится пример использования макроса, позволяющего получить доступ ко всем функциям RDS сразу.</p>
</div>
<div class="level">
<p><a href="pm_2_3.htm" id="light_htm:pm_2_3">&sect;2.3. Структура функции модели блока</a></p>
<p class="abstract">Рассматривается структура любой функции модели блока на языке C/C++, объясняется смысл ее параметров. Описывается структура данных, которую RDS хранит для каждого блока.</p>
</div>
<div class="level">
<p><a href="pm_2_4.htm" id="light_htm:pm_2_4">&sect;2.4. Инициализация и очистка данных блока</a></p>
<p class="abstract">Описывается событие инициализации <span class="cpp">RDS_BFM_INIT</span> &ndash; самое первое событие в &laquo;жизни&raquo; модели блока, и событие очистки <span class="cpp">RDS_BFM_CLEANUP</span> &ndash; самое последнее. Приводится пример модели, отводящей себе память под личные нужды при инициализации и освобождающей ее при очистке.</p>
</div>
<div class="level">
<p><a href="pm_2_5_1.htm" id="light_htm:pm_2_5">&sect;2.5. Статические переменные блоков</a></p>
<p class="abstract">Описывается работа со статическими переменными блоков (то есть переменными фиксированной структуры), которые могут служить им входами и выходами. Рассматриваются особенности работы с сигнальными переменными, матрицами и массивами, структурами, строками произвольной длины, а также с переменными, меняющими свой тип в процессе работы. Приводятся примеры моделей блоков, иллюстрирующие доступ к переменным каждого типа.</p>
<div class="level">
<p><a href="pm_2_5_1.htm" id="light_htm:pm_2_5_1">&sect;2.5.1. Доступ к статическим переменным и работа в режиме расчета</a></p>
<p class="abstract">Описывается способ чтения и записи значений статических переменных блока. Рассматривается событие проверки допустимости типа статических переменных <span class="cpp">RDS_BFM_VARCHECK</span> и событие выполнения такта расчета <span class="cpp">RDS_BFM_MODEL</span>. Приводится пример блока, выдающего в режиме расчета на выход разность двух вещественных входов. В примере предусмотрена проверка значений входов блока на специальное значение, символизирующее ошибку вещественных вычислений.</p>
</div>
<div class="level">
<p><a href="pm_2_5_2.htm" id="light_htm:pm_2_5_2">&sect;2.5.2. Особенности использования сигналов</a></p>
<p class="abstract">Описываются особенности работы с переменными сигнального типа, то есть с переменными, используемыми для передачи информации о факте наступления какого-либо события. Использование сигналов позволяет организовать сложное логическое взаимодействие блоков. Приводится пример модели блока-счетчика, увеличивающего значение своего выхода на единицу при каждом поступлении сигнала на вход.</p>
</div>
<div class="level">
<p><a href="pm_2_5_3.htm" id="light_htm:pm_2_5_3">&sect;2.5.3. Доступ к матрицам и массивам</a></p>
<p class="abstract">Описываются особенности работы с матрицами и массивами: их размещение в памяти, макросы для доступа к ним, сервисные функции для изменения размера матриц. Приводится пример блока, умножающего вход-матрицу на вход-число и выдающего результат на выход.</p>
</div>
<div class="level">
<p><a href="pm_2_5_4.htm" id="light_htm:pm_2_5_4">&sect;2.5.4. Работа со строками</a></p>
<p class="abstract">Описываются особенности работы с переменными-строками произвольной длины и сервисные функции для их создания, уничтожения и сложения. Приводится пример блока, преобразующего поступившее на вход целое число в строку.</p>
</div>
<div class="level">
<p><a href="pm_2_5_5.htm" id="light_htm:pm_2_5_5">&sect;2.5.5. Работа со структурами</a></p>
<p class="abstract">Описываются особенности работы с переменными-структурами, их размещение в памяти и способ доступа
                к их полям при помощи макросов. Приводится пример блока, суммирующего два комплексных входа, в котором
                комплексные числа представлены структурами с двумя вещественными полями <span class="cpp">Re</span> и <span class="cpp">Im</span>.</p>
</div>
<div class="level">
<p><a href="pm_2_5_6.htm" id="light_htm:pm_2_5_6">&sect;2.5.6. Работа с переменными произвольного типа</a></p>
<p class="abstract">Описываются особенности работы с переменными, тип которых может изменяться в процессе
                работы системы. Приведен пример блока &ndash; универсального выключателя, пропускающего или не
                пропускающего значение входа произвольного типа на выход в зависимости от дополнительного логического
                входа. Также приводится пример блока, выдающего на выходы разные значения в зависимости
                от типа значения, поступившего на вход. В третьем примере модель меняет тип выхода в
                зависимости от значения целого числа на входе.</p>
</div>
<div class="level">
<p><a href="pm_2_5_7.htm" id="light_htm:pm_2_5_7">&sect;2.5.7. Использование входов со связанными сигналами</a></p>
<p class="abstract">Описывается работа с входами блока, для которых заданы связанные сигналы &ndash; по этим сигналам
                можно понять, какие из входов блока сработали в данном такте расчета. Приводится пример модели блока,
                вычисляющей произведение минимального элемента первой входной матрицы и максимального элемента второй входной
                матрицы. Анализируя связанные сигналы входов, эта модель вычисляет максимальный или минимальный элемент только
                для изменившейся матрицы, экономя тем самым процессорное время.</p>
</div>
<div class="level">
<p><a href="pm_2_5_8.htm" id="light_htm:pm_2_5_8">&sect;2.5.8. Использование выходов с управляющими переменными</a></p>
<p class="abstract">Описывается использование управляющих переменных, которые позволяют запретить передачу по
                связям значения конкретного выхода блока, а также активировать связь, подключенную к конкретному элементу
                выхода-массива. Приведен пример модели переключателя с двумя выходами, передающего входное значение на
                один или на оба выхода в зависимости от значения дополнительного входа (работа неактивного выхода блокируется
                управляющей переменной). Также приведен пример демультиплексора на произвольное число выходов
                (активный выход выбирается целой управляющей переменной массива).</p>
</div>
</div>
<div class="level">
<p><a href="pm_2_6_1.htm" id="light_htm:pm_2_6">&sect;2.6. Динамические переменные</a></p>
<p class="abstract">Описывается работа с динамическими переменными, то есть с переменными, которые модели
            блоков создают и уничтожают в процессе работы. Модели могут создавать такие переменные в корневой или
            родительской подсистеме блока, поэтому несколько блоков могут получать доступ к одной и
            той же динамической переменной и использовать ее для связи.</p>
<div class="level">
<p><a href="pm_2_6_1.htm" id="light_htm:pm_2_6_1">&sect;2.6.1. Использование динамических переменных</a></p>
<p class="abstract">Описываются общие принципы работы с динамическими переменными &ndash; их создание, уничтожение,
                получение доступа к созданным (&laquo;подписка&raquo;). Описаны основные сервисные функции RDS,
                относящиеся к динамическим переменным.</p>
</div>
<div class="level">
<p><a href="pm_2_6_2.htm" id="light_htm:pm_2_6_2">&sect;2.6.2. Подписка на динамическую переменную</a></p>
<p class="abstract">Приводится пример модели блока, получающего доступ к стандартной динамической переменной времени
                &laquo;DynTime&raquo;, создаваемой блоком-планировщиком, и используемой большинством библиотечных блоков.
                Блок в примере вычисляет синус от времени, умножает его на значение входа и выдает на выход. В примере также
                рассматривается реакция модели на событие <span class="cpp"><a href="RDS_BFM_DYNVARCHANGE.htm" title="А.2.4.4. RDS_BFM_DYNVARCHANGE &ndash; изменение динамической переменной">RDS_BFM_DYNVARCHANGE</a></span>, сигнализирующее о том,
                что динамическая переменная изменилась.</p>
</div>
<div class="level">
<p><a href="pm_2_6_3.htm" id="light_htm:pm_2_6_3">&sect;2.6.3. Создание и удаление динамической переменной</a></p>
<p class="abstract">Описываются сервисные функции создания и удаления динамических переменных. Приводится пример двух блоков,
                организующих связь между разными частями схемы при помощи динамической переменной, создаваемой в корневой
                подсистеме. В примере также рассматривается событие перехода в режим моделирования <span class="cpp"><a href="RDS_BFM_CALCMODE.htm" title="А.2.4.1. RDS_BFM_CALCMODE &ndash; переход из режима редактирования в режим моделирования">RDS_BFM_CALCMODE</a></span>
                и событие запуска расчета <span class="cpp"><a href="RDS_BFM_STARTCALC.htm" title="А.2.4.14. RDS_BFM_STARTCALC &ndash; запуск расчета">RDS_BFM_STARTCALC</a></span>.</p>
</div>
<div class="level">
<p><a href="pm_2_6_4.htm" id="light_htm:pm_2_6_4">&sect;2.6.4. Работа с несколькими динамическими переменными</a></p>
<p class="abstract">Рассматриваются особенности работы модели блока с несколькими динамическими переменными одновременно.
                Приводится пример, в котором блок перемещается в окне подсистемы с заданной скоростью и в заданном направлении,
                при этом скорость и направление он берет из динамических переменных, созданных в подсистеме другим
                рассматриваемым в примере блоком, а время &ndash; из динамической переменной &laquo;<span class="rdsvar">DynTime</span>&raquo;
                стандартного библиотечного блока-<a href="pm_2_6_1.htm#ref10" title="Блок управления динамическим расчетом (планировщик)">планировщика</a>.</p>
</div>
<div class="level">
<p><a href="pm_2_6_5.htm" id="light_htm:pm_2_6_5">&sect;2.6.5. Работа со сложными динамическими переменными</a></p>
<p class="abstract">Рассматривается работа с динамическими переменными сложных типов: матрицами, структурами и т.п.
                Приводится пример, в котором два блока передают друг другу матрицу вещественных чисел через динамическую переменную
                в корневой подсистеме.</p>
</div>
</div>
<div class="level">
<p><a href="pm_2_7_1.htm" id="light_htm:pm_2_7">&sect;2.7. Настройка параметров блока</a></p>
<p class="abstract">Описываются способы предоставления пользователю интерфейса для настройки параметров блока.
            Рассматриваются возможности открытия моделью блока модальных окон, возникающие при этом проблемы и их решения.
            Рассматривается использование специальных вспомогательных объектов RDS, позволяющих без особых усилий
            формировать модальные окна с полями ввода. Также рассматривается способ хранения параметров блока в файле
            схемы, не требующий введение в модель дополнительных реакций &ndash; запись значений параметров значения
            по умолчанию статических переменных блока.</p>
<div class="level">
<p><a href="pm_2_7_1.htm" id="light_htm:pm_2_7_1">&sect;2.7.1. Функция настройки блока и открытие модальных окон</a></p>
<p class="abstract">Описывается реакция модели на функцию настройки блока (<span class="cpp"><a href="RDS_BFM_SETUP.htm" title="А.2.6.13. RDS_BFM_SETUP &ndash; вызов функции настройки блока">RDS_BFM_SETUP</a></span>),
                возможность вызова которой встроена в пользовательский интерфейс RDS. С помощью этой реакции в блоки,
                описанные в <a href="pm_2_6_3.htm" title="&sect;2.6.3. Создание и удаление динамической переменной">&sect;2.6.3</a> (приемник и передатчик, организующие
                связь через динамическую переменную), добавлен интерфейс для настройки.</p>
</div>
<div class="level">
<p><a href="pm_2_7_2.htm" id="light_htm:pm_2_7_2">&sect;2.7.2. Использование объектов-окон RDS</a></p>
<p class="abstract">Рассматривается использование вспомогательных объектов RDS, облегчающих создание и открытие
                модальных окно с полями ввода, описаны сервисные функции для работы с этими объектами. С их помощью
                в один из ранее описывавшихся блоков добавлен простой пользовательский интерфейс. Во другом примере рассматривается
                блок-генератор, выдающий на выход синусоиду, косинусоиду или прямоугольные импульсы по выбору пользователя,
                при этом некоторые поля в его окне настройки, формируемом при помощи вспомогательного объекта RDS,
                разрешаются или запрещаются в зависимости от значений других полей.</p>
</div>
<div class="level">
<p><a href="pm_2_7_3.htm" id="light_htm:pm_2_7_3">&sect;2.7.3. Расширенные возможности функции обратного вызова</a></p>
<p class="abstract">Рассматривается рисование произвольных изображений в модальном окне, формируемом вспомогательным
                объектом RDS. Для этого в окно настроек блока из предыдущего примера добавляется изображение внешнего вида
                формируемой генератором функции.</p>
</div>
<div class="level">
<p><a href="pm_2_7_4.htm" id="light_htm:pm_2_7_4">&sect;2.7.4. Хранение настроечных параметров в переменных блока</a></p>
<p class="abstract">Описывается хранение настроечных параметров блока в значениях по умолчанию его
                <a href="pm_1_5.htm" title="&sect;1.5. Статические переменные блоков, входы и выходы">статических переменных</a>. Этот способ не требует введения
                в модель новых реакций, к тому же, он позволяет пользователю выбирать: задавать ли ему параметр вручную
                в окне настроек блока или подключить к нему связь и передавать ему значение откуда-нибудь из схемы.
                Приведен пример блока, вычисляющего y=K&times;x+C, где x &ndash; вход, а K и C могут либо задаваться
                в окне настройки, либо получать свои значения по связям от других блоков.</p>
</div>
<div class="level">
<p><a href="pm_2_7_5.htm" id="light_htm:pm_2_7_5">&sect;2.7.5. Открытие модальных окон средствами Windows API</a></p>
<p class="abstract">Рассматривается пример модели блока, позволяющего выбрать произвольный цвет при помощи стандартного
                диалога Windows и выдающего выбранный цвет на выход в виде целого числа. Пример иллюстрирует открытие модальных
                окон (в данном случае &ndash; стандартного диалога) средствами Windows API.</p>
</div>
<div class="level">
<p><a href="pm_2_7_6.htm" id="light_htm:pm_2_7_6">&sect;2.7.6. Открытие модальных окон в режиме расчета</a></p>
<p class="abstract">Рассматриваются особенности открытия модальных окон в <a href="pm_1_3.htm#ref3" title="Режим расчета">режиме расчета</a>.
                Блок из предыдущего примера модифицируется так, чтобы модальное окно в режиме расчета не вызывало проблем.
                Описывается сервисная функция RDS <span class="cpp"><a href="rdsUnlockAndCall.htm" title="А.5.3.4. rdsUnlockAndCall &ndash; вызвать функцию, сняв блокировку данных">rdsUnlockAndCall</a></span>.</p>
</div>
</div>
<div class="level">
<p><a href="pm_2_8_1.htm" id="light_htm:pm_2_8">&sect;2.8. Сохранение и загрузка параметров блока</a></p>
<p class="abstract">Рассматриваются процедуры сохранения и загрузки личных параметров блока в файле схемы. Описывается более
            простой двоичный способ сохранения и более сложный &ndash; текстовый. Для текстового режима приводятся разные
            способы хранения данных: формат с ключевыми словами и формат, аналогичный стандартным INI-файлам
            (&laquo;имя=значение&raquo;). Рассматриваются вспомогательные объекты RDS, упрощающие разбор текста.</p>
<div class="level">
<p><a href="pm_2_8_1.htm" id="light_htm:pm_2_8_1">&sect;2.8.1. Способы хранения параметров блока</a></p>
<p class="abstract">Рассматриваются двоичный и текстовый форматы хранения личных данных блока в файле или буфере обмена,
                указываются преимущества и недостатки обоих форматов.</p>
</div>
<div class="level">
<p><a href="pm_2_8_2.htm" id="light_htm:pm_2_8_2">&sect;2.8.2. Сохранение параметров в двоичном формате</a></p>
<p class="abstract">Рассматривается сохранение и загрузка личных данных блока в двоичном формате, описываются
                соответствующие реакции модели (<span class="cpp"><a href="RDS_BFM_SAVEBIN.htm" title="А.2.5.6. RDS_BFM_SAVEBIN &ndash; запись данных блока в двоичном формате">RDS_BFM_SAVEBIN</a></span> и <span class="cpp"><a href="RDS_BFM_LOADBIN.htm" title="А.2.5.4. RDS_BFM_LOADBIN &ndash; загрузка данных блока в двоичном формате">RDS_BFM_LOADBIN</a></span>
                соответственно). В один из ранее описанных примеров добавляется сохранение и загрузка
                параметров в двоичном формате.</p>
</div>
<div class="level">
<p><a href="pm_2_8_3.htm" id="light_htm:pm_2_8_3">&sect;2.8.3. Сохранение параметров в текстовом формате</a></p>
<p class="abstract">Рассматривается сохранение и загрузка параметров блока в текстовом формате, описываются
                соответствующие реакции модели (<span class="cpp"><a href="RDS_BFM_SAVETXT.htm" title="А.2.5.7. RDS_BFM_SAVETXT &ndash; запись данных блока в текстовом формате">RDS_BFM_SAVETXT</a></span> и <span class="cpp"><a href="RDS_BFM_LOADTXT.htm" title="А.2.5.5. RDS_BFM_LOADTXT &ndash; загрузка данных блока в текстовом формате">RDS_BFM_LOADTXT</a></span>).
                В модель ранее описанного в примерах блока-генератора добавляются процедуры для хранения его параметров в
                текстовом виде.</p>
</div>
<div class="level">
<p><a href="pm_2_8_4.htm" id="light_htm:pm_2_8_4">&sect;2.8.4. Поиск ключевых слов с помощью объекта RDS</a></p>
<p class="abstract">Рассматривается вспомогательный объект RDS, облегчающий поиск ключевых слов в
                текстовом формате хранения личных данных блока. Модель из предыдущего примера переписывается с использованием
                этого объекта.</p>
</div>
<div class="level">
<p><a href="pm_2_8_5.htm" id="light_htm:pm_2_8_5">&sect;2.8.5. Сохранение параметров блока в формате INI-файла</a></p>
<p class="abstract">Рассматривается вспомогательный объект RDS, позволяющий организовать хранение личных данных
                блока в текстовом формате, похожем на стандартные INI-файлы Windows (&laquo;имя=значение&raquo;). В один
                из предыдущих примеров добавляются процедуры сохранения и загрузки параметров с использованием этого объекта.</p>
</div>
</div>
<div class="level">
<p><a href="pm_2_9_1.htm" id="light_htm:pm_2_9">&sect;2.9. Использование таймеров</a></p>
<p class="abstract">Рассматривается использование таймеров &ndash; объектов RDS, позволяющих организовать вызов модели
            блока через определенные промежутки времени. Описываются циклические таймеры, вызывающие модель постоянно с
            заданным интервалом, и однократные, вызывающие модель один раз через указанный промежуток времени и
            требующие явного перезапуска. Отдельно рассматриваются особенности работы модели блока с несколькими таймерами
            одновременно.</p>
<div class="level">
<p><a href="pm_2_9_1.htm" id="light_htm:pm_2_9_1">&sect;2.9.1. Таймеры в RDS</a></p>
<p class="abstract">Описывается создание таймеров в RDS, режимы их работы и возможные способы вызова
                модели блока при срабатывании таймера.</p>
</div>
<div class="level">
<p><a href="pm_2_9_2.htm" id="light_htm:pm_2_9_2">&sect;2.9.2. Циклический таймер</a></p>
<p class="abstract">Описывается циклический таймер, постоянно вызывающий модель блока через заданный интервал времени.
                Рассматривается пример блока, изображающего мигающую индикаторную лампочку.</p>
</div>
<div class="level">
<p><a href="pm_2_9_3.htm" id="light_htm:pm_2_9_3">&sect;2.9.3. Однократно срабатывающий таймер</a></p>
<p class="abstract">Описывается таймер, однократно вызывающий модель блока по истечении заданного интервала. Рассматривается
                пример блока, изображающего мигающую индикаторную лампочку, длительность горения которой не равна
                длительности паузы (после каждого срабатывания таймер перезапускается с новой задержкой).</p>
</div>
<div class="level">
<p><a href="pm_2_9_4.htm" id="light_htm:pm_2_9_4">&sect;2.9.4. Несколько таймеров в одной модели</a></p>
<p class="abstract">Рассматриваются особенности работы модели блока с несколькими таймерами одновременно. Приводится
                пример блока, изображение которого вращается (для чего используется первый таймер) и мигает (по сигналу
                от второго таймера).</p>
</div>
</div>
<div class="level">
<p><a href="pm_2_10_1.htm" id="light_htm:pm_2_10">&sect;2.10. Программное рисование внешнего вида блока</a></p>
<p class="abstract">Рассматриваются способы программного рисования внешнего вида блоков в окне подсистемы и вывод
            дополнительных изображений поверх блоков. Также рассматривается создание в окнах подсистем специальных панелей,
            на которых блоки блоки могут размещать элементы управления Windows или использовать их для вывода изображений,
            формируемых сторонними библиотеками. В частности, приводится пример построения на панели трехмерного изображения
            при помощи библиотеки OpenGL.</p>
<div class="level">
<p><a href="pm_2_10_1.htm" id="light_htm:pm_2_10_1">&sect;2.10.1. Рисование изображения блока в окне подсистемы</a></p>
<p class="abstract">Рассматривается программное рисование внешнего вида блоков на примере простого вертикального
                индикатора уровня и построения графика зависимости значения входа блока от системной переменной времени.</p>
</div>
<div class="level">
<p><a href="pm_2_10_2.htm" id="light_htm:pm_2_10_2">&sect;2.10.2. Оптимизация рисования</a></p>
<p class="abstract">Рассматриваются различные способы ускорения программного рисования внешнего вида блоков. Два из
                этих способов используются для улучшения работы графика из примера, описанного в
                <a href="pm_2_10_1.htm" title="&sect;2.10.1. Рисование изображения блока в окне подсистемы">&sect;2.10.1</a>.</p>
</div>
<div class="level">
<p><a href="pm_2_10_3.htm" id="light_htm:pm_2_10_3">&sect;2.10.3. Дополнительное рисование</a></p>
<p class="abstract">Рассматривается рисование дополнительных элементов поверх изображения блока. В описанный
                ранее график добавляется рисование иконки, указывающей на отсутствие доступа к необходимой ему
                переменной времени.</p>
</div>
<div class="level">
<p><a href="pm_2_10_4.htm" id="light_htm:pm_2_10_4">&sect;2.10.4. Панели блоков в окне подсистемы</a></p>
<p class="abstract">Рассматривается создание панелей &ndash; отдельных окон, принадлежащих блокам и находящихся
                внутри окна подсистемы. Такие панели нужны для размещения в них полей ввода или привязки к ним вывода
                внешних библиотек. Приводится пример блока, создающего пустую панель, которую пользователь может открывать,
                закрывать и перемещать. Затем этот пример модифицируется, и с панелью связывается область вывода
                трехмерной библиотеки OpenGL, а блок становится индикатором трех угловых координат, рисующим
                на панели поворачивающийся трехмерный объект.</p>
</div>
</div>
<div class="level">
<p><a href="pm_2_11.htm" id="light_htm:pm_2_11">&sect;2.11. Отображение всплывающих подсказок к блокам</a></p>
<p class="abstract">Рассматривается вывод различных текстов во всплывающих подсказках к блокам.
            Приводятся примеры отображения в подсказке настроечных параметров блока-генератора и координат ближайшей к
            курсору точки графика.</p>
</div>
<div class="level">
<p><a href="pm_2_12_1.htm" id="light_htm:pm_2_12">&sect;2.12. Реакция блоков на действия пользователя</a></p>
<p class="abstract">Рассматриваются различные способы организации взаимодействия блоков схемы с пользователем: реакция на
            мышь и клавиатуру, добавление новых пунктов в контекстное меню блока и системное меню RDS. Отдельно описываются
            реакции на действия пользователя при редактировании схемы: добавление блоков, их удаление, изменение их
            размеров и т.п.</p>
<div class="level">
<p><a href="pm_2_12_1.htm" id="light_htm:pm_2_12_1">&sect;2.12.1. Реакция на мышь</a></p>
<p class="abstract">Рассматриваются возможные реакции модели блока на действия пользователя мышью.
                Приводится пример блока, позволяющего щелчками по верхней и нижней части его изображения увеличивать и уменьшать
                значение его выхода. Затем в модель блока добавляется реакция на щелчки по активным элементам векторной
                картинки.</p>
</div>
<div class="level">
<p><a href="pm_2_12_2.htm" id="light_htm:pm_2_12_2">&sect;2.12.2. Захват мыши, реакция на перемещение курсора</a></p>
<p class="abstract">Рассматривается реакция модели блока на перемещение курсора мыши и захват мыши &ndash; режим,
                в котором блок реагирует на мышь даже при выходе курсора за его изображение. Приводится пример блока,
                изображающего рукоятку, которую можно двигать мышью по двум координатам, изменяя таким образом значения выходов
                блока.</p>
</div>
<div class="level">
<p><a href="pm_2_12_3.htm" id="light_htm:pm_2_12_3">&sect;2.12.3. Реакция на мышь в блоках сложной формы</a></p>
<p class="abstract">Рассматриваются особенности реакции на мышь в перекрывающихся блоках сложной формы,
                в которых часть изображения одного блока просматривается сквозь изображение другого. Приводится пример блока
                с &laquo;отверстием&raquo;, которое может открываться и закрываться, разрешая или запрещая тем самым
                щелчки мышью по полю ввода, видимому в отверстии.</p>
</div>
<div class="level">
<p><a href="pm_2_12_4.htm" id="light_htm:pm_2_12_4">&sect;2.12.4. Реакция блоков на клавиатуру</a></p>
<p class="abstract">Рассматривается реакция модели блока на нажатие и отпускание клавиш. В один из рассмотренных ранее
                примеров добавляется возможность увеличивать и уменьшать значение выхода блока нажатием клавиш.</p>
</div>
<div class="level">
<p><a href="pm_2_12_5.htm" id="light_htm:pm_2_12_5">&sect;2.12.5. Реакция окон подсистем на мышь и клавиатуру</a></p>
<p class="abstract">Рассматривается возможность реакции модели подсистемы на действия мышью и нажатие и отпускание
                клавиш в ее окне, если ни один из внутренних блоков не среагировал на это событие. Приводится пример модели
                подсистемы, которая перемещает окно по курсорным клавишам и меняет свой масштаб по щелчку правой кнопкой
                мыши.</p>
</div>
<div class="level">
<p><a href="pm_2_12_6.htm" id="light_htm:pm_2_12_6">&sect;2.12.6. Добавление пунктов в контекстное меню блока</a></p>
<p class="abstract">Рассматривается добавление дополнительных (постоянных и временных) пунктов в контекстное меню блока,
                вызываемое по правой кнопке мыши. В созданный ранее блок, имитирующий двухкоординатную рукоятку, добавляется
                возможность фиксировать одну из координат рукоятки, включаемая и выключаемая через контекстное меню.
                В другой блок, управляющий полем ввода, также добавляется возможность переключения состояния блока пунктом
                контекстного меню.</p>
</div>
<div class="level">
<p><a href="pm_2_12_7.htm" id="light_htm:pm_2_12_7">&sect;2.12.7. Добавление пунктов в системное меню RDS</a></p>
<p class="abstract">Описывается возможность добавления моделями блоков собственных пунктов в меню &laquo;<span class="menu">система</span>&raquo;.
                Рассматривается пример блока, открывающего окно своей подсистемы при выборе пункта системного меню или при
                нажатии связанной с этим пунктом &laquo;горячей клавиши&raquo;.</p>
</div>
<div class="level">
<p><a href="pm_2_12_8.htm" id="light_htm:pm_2_12_8">&sect;2.12.8. Реакция на действия пользователя при редактировании схемы</a></p>
<p class="abstract">Рассматриваются различные реакции модели на действия пользователя, связанные с редактированием схемы:
                добавлением и удалением блоков, изменением их размера и т.п. В рассмотренные ранее примеры добавляются новые
                функции, влияющие на редактирование схемы пользователем.</p>
</div>
</div>
<div class="level">
<p><a href="pm_2_13_1.htm" id="light_htm:pm_2_13">&sect;2.13. Вызов функций блоков</a></p>
<p class="abstract">Рассматриваются различные способы вызова функций блоков, то есть вызова модели какого-либо
            блока из модели другого блока. Приводятся примеры использования этого механизма для организации сложного
            взаимодействия между блоками схемы.</p>
<div class="level">
<p><a href="pm_2_13_1.htm" id="light_htm:pm_2_13_1">&sect;2.13.1. Общие принципы вызова функций блоков</a></p>
<p class="abstract">Рассматриваются общие принципы вызова функций блоков. Описывается регистрация функций блоков в
                RDS, необходимая для их работы, простейший способ вызова функций, а также включение в модель
                блока реакции на вызов такой функции.</p>
</div>
<div class="level">
<p><a href="pm_2_13_2.htm" id="light_htm:pm_2_13_2">&sect;2.13.2. Прямой вызов функции одного блока</a></p>
<p class="abstract">Рассматривается вызов функции блока, идентификатор которого известен вызывающей модели.
                Приводятся примеры использования функции &laquo;Common.ControlValueChanged&raquo;, которая используется
                блоками пользовательского интерфейса из библиотеки &laquo;<span class="file">Common.dll</span>&raquo; для общения между собой.
                В двухкоординатную рукоятку и блок увеличения/уменьшения, созданные ранее, добавляется поддержка этой
                функции, что позволяет соединять их со стандартными полями ввода и синхронно изменять значения блоков
                в режиме моделирования.</p>
</div>
<div class="level">
<p><a href="pm_2_13_3.htm" id="light_htm:pm_2_13_3">&sect;2.13.3. Прямой вызов функции всех блоков подсистемы</a></p>
<p class="abstract">Рассматривается вызов функции всех блоков одной подсистемы. В созданную ранее модель блока,
                управляющего полем ввода, добавляется возможность одновременного открытия, закрытия и переключения состояния
                всех таких блоков, находящихся в одной и той же подсистеме.</p>
</div>
<div class="level">
<p><a href="pm_2_13_4.htm" id="light_htm:pm_2_13_4">&sect;2.13.4. Пример использования функций блоков для поиска пути в графе</a></p>
<p class="abstract">Рассматривается пример использования функций блоков для поиска в ориентированном графе,
                состоящем из блоков и соединяющих их связей, кратчайшего пути между двумя узлами. Используется вызов функций с
                параметрами и без них, вызов функции конкретного блока и всех блоков подсистемы.</p>
</div>
<div class="level">
<p><a href="pm_2_13_5.htm" id="light_htm:pm_2_13_5">&sect;2.13.5. Отложенный вызов функций блоков</a></p>
<p class="abstract">Рассматривается отложенный вызов функций блоков, позволяющий избежать переполнения стека при глубокой
                рекурсии вызовов. В примере, рассмотренном в <a href="pm_2_13_4.htm" title="&sect;2.13.4. Пример использования функций блоков для поиска пути в графе">&sect;2.13.4</a>, прямые вызовы заменяются
                на отложенные.</p>
</div>
<div class="level">
<p><a href="pm_2_13_6.htm" id="light_htm:pm_2_13_6">&sect;2.13.6. Регистрация исполнителя функции</a></p>
<p class="abstract">Рассматривается механизм регистрации блока в качестве исполнителя какой-либо функции,
                позволяющий остальным блокам схемы легко находить его идентификатор и вызывать эту функцию. В
                приводимом примере один блок регистрируется как исполнитель функции вывода сообщения, а
                другой выводит сообщение с его помощью.</p>
</div>
</div>
<div class="level">
<p><a href="pm_2_14_1.htm" id="light_htm:pm_2_14">&sect;2.14. Программное управление расчетом</a></p>
<p class="abstract">Рассматриваются сервисные функции, позволяющие останавливать, перезапускать и сбрасывать расчет. С
            их помощью можно выполнять сложные итерационные вычисления.</p>
<div class="level">
<p><a href="pm_2_14_1.htm" id="light_htm:pm_2_14_1">&sect;2.14.1. Запуск и остановка расчета</a></p>
<p class="abstract">Описывается использование сервисных функций для запуска и остановки расчета. Приводится
                пример блока, запускающего и останавливающего расчет при нажатии кнопки мыши на его изображении,
                а также останавливающего расчет поступлении сигнала на вход.</p>
</div>
<div class="level">
<p><a href="pm_2_14_2.htm" id="light_htm:pm_2_14_2">&sect;2.14.2. Сброс подсистемы в начальное состояние</a></p>
<p class="abstract">Описывается программный сброс расчета, то есть способ возврата какой-либо подсистемы или всей
                схемы в начальное состояние. Рассматриваются два примера, использующих программный сброс расчета: поиск
                угла возвышения метательной машины, при котором снаряд летит на заданную дальность, и построение
                графика зависимости дальности полета снаряда от угла возвышения этой машины.</p>
</div>
<div class="level">
<p><a href="pm_2_14_3.htm" id="light_htm:pm_2_14_3">&sect;2.14.3. Сохранение и загрузка состояния блоков</a></p>
<p class="abstract">Описывается механизм возврата блоков в запомненное состояние. Рассматривается пример, в
                котором запоминание состояния подсистемы и возврат к этому состоянию производятся по команде
                пользователя.</p>
</div>
<div class="level">
<p><a href="pm_2_14_4.htm" id="light_htm:pm_2_14_4">&sect;2.14.4. Отдельный расчет подсистемы</a></p>
<p class="abstract">Рассматривается механизм временной остановки расчета всей схемы кроме одной единственной подсистемы. 
                Приводится пример блока, переводящего родительскую подсистему в режим отдельного расчета для того, 
                чтобы цепочка блоков в этой подсистеме не создавала паразитных задержек.</p>
</div>
<div class="level">
<p><a href="pm_2_14_5.htm" id="light_htm:pm_2_14_5">&sect;2.14.5. Вызов модели блока перед тактом расчета</a></p>
<p class="abstract">Рассматривается специальный режим вызова модели блока непосредственно перед тактом расчета 
                (<span class="cpp"><a href="RDS_BFM_PREMODEL.htm" title="А.2.4.10. RDS_BFM_PREMODEL &ndash; вызов модели перед тактом расчета">RDS_BFM_PREMODEL</a></span>). Описанный в <a href="pm_2_14_4.htm" title="&sect;2.14.4. Отдельный расчет подсистемы">&sect;2.14.4</a> пример блока, ускоряющего работу 
                подсистемы, модифицируется так, чтобы блоки подсистемы срабатывали до блоков остальной части схемы.</p>
</div>
</div>
<div class="level">
<p><a href="pm_2_15_1.htm" id="light_htm:pm_2_15">&sect;2.15. Обмен данными по сети</a></p>
<p class="abstract">Рассматриваются способы обмена данными между схемами, работающими на разных машинах. Приводятся 
            примеры моделей блоков, осуществляющих такой обмен.</p>
<div class="level">
<p><a href="pm_2_15_1.htm" id="light_htm:pm_2_15_1">&sect;2.15.1. Общие принципы обмена данными по сети в RDS</a></p>
<p class="abstract">Рассматривается механизм обмена данными по сети между блоками RDS. Описываются основные сервисные 
                функции и структуры и способ их использования.</p>
</div>
<div class="level">
<p><a href="pm_2_15_2.htm" id="light_htm:pm_2_15_2">&sect;2.15.2. Пример использования функций передачи и приема данных</a></p>
<p class="abstract">Приводятся примеры моделей блоков, позволяющих организовать передачу вещественного значения 
                между схемами, работающими на разных машинах. В дополнение к ним описывается модель блока, добавление которого 
                в схему включает серверные функции в RDS.</p>
</div>
<div class="level">
<p><a href="pm_2_15_3.htm" id="light_htm:pm_2_15_3">&sect;2.15.3. Способы снижения нагрузки на сеть</a></p>
<p class="abstract">Рассматриваются два способа снижения нагрузки на сеть: ограничение минимального интервала между 
                моментами передачи данных и объединение передаваемых данных в один блок. Приводятся примеры реализации 
                этих способов.</p>
</div>
</div>
<div class="level">
<p><a href="pm_2_16_1.htm" id="light_htm:pm_2_16">&sect;2.16. Программное изменение схемы</a></p>
<p class="abstract">Рассматриваются способы программной модификации схемы. Приводятся примеры блоков, 
            изменяющих свою структуру переменных, а также добавляющих в схему и 
            удаляющих из нее другие блоки и связи.</p>
<div class="level">
<p><a href="pm_2_16_1.htm" id="light_htm:pm_2_16_1">&sect;2.16.1. Изменение структуры переменных блока</a></p>
<p class="abstract">Рассматриваются функции для программного изменения структуры статических переменных 
                блока из его модели. Модель одного из ранее рассмотренных блоков изменяется так, чтобы она сама 
                корректировала переменные, если они ей не подходят. Описывается модель блока, предоставляющего пользователю 
                интерфейс для ограниченного редактирования своих переменных.</p>
</div>
<div class="level">
<p><a href="pm_2_16_2.htm" id="light_htm:pm_2_16_2">&sect;2.16.2. Добавление и удаление блоков и связей</a></p>
<p class="abstract">Рассматриваются функции для программного добавления в схему новых блоков и связей и для их удаления. 
                Приводится пример блока, который по двум текстовым файлам, содержащим список блоков и соединений между ними, 
                создает в подсистеме новый фрагмент схемы.</p>
</div>
</div>
</div>
<div class="level">
<p><a href="pm_3_1.htm" id="light_htm:pm_3">Глава 3. Управление RDS из других приложений</a></p>
<p class="abstract">Рассматриваются методы выполнения в RDS различных действий по команде от внешнего 
        приложения, передачи информации от внешнего приложения блокам схемы и обратно. Использование внешнего управления 
        позволяет включать RDS в состав более сложных программных комплексов в качестве составной части.</p>
<div class="level">
<p><a href="pm_3_1.htm" id="light_htm:pm_3_1">&sect;3.1. Общие принципы управления RDS</a></p>
<p class="abstract">Рассматриваются общие принципы использования библиотеки RdsCtrl.dll для управления RDS 
            из другого приложения Windows. Приводится исходный текст тестовой программы, в которую позже 
            будут добавлены вызовы для управления RDS и для реакции на различные события, происходящие 
            в загруженной схеме.</p>
</div>
<div class="level">
<p><a href="pm_3_2.htm" id="light_htm:pm_3_2">&sect;3.2. Загрузка библиотеки и управление схемой</a></p>
<p class="abstract">Рассматривается простой пример управления схемой из внешнего приложения. В программу, созданную в 
            <a href="pm_3_1.htm" title="&sect;3.1. Общие принципы управления RDS">&sect;3.1</a>, добавляются функции для запуска RDS, загрузки 
            выбранной пользователем схемы и переключения режимов работы RDS.</p>
</div>
<div class="level">
<p><a href="pm_3_3.htm" id="light_htm:pm_3_3">&sect;3.3. Вызов функции блока загруженной схемы</a></p>
<p class="abstract">Рассматривается передача информации конкретному блоку загруженной схемы и получение от него ответа, 
            а также способ поиска блока по символическому имени выполняемой им операции. В программу, созданную в 
            <a href="pm_3_2.htm" title="&sect;3.2. Загрузка библиотеки и управление схемой">&sect;3.2</a>, добавляются функции вызова и поиска блоков.</p>
</div>
<div class="level">
<p><a href="pm_3_4.htm" id="light_htm:pm_3_4">&sect;3.4. Реакция на события и сообщения от блоков</a></p>
<p class="abstract">Рассматривается вызов специальным образом зарегистрированных функций управляющей программы при возникновении 
            различных событий в RDS и в ответ на вызовы от блоков загруженной схемы. В созданную ранее модель поиска 
            угла возвышения метательной машины (<a href="pm_2_14_2.htm" title="&sect;2.14.2. Сброс подсистемы в начальное состояние">&sect;2.14.2</a>) добавляются вызовы 
            и реакции, позволяющие схеме с этой моделью обмениваться данными с управляющей программой. Дополнительно 
            рассматривается пример блока-кнопки, сообщающего управляющей программе о щелчке на 
            его изображении.</p>
</div>
<div class="level">
<p><a href="pm_3_5.htm" id="light_htm:pm_3_5">&sect;3.5. Вмешательство в загрузку и сохранение схемы</a></p>
<p class="abstract">Рассматриваются методы перехвата событий загрузки и сохранения схемы, которые позволяют 
            управляющему приложению вмешаться в эти процессы для самостоятельной организации хранения схем (например, 
            в базе данных). В рассматриваемый пример программы добавляются функции, позволяющие сохранять схему в 
            виде набора отдельных файлов, каждый из которых соответствует блоку или связи, и загружать схему из 
            такого набора.</p>
</div>
<div class="level">
<p><a href="pm_3_6_1.htm" id="light_htm:pm_3_6">&sect;3.6. Отображение схемы RDS в собственном окне приложения</a></p>
<p class="abstract">Рассматривается возможность отображения подсистем загруженной в RDS схемы не в отдельных окнах, 
            а внутри окна управляющего приложения. Приводится пример программы, реализующей эту возможность и 
            основные функции пользовательского интерфейса для взаимодействия с блоками схемы.</p>
<div class="level">
<p><a href="pm_3_6_1.htm" id="light_htm:pm_3_6_1">&sect;3.6.1. Общие принципы работы с портом вывода</a></p>
<p class="abstract">Рассматривается общая структура программы, отображающей схему внутри своего окна. Приводится исходный текст 
                такой программы, в которую позже будут добавлены необходимые для ее работы функции обмена данными с RDS.</p>
</div>
<div class="level">
<p><a href="pm_3_6_2.htm" id="light_htm:pm_3_6_2">&sect;3.6.2. Рисование и прокрутка изображения</a></p>
<p class="abstract">Рассматриваются функции для создания и настройки порта вывода, привязки к нему подсистемы и рисования 
                в нем изображения. Эти функции добавляются в программу, созданную в <a href="pm_3_6_1.htm" title="&sect;3.6.1. Общие принципы работы с портом вывода">&sect;3.6.1</a>.</p>
</div>
<div class="level">
<p><a href="pm_3_6_3.htm" id="light_htm:pm_3_6_3">&sect;3.6.3. Смена отображаемой в порте подсистемы</a></p>
<p class="abstract">В описываемый пример программы добавляются функции, позволяющие пользователю переходить от подсистемы 
                к подсистеме в одном и том же порте вывода.</p>
</div>
<div class="level">
<p><a href="pm_3_6_4.htm" id="light_htm:pm_3_6_4">&sect;3.6.4. Реакция на мышь и клавиатуру</a></p>
<p class="abstract">В рассматриваемый пример программы добавляется реакция блоков отображаемой подсистемы 
                на мышь и клавиатуру.</p>
</div>
<div class="level">
<p><a href="pm_3_6_5.htm" id="light_htm:pm_3_6_5">&sect;3.6.5. Работа с контекстным меню блока</a></p>
<p class="abstract">В рассматриваемый пример программы добавляется вывод контекстного меню блока или подсистемы, 
                пункты которого запрашиваются у RDS.</p>
</div>
<div class="level">
<p><a href="pm_3_6_6.htm" id="light_htm:pm_3_6_6">&sect;3.6.6. Вывод всплывающих подсказок</a></p>
<p class="abstract">В рассматриваемый пример программы добавляется вывод всплывающих подсказок, текст и 
                параметры которых определяются блоками отображаемой схемы.</p>
</div>
</div>
</div>
<div class="level">
<p><a href="pm_4_1.htm" id="light_htm:pm_4">Глава 4. Создание модулей автоматической компиляции</a></p>
<p class="abstract">Описывается принцип создания модулей автокомпиляции, которые по введенному пользователем тексту могут формировать и компилировать модель блока. Рассматривается пример такого модуля для создания простых моделей в синтаксисе языка C.</p>
<div class="level">
<p><a href="pm_4_1.htm" id="light_htm:pm_4_1">&sect;4.1. Принцип работы модулей автокомпиляции</a></p>
<p class="abstract">Рассматривается структура данных модуля автокомпиляции и его функции, описывается последовательность 
            вызовов функции модуля при подключении и отключении моделей и выполнении компиляции.</p>
</div>
<div class="level">
<p><a href="pm_4_2.htm" id="light_htm:pm_4_2">&sect;4.2. Инициализация, очистка и настройка параметров модуля</a></p>
<p class="abstract">Рассматривается пример модуля автоматической компиляции, функция которого реагирует пока 
            только на самые основные вызовы: инициализацию данных, очистку данных и вызов окна настройки. Созданный модуль 
            регистрируется в RDS.</p>
</div>
<div class="level">
<p><a href="pm_4_3.htm" id="light_htm:pm_4_3">&sect;4.3. Подключение моделей к блокам и вызов редактора</a></p>
<p class="abstract">В созданный в <a href="pm_4_2.htm" title="&sect;4.2. Инициализация, очистка и настройка параметров модуля">&sect;4.2</a> модуль автоматической компиляции 
            добавляются функции, необходимые для подключения моделей к блокам. Рассматривается простой 
            пример текстового формата модели, в модуль добавляется редактор таких моделей.</p>
</div>
<div class="level">
<p><a href="pm_4_4.htm" id="light_htm:pm_4_4">&sect;4.4. Компиляция моделей</a></p>
<p class="abstract">Описывается способ формирования исходного текста модели блока на языке C и 
            вызова для этого текста внешнего компилятора.</p>
</div>
</div>
</div>


<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="disbutton">&lt;&lt;</span>
<span class="button"><a href="pm_1_1.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm">Описание пользователя</a></span>
<span class="disbutton">Руководство программиста</span>
<span class="button"><a href="app_index.htm">Приложения</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
