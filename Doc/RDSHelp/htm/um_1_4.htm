<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;1.4. Статические переменные блоков</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_1">Глава 1. Необходимые сведения об устройстве RDS</a></p>
<div class="level"><p>&sect;1.4. Статические переменные блоков</p>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_1_3.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_1_5.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_1_4">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 1. Необходимые сведения об устройстве RDS</h2>
<h3>&sect;1.4. Статические переменные блоков</h3>
<p class="abstract">Описываются типы статических переменных блоков. Эти переменные могут использоваться как входы и выходы для присоединения связей.</p>

<p>Как уже упоминалось в <a href="um_1_2.htm" title="&sect;1.2. Блоки и связи в RDS, их типы и основные параметры">&sect;1.2</a>, блок в RDS
может иметь
статические и динамические переменные. Статические переменные, как правило,
создаются вместе с блоком и используются как входы и выходы или для хранения
промежуточных значений. Динамические переменные создаются и уничтожаются моделью блока
программно и используются для скрытой от пользователя передачи данных между блоками.
Со статическими переменными пользователь сталкивается чаще всего (например, при
<a href="um_2_7_1.htm" title="&sect;2.7.1. Общие принципы создания связей">создании связей</a> между блоками),
поэтому сначала рассмотрим их.</p>

<p>Каждая статическая переменная имеет имя, уникальное в данном блоке. Именно это имя
пользователь видит в
<a href="um_2_7_1.htm#pic2" title="Начало создания связи через контекстное меню (а) или при помощи щелчка мыши с нажатой клавишей Ctrl (б)">меню подключения связи</a>
к блоку или в
<a href="um_2_9_1.htm#pic9" title="Вкладка соединения окна параметров блока">списке соединений блока</a>. Имя переменной должно
содержать только буквы латинского алфавита, цифры и знак подчеркивания, и при этом
оно не должно начинаться с цифры. Имена чувствительны к регистру, поэтому,
например, &laquo;<span class="rdsvar">Start</span>&raquo; и &laquo;<span class="rdsvar">start</span>&raquo; будут считаться разными
переменными.</p>

<p><span id="ref1">Переменные</span>
блока в RDS могут иметь один из следующих
<span id="light_ref1">типов</span>:</p>

<dl>
  <dt><span class="term"><span id="light_ref2">Сигнал</span></span>
  (возможные значения: 0 и 1)</dt>
  <dd>Сигналы
  служат для передачи информации о наступлении каких-либо событий и передаются по
  связям особенным образом, отличным от других переменных. Сигнал с выхода блока
  передается по связи на входы блоков, соединенных с ним, только в том случае, если его
  значение равно 1. При этом после передачи значение выхода автоматически сбрасывается
  в 0, и, таким образом, блокируется повторная передача информации о том же самом
  событии. Поскольку нулевое значение сигнала никогда не передается по связи, модель
  блока, обнаружившая на сигнальном входе единицу, сама должна сбросить ее в 0, чтобы
  подготовится к приему информации о следующем событии. Подробнее использование сигналов
  и обработка их в моделях блоков рассматривается в
  <a href="pm_2_5_2.htm" title="&sect;2.5.2. Особенности использования сигналов">&sect;2.5.2 руководства программиста</a> и
  <a href="um_3_7_2_6.htm" title="&sect;3.7.2.6. Использование сигналов">&sect;3.7.2.6 описания пользователя</a>
  (для <a href="um_index.htm#light_htm:um_3" title="Глава 3. Использование стандартных модулей автокомпиляции">автокомпилируемых</a> моделей).</dd>

  <dt><span class="term"><span id="light_ref3">Логический</span></span>
  тип (возможные значения: 0 и 1)</dt>
  <dd>Нулевое значение переменной считается ложью, единичное &ndash; истиной.</dd>

  <dt><span class="term"><span id="light_ref4">char</span></span>
  (диапазон значений: &minus;128&thinsp;&hellip;&thinsp;127)</dt>
  <dd>Однобайтовая переменная,
  предназначенная для хранения небольших целых чисел или кодов символов,
  полностью эквивалентная типу
  <span class="cpp">signed char</span>
  в C++. Этот тип используется в блоках редко,
  в основном, для совместимости со старыми моделями. Для работы с целыми числами чаще
  всего используется тип int.</dd>

  <dt><span class="term"><span id="light_ref5">short</span></span>
  (диапазон значений: &minus;32768&thinsp;&hellip;&thinsp;32767)</dt>
  <dd>Целая двухбайтовая переменная, эквивалентная типу <span class="cpp">short int</span> в
  C++. В настоящее время используется редко.</dd>

  <dt><span class="term"><span id="light_ref6">int</span></span>
  (диапазон значений: &minus;2147483648&thinsp;&hellip;&thinsp;2147483647)</dt>
  <dd>Основной в RDS тип для работы с целыми числами. Эквивалентен тридцатидвухбитному
  типу <span class="cpp">int</span> в C++.</dd>

  <dt><span class="term"><span id="light_ref7">float</span></span>
  (диапазон значений модуля числа:
  1.18&times;10<sup>&minus;38</sup>&thinsp;&hellip;&thinsp;3.40&times;10<sup>38</sup>)</dt>
  <dd>Вещественная
  переменная одинарной точности, эквивалентная одноименному типу в C++.
  Используется редко.</dd>

  <dt><span class="term"><span id="light_ref8">double</span></span>
  (диапазон значений модуля числа:
  2.23&times;10<sup>&minus;308</sup>&thinsp;&hellip;&thinsp;1.79&times;10<sup>308</sup>)</dt>
  <dd>Вещественная переменная двойной точности, эквивалентная одноименному типу в C++,
  используется во всех стандартных блоках для работы с вещественными числами.</dd>

  <dt><span class="term"><span id="light_ref10"><span id="ref9">Строка символов</span></span></span></dt>
  <dd>Используется для работы с текстами
  произвольной длины. Содержит последовательность символов, завершающуюся нулевым
  байтом, поэтому совместима со стандартными функциями обработки строк Windows и C++.
  В строках RDS всегда используется кодировка Windows
  <span id="light_ref9">CP1251</span>, многобайтовые символы
  Unicode не поддерживаются.</dd>

  <dt><span class="term"><span id="light_ref11">Матрица</span></span></dt>
  <dd>Матрица &ndash; это двумерная таблица переменных одного
  типа, в которой конкретный элемент определяется индексом строки и индексом столбца
  (индексы начинаются с нуля). Если матрица является входом или выходом блока,
  связи могут подключаться как к матрице в целом (при этом по связи будут передаваться
  все элементы матрицы одновременно), так и к
  <a href="um_2_7_3.htm" title="&sect;2.7.3. Подключение связей к полям структур и элементам массивов">отдельным ее элементам</a>. Для обращения к
  конкретному элементу после имени переменной-матрицы в квадратных скобках через
  запятую указываются индексы строки и столбца &ndash; например, элемент матрицы
  &laquo;<span class="rdsvar">M</span>&raquo;, находящийся в третьей строке и восьмом столбце, записывается
  как &laquo;<span class="rdsvar">M[2,7]</span>&raquo;. Тип элемента матрицы может быть любым, в том числе,
  и другой матрицей. Максимально допускается пятикратная вложенность матриц,
  т.е. &laquo;матрица матриц матриц матриц матриц какого-то типа&raquo;. Чаще всего
  в математических расчетах используются матрицы вещественных чисел, среди стандартных
  блоков RDS есть блоки, позволяющие вводить и отображать такие матрицы.</dd>

  <dt><span class="term"><span id="light_ref12">Массив</span></span></dt>
  <dd>Массив &ndash; это набор (вектор) переменных одного типа.
  Индексы элементов массива начинаются с нуля. Если массив является входом или
  выходом блока, связи могут подключаться как к массиву в целом, так и к
  <a href="um_2_7_3.htm" title="&sect;2.7.3. Подключение связей к полям структур и элементам массивов">отдельным его элементам</a>. Для обращения к
  конкретному элементу после имени переменной-массива указывается индекс в
  квадратных скобках &ndash; например, третий по счету (начиная с нулевого)
  элемент массива &laquo;<span class="rdsvar">M</span>&raquo; записывается как &laquo;<span class="rdsvar">M[2]</span>&raquo;.
  Тип элемента массива может быть любым, кроме другого массива. Если необходимо
  создать массив массивов, вместо него следует использовать массив матриц,
  поскольку матрица может быть элементом массива, а другой массив &ndash; нет.
  Чаще всего массивы используются для создания блоков с произвольным количеством
  одинаково обрабатываемых входов или выходов. Например, блок, имеющий вход в
  виде массива вещественных чисел и выдающий на единственный вещественный выход
  сумму всех элементов этого массива, может использоваться как сумматор, число
  входов которого может быть любым &ndash; пользователь просто подключает к разным
  элементам массива столько связей, сколько необходимо в данный момент.
  Такой сумматор входит в набор стандартных блоков RDS.</dd>

  <dt><span class="term"><span id="light_ref13">Произвольный тип</span></span></dt>
  <dd>Тип, который может изменяться в
  процессе работы блока. К входам произвольного типа можно подключать связи от
  выходов любого типа &ndash; в момент срабатывания связи такой вход получит тот же
  тип, что и выход, передавший ему значение. Выход произвольного типа может
  подстраиваться под разные типы значений при работе модели блока. Переменные
  произвольного типа обрабатываются RDS медленнее, чем другие, поэтому обычно
  они используются только для данных, тип которых заранее неизвестен (например,
  в моделях универсальных выключателей, мультиплексоров или демультиплексоров).</dd>

  <dt><span class="term"><span id="ref15"><span id="light_ref14">Структура</span></span></span></dt>
  <dd>Структура &ndash; это набор других переменных, каждая из которых имеет
  собственное имя и тип. Такие внутренние переменные называются
  <span class="term" id="light_ref15">полями</span> структуры.
  Связи могут подключаться как к структуре в целом, так и к ее
  <a href="um_2_7_3.htm" title="&sect;2.7.3. Подключение связей к полям структур и элементам массивов">отдельным полям</a>.
  <span id="ref16">У</span>
  структуры есть <span class="term" id="light_ref16">имя типа</span> &ndash; произвольная строка, связанная с данным
  конкретным набором полей. Например, стандартная структура с именем типа
  &laquo;<span class="rdsvar">Complex</span>&raquo; содержит два поля типа double:
  &laquo;<span class="rdsvar">Re</span>&raquo; и &laquo;<span class="rdsvar">Im</span>&raquo;. Структуры чаще всего используются для
  работы со сложными данными (например, структура упомянутого выше типа
  &laquo;<span class="rdsvar">Complex</span>&raquo; – с комплексными числами). Состав полей структуры может
  <a href="um_2_14.htm" title="&sect;2.14. Создание и изменение структур">редактироваться</a> пользователем,
  но следует иметь в виду, что блок, использующий структуру, может отказаться работать,
  если состав и последовательность полей этой структуры не будет соответствовать
  желаниям его разработчика.</dd>

</dl>

<p>Статические переменные <a href="um_1_2.htm#light_ref9" title="Простой блок">простого блока</a> задаются в
<a href="um_2_9_1.htm#pic8" title="Вкладка переменные окна параметров блока">окне его параметров</a>.
Пользователь редко редактирует
их самостоятельно &ndash; это требуется, в основном, при создании блоков-индикаторов с
анимированными картинками (пример такого блока приведен в
<a href="um_2_10_2.htm" title="&sect;2.10.2. Рисование прямоугольников и эллипсов">&sect;2.10.2</a>) и блоков с автоматически компилируемой
функцией модели (созданию таких блоков посвящена
<a href="um_index.htm#light_htm:um_3" title="Глава 3. Использование стандартных модулей автокомпиляции">глава 3 описания пользователя</a>). Попытка изменить структуру переменных
библиотечного блока может привести к его неработоспособности, о чем пользователю
выводится соответствующее предупреждение. Как правило, пользователь имеет дело со
статическими переменными уже готовых блоков, подключая к ним связи.</p>

<p><span id="ref20"><span id="ref19"><span id="ref18"><span id="ref17">Статическая переменная</span></span></span></span>
может быть <span id="light_ref20"><span class="term" id="light_ref17">входом</span> блока,
<span class="term" id="light_ref18">выходом</span> или
<span class="term" id="light_ref19">внутренней</span></span>.
К входам и выходам можно подключать связи, соединяя блоки с другими.
Внутренние переменные обычно используются разработчиком блока для хранения каких-либо
параметров или для того, чтобы связывать с ними подвижные элементы векторной
анимированной картинки.</p>

<div class="picright"><div class="container" id="pic1">
<img src="../img/ConnToMatrixElements.png" width="168" height="131" alt="Связи подключены к отдельным элементам матрицы" />
<p id="light_pic1">Рис.&nbsp;7. Связи подключены к<br />отдельным элементам матрицы</p>
</div></div>

<p>Соединение связями возможно не только между самими входами и выходами, но и между
отдельными элементами этих переменных. Например, вещественный выход может быть подключен
к конкретному элементу входа, являющемуся матрицей вещественных чисел
(<a href="#pic1" title="Связи подключены к отдельным элементам матрицы">рис.&nbsp;7</a>),
или к вещественному полю структуры-входа. Точно так же отдельное вещественное
поле структуры-выхода или отдельный элемент выхода-массива вещественных чисел может
быть подключен к вещественному входу.
<span id="ref21">Чтобы</span>
при присоединении связи подключить ее не к входу
или выходу целиком, а к отдельному его элементу, следует при
<a href="um_2_7_3.htm" title="&sect;2.7.3. Подключение связей к полям структур и элементам массивов">указании</a>
имен соединяемых переменных использовать следующий
<span id="light_ref21">синтаксис</span>:</p>

<ul>
  <li>поле структуры отделяется от ее имени точкой;</li>
  <li>индекс массива указывается числом в квадратных скобках после его имени;</li>
  <li>строка и столбец матрицы указываются двумя числами через запятую в квадратных скобках после ее имени.</li>
</ul>

<p>Например:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Запись в RDS</th>
    <th>Значение</th>
  </tr>
  <tr>
    <td>y</td>
    <td>переменная &laquo;<span class="rdsvar">y</span>&raquo;</td>
  </tr>
  <tr>
    <td>A[3]</td>
    <td>четвертый (т.е. с индексом 3) элемент массива &laquo;<span class="rdsvar">A</span>&raquo;</td>
  </tr>
  <tr>
    <td>M[0,1]</td>
    <td>элемент матрицы &laquo;<span class="rdsvar">M</span>&raquo;, находящийся в строке с индексом 0 (первой)
    и столбце с индексом 1 (втором)</td>
  </tr>
  <tr>
    <td>Out.Re</td>
    <td>поле &laquo;<span class="rdsvar">Re</span>&raquo; структуры &laquo;<span class="rdsvar">Out</span>&raquo;</td>
  </tr>
  <tr>
    <td>Y[2][0,1]</td>
    <td>элемент, находящийся в строке 0 и столбце 1 матрицы, которая является третьим
    (с индексом 2) элементом массива &laquo;<span class="rdsvar">Y</span>&raquo;</td>
  </tr>
  <tr>
    <td>A[3].Re</td>
    <td>поле &laquo;<span class="rdsvar">Re</span>&raquo; структуры, являющейся четвертым (с индексом 3)
    элементом массива &laquo;<span class="rdsvar">A</span>&raquo;</td>
  </tr>
  <tr>
    <td>A.data[3]</td>
    <td>четвертый (т.е. с индексом 3) элемент массива, находящегося в поле
    &laquo;<span class="rdsvar">data</span>&raquo; структуры &laquo;<span class="rdsvar">A</span>&raquo;</td>
  </tr>
</table>
</div></div>

<p>Подсистемы, внешние входы и внешние выходы тоже имеют статические переменные,
но формируются они не так, как у простых блоков. Входы и выходы подсистемы отражают
наличие в ней <a href="um_1_2.htm#light_ref12" title="Внешний вход подсистемы">блоков-входов</a>
и <a href="um_1_2.htm#light_ref14" title="Внешний выход подсистемы">блоков-выходов</a>, внутренних переменных подсистемы не
имеют. Пользователь может
<a href="um_2_11_4.htm#light_ref7" title="Переменные в окне параметров подсистемы">изменить</a> порядок переменных в подсистеме
(это влияет на порядок их отображения в меню подключения связи), но не может
добавлять и удалять их &ndash; вместо этого он должен добавлять и удалять
соответствующие блоки-входы и выходы внутри подсистемы. Внешние входы и выходы
имеют единственную переменную, для которой пользователь
<a href="um_2_11_2.htm#pic8" title="Окно параметров внешнего входа (окно параметров внешнего выхода выглядит точно так же)">задает</a>
только тип и имя. Будет эта переменная входом или выходом, определяется типом
самого блока: единственная переменная внешнего входа будет выходом, поскольку
внутри подсистемы этот блок передает данные, поступившие снаружи, а
единственная переменная внешнего выхода &ndash; входом.</p>

<p><span id="ref22">Каждая переменная</span>
блока имеет <span id="light_ref22">значение по умолчанию</span>,
которое автоматически присваивается ей при
создании блока, загрузке схемы из файла или при сбросе расчета.
Значение входа блока по умолчанию сохраняется до первого срабатывания связи, подключенной к
этому входу, значения по умолчанию выходов и внутренних переменных &ndash; до тех пор, пока
модель блока не запишет в эти переменные новые значения. Значение по умолчанию вводится
при <a href="um_2_9_2.htm" title="&sect;2.9.2. Редактирование списка переменных блока">создании</a> структуры переменных блока
в виде строки в специальном формате:</p>

<ul>
  <li>для <span class="term">логических</span> и <span class="term">сигналов</span>
  &ndash; цифры 1 или 0;</li>

  <li>для целых чисел (типы <span class="term">char</span>,
  <span class="term">short</span>, <span class="term">int</span>)
  &ndash; десятичное представление числа
  (например, &laquo;&minus;24&raquo;), двоичное представление числа с префиксом
  &laquo;0b&raquo; (например, строка &laquo;0b11&raquo; представляет число 3),
  восьмеричное представление числа с префиксом &laquo;0o&raquo; (например,
  строка &laquo;0o11&raquo; представляет число 9) или шестнадцатеричное
  представление числа с префиксом &laquo;0h&raquo; или &laquo;0x&raquo;
  (строка &laquo;0x1f&raquo; представляет число 31);</li>

  <li>для вещественных чисел (типы <span class="term">float</span>,
  <span class="term">double</span>) &ndash; запись с десятичной точкой
  (например, &laquo;3.14&raquo;) или в экспоненциальной форме с суффиксом
  &laquo;e&raquo; (например, &laquo;1.1e&minus;3&raquo; представляет число
  0.0011, то есть 1.1&times;10<sup>&minus;3</sup>);</li>

  <li>для <span class="term">строк</span> &ndash; последовательность символов,
  составляющая строку (например, &laquo;ABCD&raquo;);</li>

  <li>для <span class="term">массивов</span> &ndash; размер в квадратных скобках,
  за которым следует значение
  по умолчанию элемента (например, &laquo;[10]3.3&raquo; задает массив из десяти
  элементов, каждый из которых равен 3.3);</li>

  <li>для <span class="term">матриц</span> &ndash; число строк и столбцов через
  запятую в квадратных скобках,
  за которыми следует значение по умолчанию элемента (например, &laquo;[3,2]8&raquo;
  задает матрицу из трех строк и двух столбцов, каждый элемент которой равен 8);</li>

  <li>для <span class="term">структур</span> &ndash; значения по умолчанию всех
  полей через запятую в фигурных
  скобках (например, если комплексное число хранится в структуре с двумя вещественными
  полями, представляющими собой вещественную и мнимую части числа,
  строка &laquo;{1.2,3.4}&raquo; задает число 1.2&nbsp;+&nbsp;<i>i</i>&nbsp;3.4).</li>
</ul>

<p>Для массивов и матриц нельзя задать разные значения по умолчанию для отдельных
элементов, необходимо указать одно значение, которое будет присвоено всем элементам
матрицы или массива. Это значение будет использоваться не только при сбросе расчета,
но и при увеличении размера массива/матрицы в процессе самого расчета для инициализации
добавленных элементов. Можно указать только значение по умолчанию для добавляемых
элементов, не указывая размер &ndash; в этом случае квадратные скобки следует оставить
пустыми. Например, указав в качестве начального значения матрицы строку
&laquo;[&nbsp;]&nbsp;2&raquo;, можно добиться того, что при сбросе расчета
матрица будет пустой, а при увеличении числа ее строк и столбцов в процессе расчета
добавленные элементы будут получать значение 2.
Следует учитывать, что заданные по умолчанию размеры входов-матриц и массивов сохраняются 
только до первого срабатывания подключенной к входу связи: матрицы и массивы передаются по 
связям целиком, вместе с размерами и содержимым, поэтому после передачи данных по связи размер 
матрицы на входе станет равным размеру матрицы на выходе, который соединен с этим входом.</p>

<p>Для индикации текущего значения какого-либо выхода блока его обычно подключают
связью к специализированному блоку-индикатору, в параметрах которого задается
желаемый формат отображения. Например, на
<a href="um_1_2.htm#pic1" title="Простой блок с подключенными связями">рис.&nbsp;2</a>
выход блока &laquo;<span class="rdsvar">y</span>&raquo; подключен к числовому индикатору, отображающему его
в виде целого числа. Если требуется наблюдать изменение значения вещественной переменной
во времени, обычно ее подключают к
<a href="um_2_2.htm#pic3" title="Окно подсистемы после завершения расчета">графику</a>, для отображения матриц тоже
есть специализированные блоки и т.д. При отладке работы схемы можно посмотреть
значение любой переменной, включая внутренние, на вкладке
&laquo;<a href="um_2_9_1.htm#pic8" title="Вкладка переменные окна параметров блока">переменные</a>&raquo;
окна параметров блока. Следует, однако, учитывать, что на этой вкладке нельзя настроить
формат вывода значений, а для матриц и массивов выводится только размер без значений
конкретных элементов.</p>

<p>Выход и вход (или два их отдельных элемента или поля, как было описано выше)
всегда можно соединить связью, если их типы совпадают. Если типы не совпадают,
соединение все равно возможно в тех случаях, когда тип выхода может быть
преобразован к типу входа. Преобразование типов может как приводить, так и не
приводить к потере данных. Например, выход типа int может без потерь быть соединен
со входом типа double, а обратное соединение (выход double с входом int)
ведет к округлению переданного значения до целого, или, в случае очень больших
значений, к потере самого значения. Некоторые типы не могут соединяться в
принципе &ndash; например, нельзя соединить вещественное число с матрицей или
две структуры с разным составом полей.
<span id="ref23">Ниже</span>
приведены все <span id="light_ref23">допустимые соединения типов</span>
и действия, выполняемые при передаче данных по такому соединению.</p>

<ul>
  <li>Выход типа <span class="term">double</span> может быть соединен со входами следующих типов:
  <ul>
    <li><span class="term">double</span> &ndash; производится копирование значения без потери точности;</li>
    <li><span class="term">float</span> &ndash; производится копирование значения с потерей точности;</li>
    <li><span class="term">int</span>, <span class="term">short</span>,
        <span class="term">char</span> &ndash; производится округление до целого;</li>
    <li><span class="term">сигнал</span> &ndash; независимо от значения выхода в сигнальный вход записывается единица;</li>
    <li><span class="term">строка</span> &ndash; вещественное число преобразуется в строку с возможным округлением;</li>
    <li><span class="term">произвольный тип</span> &ndash; вход получает тип double, значение копируется.</li>
  </ul></li>
  <li>Выход типа <span class="term">float</span> может быть соединен со входами следующих типов:
  <ul>
    <li><span class="term">double</span>, <span class="term">float</span> &ndash;
        производится копирование значения без потери точности;</li>
    <li><span class="term">int</span>, <span class="term">short</span>,
        <span class="term">char</span> &ndash; производится округление до целого;</li>
    <li><span class="term">сигнал</span> &ndash; независимо от значения выхода в сигнальный вход записывается единица;</li>
    <li><span class="term">строка</span> &ndash; вещественное число преобразуется в строку с возможным округлением;</li>
    <li><span class="term">произвольный тип</span> &ndash; вход получает тип float, значение копируется.</li>
  </ul></li>
  <li>Выходы типа <span class="term">int</span>, <span class="term">short</span> и
      <span class="term">char</span> (целые) могут быть соединены со входами следующих типов:
  <ul>
    <li><span class="term">double</span>, <span class="term">float</span> &ndash; целое число преобразуется в вещественное;</li>
    <li><span class="term">int</span>, <span class="term">short</span>,
        <span class="term">char</span> &ndash; значение копируется, возможна потеря данных при передаче числа
    с большой разрядностью в переменную с меньшей: int в short и char, short в char;</li>
    <li><span class="term">сигнал</span> &ndash; независимо от значения выхода в сигнальный вход записывается единица;</li>
    <li><span class="term">строка</span> &ndash; целое число преобразуется в строку в десятичной системе счисления;</li>
    <li><span class="term">произвольный тип</span> &ndash; вход получает тип выхода, значение копируется.</li>
  </ul></li>
  <li><span class="term">Логический</span> выход может быть соединен со входами следующих типов:
  <ul>
    <li><span class="term">логический</span> &ndash; производится копирование значения без потерь;</li>
    <li><span class="term">double</span>, <span class="term">float</span>,
        <span class="term">int</span>, <span class="term">short</span>,
        <span class="term">char</span> &ndash; в переменную записывается 0 или 1;</li>
    <li><span class="term">сигнал</span> &ndash; независимо от значения выхода в сигнальный вход записывается единица,
    даже если передается нулевое значение логического выхода;</li>
    <li><span class="term">строка</span> &ndash; формируется строка из единственного символа 0 или 1;</li>
    <li><span class="term">произвольный тип</span> &ndash; вход получает логический тип, значение копируется.</li>
  </ul></li>
  <li><span class="term">Сигнальный</span> выход может быть соединен со входами следующих типов:
  <ul>
    <li><span class="term">сигнал</span> &ndash; если значение выхода равно 1, входу присваивается 1, а
    значение сигнального выхода автоматически сбрасывается в 0; если же значение
    выхода равно 0, вход не изменяется;</li>
    <li><span class="term">произвольный тип</span> &ndash; если значение выхода равно 1, вход получает
    сигнальный тип и ему присваивается 1, если же значение выхода равно 0,
    вход не изменяет ни тип, ни значение.</li>
  </ul></li>
  <li>Выход-<span class="term">строка</span> может быть соединен со входами следующих типов:
  <ul>
    <li><span class="term">строка</span> &ndash; строка копируется во входную переменную;</li>
    <li><span class="term">double</span>, <span class="term">float</span>
    &ndash; производится преобразование строки в вещественное число,
    если формат строки это позволяет;</li>
    <li><span class="term">int</span>, <span class="term">short</span>,
    <span class="term">char</span> &ndash; производится преобразование строки в целое число,
    если формат строки это позволяет;</li>
    <li><span class="term">сигнал</span> &ndash; независимо от значения выхода в сигнальный вход записывается единица;</li>
    <li><span class="term">произвольный тип</span> &ndash; вход получает тип &laquo;строка&raquo;, сама строка копируется.</li>
  </ul></li>
  <li>Выход-<span class="term">структура</span> может быть соединен со входами следующих типов:
  <ul>
    <li>вход-<span class="term">структура</span> в точности того же типа, что и выход &ndash; копируются
    все значения полей;</li>
    <li><span class="term">сигнал</span> &ndash; независимо от значения выхода в сигнальный вход записывается единица;</li>
    <li><span class="term">произвольный тип</span> &ndash; вход получает тип выхода, все значения полей копируются.</li>
  </ul></li>
  <li>Выход-<span class="term">массив</span> или <span class="term">матрица</span> может быть соединен со входами следующих типов:
  <ul>
    <li>вход-<span class="term">массив</span> или <span class="term">матрица</span> с элементами того же типа &ndash; размерность
    соединенного входа устанавливается равной размерности выхода и копируется
    все содержимое выходного массива;</li>
    <li>вход-<span class="term">массив</span> или <span class="term">матрица</span> с элементами совместимого типа &ndash; размерность
    соединенного входа устанавливается равной размерности выхода и производится
    поэлементное копирование с преобразованием типов элементов согласно указанным
    выше правилам;</li>
    <li><span class="term">сигнал</span> &ndash; независимо от значения выхода в сигнальный вход записывается единица;</li>
    <li><span class="term">произвольный тип</span> &ndash; вход получает тип выхода (массив или матрица) и точную
    копию его значения.</li>
  </ul></li>
  <li>Выход <span class="term">произвольного типа</span> может быть соединен с входом любого типа, передача данных
  при этом производится по указанным выше правилам согласно реальному типу этого
  выхода в момент передачи.</li>
</ul>

<div class="picright"><div class="container" id="pic2">
<img src="../img/SignalConnRus.png" width="167" height="47" alt="К таблице состояния сигналов" />
<p id="light_pic2">Рис.&nbsp;8. К таблице<br />состояния сигналов</p>
</div></div>

<p>Из перечисленных выше правил видно, что к входу произвольного типа можно подключить
любой выход &ndash; передача данных этого выхода автоматически присвоит входу тип выхода.
Можно также заметить, что передача сигналов по связям существенно отличается от
передачи всех остальных переменных. Во-первых, соединение сигнального входа с
выходом любого типа, отличного от сигнального, приводит к тому, что при срабатывании
связи, независимо от значения соединенного входа, в сигнальный вход записывается единица.
Это позволяет использовать сигнальные входы для фиксации самого факта срабатывания
связи. Во-вторых, при соединении связью двух сигнальных переменных по этой связи будет
передаваться только единичное значение, причем оно автоматически сбрасывается после
передачи. Это связано с тем, что сигнал предназначен для отслеживания факта наступления
какого-либо события &ndash; например, срабатывания устройства или нажатия кнопки
пользователем. Сигнал с выхода блока передается по связи на входы других блоков только
в том случае, если его значение равно 1, то есть если событие наступило. При этом
сразу после передачи значение выхода автоматически сбрасывается в 0: информация о
событии передана следующему блоку и дальнейшая передача не потребуется, пока событие
снова не наступит, то есть пока передающий блок снова не присвоит своему выходу
единичное значение). В результате этого на входе блока-приемника будет сохраняться
единичное значение до тех пор, пока его модель, отреагировав на событие, самостоятельно
не сбросит значение своего входа в 0. Это можно проиллюстрировать таблицей состояния
выхода и соединенного с ним входа сигнального типа
(<a href="#pic2" title="К таблице состояния сигналов">рис.&nbsp;8</a>):</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th colspan="2">До передачи данных</th>
    <th colspan="2">После передачи данных</th>
    <th rowspan="2">Действие</th>
  </tr>
  <tr>
    <th>Выход</th>
    <th>Вход</th>
    <th>Выход</th>
    <th>Вход</th>
  </tr>
  <tr>
    <td class="center">0</td>
    <td class="center">0</td>
    <td class="center">0</td>
    <td class="center">0</td>
    <td class="just">Передача не производится, значение входа не изменяется и остается равным 0</td>
  </tr>
  <tr>
    <td class="center">0</td>
    <td class="center">1</td>
    <td class="center">0</td>
    <td class="center">1</td>
    <td class="just">Передача не производится, значение входа не изменяется и остается равным 1</td>
  </tr>
  <tr>
    <td class="center">1</td>
    <td class="center">0</td>
    <td class="center">0</td>
    <td class="center">1</td>
    <td class="just">Данные передаются (вход получает значение 1), значение выхода автоматически сбрасывается в 0</td>
  </tr>
  <tr>
    <td class="center">1</td>
    <td class="center">1</td>
    <td class="center">0</td>
    <td class="center">1</td>
    <td class="just">Данные передаются (значение входа не изменяется, поскольку оно и до этого было равно 1), значение выхода автоматически сбрасывается в 0</td>
  </tr>
</table>
</div></div>

<p>С помощью сигнальных переменных обычно задают логику работы схемы и
последовательность срабатывания блоков (например, таким образом можно моделировать
граф операций).</p>

<p><span id="light_ref24">Первые две переменных</span>
любого простого блока всегда являются сигнальным входом и
сигнальным выходом и играют особую роль в управлении работой блока и подключенных к
нему связей.
<span id="ref26"><span id="ref25">Первая</span></span>
переменная блока (по умолчанию она называется
&laquo;<span class="rdsvar"><span id="light_ref25">Start</span></span>&raquo;,
но может быть, при желании, переименована) играет роль входного
<span id="light_ref26">сигнала управления
запуском</span> модели блока: если для данного блока явно не указано, что он должен
<a href="um_2_9_1.htm#light_ref8" title="Установка режима запуска блока">работать в каждом такте расчета</a>, то в
<a href="um_1_3.htm#ref3" title="Режим расчета">режиме расчета</a>
его модель будет вызвана только в том случае, если на вход управления запуском
будет подана единица. При этом непосредственно перед вызовом модели блока этот
вход управления запуском автоматически сбрасывается в 0, поскольку в противном случае
после первого поступления единицы на него, как и на любой сигнальный вход, она
останется там навсегда &ndash; нули по сигнальным связям не передаются.</p>

<div class="picright"><div class="container" id="pic3">
<img src="../img/StartSignal.png" width="277" height="248" alt="Пример использования сигнала управления запуском" />
<p id="light_pic3">Рис.&nbsp;9. Пример использования<br />сигнала управления запуском</p>
</div></div>

<p>Многие стандартные блоки в RDS поддерживают управление своей работой при
помощи сигнала управления запуском. Как правило, для этого в настройках блока
необходимо разрешить использование этого сигнала: если оно запрещено, модель
будет сама управлять своей работой, запускаясь каждый такт или при изменении
одного из входов. Если же оно разрешено, модель будет ждать сигнала запуска. На
<a href="#pic3" title="Пример использования сигнала управления запуском">рис.&nbsp;9</a>
изображено окно настройки стандартного блока умножения на константу, в котором
включено ожидание сигнала запуска, и схема подключения этого блока, при которой
он будет срабатывать при каждом нажатии кнопки &laquo;умножить&raquo;.</p>

<p><span id="ref28"><span id="ref27">Вторая</span></span>
переменная блока (по умолчанию &ndash; &laquo;<span class="rdsvar"><span id="light_ref27">Ready</span>&raquo;, но может быть
переименована) служит выходным <span id="light_ref28">сигналом готовности блока</span>: в режиме расчета данные
с выходов этого блока передаются только в том случае, если она равна единице.
Этой переменной автоматически присваивается единица перед запуском модели, и ноль
после срабатывания связей. Модель блока обычно обнуляет сигнал готовности если по
каким-либо причинам не готова выдать на выходы новые данные &ndash; таким образом,
выходной сигнал готовности будет равен единице, если модель блока сработала и
вычислила значения выходов, и нулю, если модель не запускалась или не
подготовила данные.</p>

<p>Сигнал готовности вместе с сигналом управления запуском можно использовать в
сложных схемах для задержки срабатывания каких-либо блоков до тех пор, пока
блоки, включенные перед ними, не подготовят для них данные. На
<a href="#pic4" title="Две ветви алгебраических блоков">рис.&nbsp;10</a>
изображена схема, в которой значение с поля ввода (слева) подается на
две параллельные ветви: в одной блок &laquo;<span class="rdsvar">Sum1</span>&raquo; прибавляет к этому значению
число 6, в другой &ndash; блоки &laquo;<span class="rdsvar">Sum2</span>&raquo;, &laquo;<span class="rdsvar">Sum3</span>&raquo; и
&laquo;<span class="rdsvar">Sum4</span>&raquo; три раза последовательно прибавляют к нему число 2, после чего
выходы обоих ветвей вычитаются блоком &laquo;<span class="rdsvar">Diff1</span>&raquo; и результат подается на
числовой индикатор (справа). Все блоки в этой схеме &ndash; стандартные, их модели
запускаются при срабатывании любой из подключенных к входам связей.</p>

<div class="pic"><div class="container" id="pic4">
<img src="../img/SignalChain1.png" width="461" height="205" alt="Две ветви алгебраических блоков" />
<p id="light_pic4">Рис.&nbsp;10. Две ветви алгебраических блоков</p>
</div></div>


<p>Теоретически, в этой схеме числовой индикатор должен всегда показывать нулевое
значение, поскольку и верхняя, и нижняя ветви схемы прибавляют к значению поля
ввода число шесть. Однако, если рассмотреть работу этой схемы по тактам, можно
заметить, что нулевое значение на выходе блока вычитания &laquo;<span class="rdsvar">Diff1</span>&raquo;
устанавливается не сразу: расчет верхней ветви занимает один такт, расчет
нижней &ndash; три такта (там три последовательно соединенных блока),
поэтому при изменении значения во входном поле ввода новое значение на входе
&laquo;<span class="rdsvar">x1</span>&raquo; блока вычитания установится быстрее, чем на входе
&laquo;<span class="rdsvar">x2</span>&raquo;, и в течение пары тактов на индикатор будет подаваться
неверное значение. В большинстве случаев об этом можно не задумываться, поскольку
при моделировании процессов, протекающих во времени, небольшие рассогласования
в одновременности срабатывания блоков будут считаться происходящими
в пределах одного дискретного шага расчета (в один и
тот же момент времени), и, к тому моменту, как системное время изменится, на
выходах всех цепочек блоков уже появятся правильные значения. Однако, при
моделировании логических схем неодновременность срабатывания цепочек блоков
разной длины может создавать проблемы, поэтому для борьбы с ней можно
использовать управление запуском блоков по готовности данных.</p>

<p>На <a href="#pic5" title="Две ветви алгебраических блоков с сигналом управления">рис.&nbsp;11</a> изображена такая же схема,
в которой у блока вычитания &laquo;<span class="rdsvar">Diff1</span>&raquo; включен режим работы по
сигналу (окно настройки этого блока аналогично изображенному на
<a href="#pic3" title="Пример использования сигнала управления запуском">рис.&nbsp;9</a>), и на его вход управления
запуском &laquo;<span class="rdsvar">Start</span>&raquo; подан сигнал готовности
&laquo;<span class="rdsvar">Ready</span>&raquo; последнего блока самой длинной ветви
&laquo;<span class="rdsvar">Sum4</span>&raquo;. Теперь &laquo;<span class="rdsvar">Diff1</span>&raquo; будет выполнять вычитание
только тогда, когда сработает &laquo;<span class="rdsvar">Sum4</span>&raquo;, то есть когда значение
в самой длинной цепочке будет полностью вычислено. При этом на числовой индикатор
всегда будет подаваться нулевое значение.</p>

<div class="pic"><div class="container" id="pic5">
<img src="../img/SignalChain2.png" width="461" height="205" alt="Две ветви алгебраических блоков с сигналом управления" />
<p id="light_pic5">Рис.&nbsp;11. Две ветви алгебраических блоков с сигналом управления</p>
</div></div>


<p>Более подробно принципы работы со статическими переменными блоков,
включая особенности использования сигналов, рассмотрены в
<a href="um_index.htm#light_htm:um_3_7_2" title="&sect;3.7.2. Работа со статическими переменными блока">&sect;3.7.2 описания пользователя</a> и в
<a href="pm_index.htm#light_htm:pm_2_5" title="&sect;2.5. Статические переменные блоков">&sect;2.5 руководства программиста</a>. Эта информация нужна, в
основном, разработчикам моделей блоков (в том числе, и автоматически компилируемых),
обычному пользователю для работы с RDS достаточно уметь соединять
переменные блоков связями и знать, какие типы можно соединять между собой.
Назначение каждой переменной конкретного блока и особенности их использования
рассматриваются в описаниях конкретных библиотечных блоков.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_1_3.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_1_5.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_1_4">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
