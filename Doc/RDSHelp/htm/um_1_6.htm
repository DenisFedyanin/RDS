<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;1.6. Коротко о других способах взаимодействия блоков</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_1">Глава 1. Необходимые сведения об устройстве RDS</a></p>
<div class="level"><p>&sect;1.6. Коротко о других способах взаимодействия блоков</p>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_1_5.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_1_7.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_1_6">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 1. Необходимые сведения об устройстве RDS</h2>
<h3>&sect;1.6. Коротко о других способах взаимодействия блоков</h3>
<p class="abstract">Описываются скрытые от пользователя механизмы, позволяющий блокам обращаться друг к другу минуя связи и динамические переменные, а также обмениваться данными с другими приложениями Windows. Подробно они рассматриваются в <a href="pm_index.htm" title="Руководство программиста">руководстве программиста</a>, а здесь дается их краткий обзор.</p>


<p>Помимо передачи данных по
<a href="um_1_4.htm" title="&sect;1.4. Статические переменные блоков">связям</a>
и через
<a href="um_1_5.htm" title="&sect;1.5. Динамические переменные">динамические переменные</a>, у блоков есть и другие
возможности общаться друг с другом. В то время, как связи создаются пользователем и
явно видны ему, динамические переменные и другие способы взаимодействия, как правило,
скрыты от пользователя, если только разработчик блока не включит управление ими в
пользовательский интерфейс блока. Например, окно настройки блоков работы с
динамическими переменными, изображенных на
<a href="um_1_5.htm#pic2" title="Стандартные блоки для работы с динамическими переменными">рис.&nbsp;13</a>, позволяют задавать имя переменной
и ее тип. Несмотря на то, что пользователь непосредственно не работает с большинством
из альтернативных способов передачи данных между блоками, ему необходимо знать, что
взаимодействие блоков в схеме может не ограничиваться связями, которые он видит, и
в общих чертах представлять себе возможности этих блоков.</p>

<p><span id="ref2"><span id="ref1">Самый распространенный</span></span>,
помимо использования связей и динамических переменных, способ передачи
данных от одного блока к другому &ndash; это непосредственный вызов модели одного
блока из модели другого. В RDS он называется
<span class="term" id="light_ref1">вызовом функции блока</span>,
его механизм подробно рассматривается в
<a href="um_index.htm#light_htm:um_3_7_12" title="&sect;3.7.13. Вызов функций блоков">&sect;3.7.13 описания пользователя</a>
и <a href="pm_index.htm#light_htm:pm_2_13" title="&sect;2.13. Вызов функций блоков">&sect;2.13 руководства программиста</a>.
Коротко его можно описать
следующим образом: программист, создавший блок, который может выполнить какую-либо
потенциально полезную для других блоков функцию, дает этой функции уникальное
текстовое имя и вставляет в модель своего блока специальный вызов, заявляющий
RDS о существовании и имени этой функции (в терминах RDS &ndash;
<span class="term" id="light_ref2">регистрирующий</span>
эту функцию). После этого другие программисты,
зная имя функции, могут вставлять в модели своих блоков запросы на ее выполнение
как у какого-либо конкретного блока, так и у всех блоков, которые могут ее выполнять
в данной подсистеме или во всей схеме. При желании, пользователь может увидеть все
имена функций, зарегистрированных блоками загруженной в данный момент схемы,
на вкладке &laquo;<a href="um_2_17.htm#pic5" title="Информация о схеме: вкладка функции блоков">функции блоков</a>&raquo;
окна информации о системе,
но он не может повлиять на вызов и выполнение этих функций &ndash; их имена и
выполняемые ими действия жестко закладываются в программы блоков их создателями.</p>

<p>
<span id="ref3">В качестве примера</span> функции,
поддерживаемой многими стандартными блоками, можно привести функцию с именем
&laquo;<span class="rdsvar"><span id="light_ref3">Common.ControlValueChanged</span></span>&raquo;.
Обычно ее поддержка реализуется разработчиками различных блоков пользовательского
интерфейса &ndash; кнопок, полей ввода, рукояток и т.п. Вызов этой функции
заставляет блок немедленно считать данные со своих входов, если они у него есть,
изменить свое внутреннее состояние согласно полученным значениям (например,
переместить рукоятку в новое положение), выдать эти же значения на выходы и
вызвать у всех присоединенных блоков эту же функцию. Именно за счет этой функции
блоки пользовательского интерфейса можно соединять в цепочки и кольца,
работающие не только в режиме расчета, но и в режиме моделирования
(см. <a href="um_1_3.htm#pic1" title="Соединение рукоятки и поля ввода">рис.&nbsp;5</a>).
В <a href="um_1_3.htm#ref2" title="Режим моделирования">режиме моделирования</a>
передача данных по связям и автоматический запуск моделей
блоков не производится, но, за счет принудительной активации выходных связей и
вызова функции &laquo;<span class="rdsvar">Common.ControlValueChanged</span>&raquo; у всех соединенных
блоков, введенное пользователем значение распространяется по цепочке.</p>

<div class="picright"><div class="container" id="pic1">
<img src="../img/MathErrorExample.png" width="300" height="200" alt="Сообщение, выводимое блоком обработки ошибок (слева) при делении на ноль" />
<p id="light_pic1">Рис.&nbsp;14. Сообщение, выводимое<br />блоком обработки ошибок (слева)<br />при делении на ноль</p>
</div></div>


<p><span id="ref4">Другим</span> примером широко
используемой функции может служить
&laquo;<span class="rdsvar"><span id="light_ref4">Common.MathError</span></span>&raquo; &ndash;
эту функцию выполняют блоки, предназначенные для обработки ошибок математических
вычислений. Такой блок помещается в схему
(<a href="#pic1" title="Сообщение, выводимое блоком обработки ошибок (слева) при делении на ноль">рис.&nbsp;14</a>, квадратный блок с красной буквой
&laquo;Е&raquo; в левой части рисунка), после чего при возникновении
математической ошибки где-либо в той же подсистеме или в одной из вложенных,
блок, обнаруживший ошибку, находит блок-обработчик и вызывает его функцию,
передавая ему свое имя и описание ошибки. Обработчик, в свою очередь, выполняет
предусмотренные программистом действия &ndash; например, останавливает расчет и
выводит пользователю сообщение, как на
<a href="#pic1" title="Сообщение, выводимое блоком обработки ошибок (слева) при делении на ноль">рис.&nbsp;14</a>. Без использования вызова функции блока
пришлось бы либо предусматривать во всех блоках специальный выход ошибки и соединять
его с блоком-обработчиком связями, что загромоздило бы схему, либо встраивать
реакцию на математические ошибки в каждый блок, что сделало бы эту реакцию
жесткой. Сейчас, заменив блок-обработчик на другой, можно изменить реакцию на
ошибки во всей обслуживаемой им части схемы. Механизм, с помощью которого блоки
находят обслуживающий их обработчик, подробно описан в
<a href="um_3_7_12_4.htm" title="&sect;3.7.13.4. Регистрация и поиск исполнителя функции">&sect;3.7.13.4 описания пользователя</a> и
<a href="pm_2_13_6.htm" title="&sect;2.13.6. Регистрация исполнителя функции">&sect;2.13.6 руководства программиста</a></p>

<p><span id="ref5">Поскольку</span> <span id="light_ref5">модель</span>
любого блока в RDS
является функцией в динамически подключаемой библиотеке (DLL), которая обычно
пишется на каком-либо языке высокого уровня, возможности блоков по взаимодействию
с различными объектами за пределами RDS ограничены только знаниями
программиста-разработчика: ему доступны все функции Windows API. Например,
не так уж сложно создать блоки, которые будут передавать и принимать данные по
сети, взаимодействовать с другими приложениями и т.п. Для облегчения жизни
программисту в RDS встроены механизмы, стандартизующие некоторые действия по
обмену с внешним миром &ndash; в частности, обмен данными между блоками
по сети и работу схемы под управлением другого приложения Windows.</p>

<p><span id="ref6">Встроенный</span> в RDS механизм
<span id="light_ref6">обмена данными по сети</span> подробно описан в
<a href="pm_index.htm#light_htm:pm_2_15" title="&sect;2.15. Обмен данными по сети">&sect;2.15 руководства программиста</a>. Пользователь имеет с ним дело,
в основном, через стандартные сетевые блоки, использующие этот механизм. Эти блоки
позволяют, назначив одну из машин в сети сервером RDS, передавать в этой сети
данные между схемами, загруженными на разных машинах, просто подавая эти данные на
входы блоков и снимая их с выходов (<a href="#pic2" title="Передача по сети вещественного числа при помощи стандартных блоков">рис.&nbsp;15</a>).</p>

<div class="pic"><div class="container" id="pic2">
<img src="../img/ExampleNet.png" width="466" height="169" alt="Передача по сети вещественного числа при помощи стандартных блоков" />
<p id="light_pic2">Рис.&nbsp;15. Передача по сети вещественного числа при помощи стандартных блоков</p>
</div></div>


<p><span id="ref7">Поскольку</span>
передаваемых данных может быть много и они могут иметь разные типы,
передача осуществляется через <span class="term" id="light_ref7">каналы</span>
сервера RDS, каждому из которых дается произвольное имя. Число каналов
не ограничено.
С точки зрения пользователя, он просто подключает связь к входу одного из сетевых
блоков на одной из машин и указывает в его настройках имя канала. Затем на других
машинах он добавляет в схему сетевой блок, вводит его настройках это же самое имя
канала, и снимает значение с выхода блока. Передача данных между машинами не
однонаправленная &ndash; одна и та же схема может служить и передатчиком, и
приемником данных. Кроме ввода имени канала в настройках блока, пользователь не
может повлиять на передачу данных по сети. Однако, при желании, в
<a href="um_2_18.htm" title="&sect;2.18. Настройки RDS">настройках</a>
RDS он может вообще запретить сетевую активность схем на какой-либо машине
или ограничить список сетевых адресов, с которыми разрешено взаимодействие.
Пользователь может также просмотреть список других машин, подключившихся к
данной машине, и список каналов сервера в
<a href="um_2_20.htm" title="&sect;2.20. Окно сетевых соединений">окне сетевых соединений</a>.</p>

<p><span id="ref8">Для</span>
управления схемами из других приложений в состав RDS входит специальная
библиотека
&laquo;<span class="file"><span id="light_ref8">RdsCtrl.dll</span></span>&raquo;, позволяющая
внешнему приложению как передавать
команды RDS и отдельным блокам схемы, так и реагировать на события,
происходящие в схеме (например, на окончание расчета или на действия пользователя).
Разумеется, все взаимодействие при этом реализуется программистами приложения и
моделей блоков, пользователь не может на него повлиять. Подробно механизм обмена
данными между RDS и внешними приложениями рассматривается в
<a href="pm_index.htm#light_htm:pm_3" title="Глава 3. Управление RDS из других приложений">главе 3 руководства программиста</a>.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_1_5.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_1_7.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_1_6">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
