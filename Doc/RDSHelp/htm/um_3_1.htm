<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.1. Принцип действия стандартного модуля автокомпиляции</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p>&sect;3.1. Принцип действия стандартного модуля автокомпиляции</p>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_2_21_2.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_2_1.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_1">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2>Глава 3. Использование стандартных модулей автокомпиляции</h2>
<p class="abstract">В этой главе описывается создание пользовательских моделей блоков при помощи входящих в состав RDS модулей автоматической компиляции. Пользователь записывает основные действия, выполняемые блоком, в виде программ на языке C++, а модуль, при помощи внешнего компилятора, собирает из этих программ полноценную модель блока.</p>
<h3>&sect;3.1. Принцип действия стандартного модуля автокомпиляции</h3>
<p class="abstract">Рассматриваются общие принципы работы входящих в состав RDS модулей автоматической компиляции, приводится список поддерживаемых компиляторов.</p>


<p>В RDS модули автоматической компиляции призваны облегчать написание моделей блоков &ndash;
эти модули работают посредниками между пользователем и одним из установленных в системе
компиляторов какого-либо языка высокого уровня. Обычно пользователь пишет только самые необходимые
фрагменты программы модели, а затем модуль автокомпиляции формирует из них полный текст программы и
передает его компилятору, создающему исполняемый файл динамической библиотеки (DLL). После этого функция
модели из этой библиотеки автоматически подключается к одному или нескольким блокам схемы.
Такая схема работы позволяет пользователю сосредоточиться на алгоритме работы блока, не вдаваясь
в тонкости правильного оформления исходного текста программы и описаний, необходимых для создания
динамических библиотек Windows. Стандартные модули автокомпиляции RDS поддерживают только язык C++,
и, при их использовании, все фрагменты программ пользователь должен писать на этом языке. Для
написания простейших моделей достаточно знать, как записываются математические выражения и операторы
присваивания. Если же пользователь захочет расширить возможности своих моделей, ему будет полезно
изучить сам язык C++ и его стандартные библиотеки.</p>

<p>Модули автокомпиляции не являются неотъемлемой частью RDS &ndash; они не встроены в главную
программу &laquo;<span class="file">rds.exe</span>&raquo;, а, как и модели блоков, находятся во внешних динамически
подключаемых библиотеках. В состав RDS по умолчанию входит несколько модулей, рассчитанных на
работу с компиляторами языка C++: часть модулей настроена на работу с конкретными компиляторами разных
производителей, часть &ndash; универсальные, предназначенные для подключения произвольного компилятора.
Все эти модули имеют один и тот же интерфейс пользователя, позволяющий достаточно гибко настраивать
взаимодействие с компилятором. Фактически, модули для конкретных компиляторов отличаются от универсальных
модулей только набором параметров по умолчанию. Сейчас будут рассмотрены только самые общие
принципы работы этих стандартных модулей, более подробно их настройка рассматривается в
<a href="um_index.htm#light_htm:um_3_9" title="&sect;3.9. Настройки стандартного модуля автокомпиляции">&sect;3.9</a>. Модули для других языков программирования в состав
RDS не входят, при необходимости, они могут быть созданы сторонними разработчиками (правила
написания таких модулей подробно рассмотрены в
<a href="pm_index.htm#light_htm:pm_4" title="Глава 4. Создание модулей автоматической компиляции">главе 4 руководства программиста</a>).</p>

<p><span id="ref1">Все</span>
<span id="light_ref2">стандартные модули автокомпиляции</span>
находятся в библиотеке
<span id="light_ref1">&laquo;<span class="file">Common.dll</span>&raquo;</span> в
<a href="um_2_18.htm#light_ref11" title="Папка стандартных DLL">папке DLL</a>
RDS. <span id="ref3">Для</span>
подключения какого-либо из них к RDS в стандартном окне
<a href="um_2_19_1.htm" title="&sect;2.19.1. Подключение модулей автоматической компиляции моделей блоков">подключения модулей автокомпиляции</a> необходимо указать имя
этой библиотеки с префиксом
&laquo;<span id="light_ref3">$DLL$</span>\\&raquo; и имя функции, обслуживающей
конкретный модуль, из следующей таблицы:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя функции модуля</th>
    <th>Компилятор, для которого предназначен модуль</th>
  </tr>
  <tr>
    <td><span id="light_ref4">BCpp55</span></td>
    <td><span id="light_ref5">Borland C++ 5.5</span>
    (бесплатный,
    <a href="http://www.embarcadero.com/products/cbuilder/free-compiler" target="_blank">http://www.embarcadero.com/products/cbuilder/free-compiler</a>) или <span id="light_ref6">Borland C++ Builder 6</span> (коммерческий)</td>
  </tr>
  <tr>
    <td><span id="light_ref7">OpenWatcomCpp</span></td>
    <td><span id="light_ref8">Open Watcom C++</span> (бесплатный,
    <a href="http://www.openwatcom.org" target="_blank">http://www.openwatcom.org</a>)</td>
  </tr>
  <tr>
    <td><span id="light_ref9">DigitalMars</span></td>
    <td><span id="light_ref10">Digital Mars C++</span> (бесплатный,
    <a href="http://www.digitalmars.com" target="_blank">http://www.digitalmars.com</a>)</td>
  </tr>
  <tr>
    <td><span id="light_ref11">Gcc_MinGW</span></td>
    <td><span id="light_ref12">MinGW GCC</span> (бесплатный,
    <a href="http://www.mingw.org" target="_blank">http://www.mingw.org</a>)</td>
  </tr>
  <tr>
    <td><span id="light_ref13">MSVCTK2003</span></td>
    <td><span id="light_ref14">Microsoft Visual C++ 2003 toolkit</span>
    (бесплатный)</td>
  </tr>
  <tr>
    <td><span id="light_ref15">MSVCpp6</span></td>
    <td><span id="light_ref16">Microsoft Visual C++ 6</span> (коммерческий)</td>
  </tr>
  <tr>
    <td><span id="light_ref17">UserComp1</span>, <span id="light_ref18">UserComp2</span>,
    <span id="light_ref19">UserComp3</span></td>
    <td>Универсальные модули, которые пользователь должен настроить самостоятельно</td>
  </tr>
</table>
</div></div>

<p>Принимая решение об установке и подключении к RDS того или иного компилятора, следует, по
возможности, выбирать тот, для которого имя функции модуля приведено в таблице на первых строчках.
Проще всего установить и подключить к RDS компиляторы Borland и Watcom, сложнее всего &ndash; MinGW
и Microsoft Visual C++ 2003 (последний в настоящее время недоступен для загрузки на официальном сайте
Microsoft). Модули с именами &laquo;UserComp1&raquo;, &laquo;UserComp2&raquo; и
&laquo;UserComp3&raquo; не рассчитаны на какой-либо стандартный компилятор, это универсальные модули,
в настройках которых необходимо указать пути ко всем исполняемым файлам компилятора, папкам библиотек и
заголовков, параметры командной строки и т.п. Это требует определенного опыта в работе с компиляторами,
управляемыми через командную строку, поэтому, при наличии у пользователя какого-либо из перечисленных
выше стандартных компиляторов, рекомендуется использовать специально предназначенный для него модуль.
Подключение компиляторов к стандартным модулям рассмотрено в
<a href="um_index.htm#light_htm:um_3_2" title="&sect;3.2. Установка стандартных модулей автокомпиляции и компиляторов">&sect;3.2</a>, настройка универсальных &ndash; в
<a href="um_index.htm#light_htm:um_3_9" title="&sect;3.9. Настройки стандартного модуля автокомпиляции">&sect;3.9</a>.</p>

<p><span id="ref20">Кроме</span>
перечисленных выше, в библиотеке &laquo;<span class="file">Common.dll</span>&raquo; находится еще один дополнительный модуль
автокомпиляции с именем функции
<span id="light_ref20">&laquo;SearchComp&raquo;</span>. Этот модуль не рассчитан на какой-либо
конкретный компилятор и не может сам компилировать модели. Вместо этого он пытается найти среди модулей
из приведенной выше таблицы тот, который пользователь уже настроил, и обращается к нему. Это возможно,
поскольку все стандартные модули автокомпиляции совместимы: у них одинаковый формат моделей и одинаковый
способ формирования текста программ. Основное назначение этого дополнительного модуля &ndash; передача
другому пользователю схемы с автокомпилируемыми блоками. Если, например, передать схему, в которой для
компиляции используется модуль для Borland, другому пользователю, у которого настроен только модуль для
Watcom, этому другому пользователю придется заменять используемый модуль во всех блоках схемы. Если
же заранее переключить все блоки на использование модуля &laquo;SearchComp&raquo;, у каждого
пользователя будет использоваться тот модуль, который он успешно настроил и использует сам.
Обращения к модулю &laquo;SearchComp&raquo; несколько задерживает загрузку схемы, поэтому,
если все пользователи работают с одним и тем же компилятором, лучше не использовать этот модуль.</p>

<p><span id="ref21">Независимо</span> от используемого компилятора,
все модули работают по одному принципу. В
<a href="um_1_3.htm#ref1" title="Режим редактирования">режиме редактирования</a>
пользователь может связать с каким-либо блоком схемы автоматически компилируемую модель,
описание которой хранится на диске в отдельном файле, как правило, с расширением
<span id="light_ref21">&laquo;<span class="file">.mdl</span>&raquo;</span>. Модуль автокомпиляции позволяет пользователю
вводить и изменять эту модель в специальном окне редактора
(<a href="#pic1" title="Типичный внешний вид окна редактора модели">рис.&nbsp;301</a>),
открывающемся при двойном щелчке на блоке или из контекстного меню этого блока. Одна и та же модель
может быть связана с несколькими блоками схемы или даже с разными блоками в разных схемах, при этом ее
изменение одновременно отражается на работе всех использующих ее блоков во всех схемах. В окне
редактора пользователь не только вводит фрагменты программы, которые будут выполняться для данного блока
при наступлении различных системных событий, но и задает список
<a href="um_1_2.htm#ref4">статических</a>
и <a href="um_1_2.htm#ref6">динамических</a>
переменных блока, набор его настроечных параметров, внешний вид
<a href="um_2_6.htm#ref3" title="Настройка блока">окна настройки</a> и т.п.</p>

<div class="pic"><div class="container" id="pic1">
<img src="../img/AutocompExample2.png" width="593" height="461" alt="Типичный внешний вид окна редактора модели" />
<p id="light_pic1">Рис.&nbsp;301. Типичный внешний вид окна редактора модели</p>
</div></div>


<p>При переходе RDS из режима редактирования
в <a href="um_1_3.htm#ref2" title="Режим моделирования">режим моделирования</a>
или <a href="um_1_3.htm#ref3" title="Режим расчета">расчета</a>
модуль автокомпиляции проверяет наличие изменений в модели. Если изменения есть, то из
введенных пользователем фрагментов программы модуль составляет полный исходный текст для
динамически подключаемой библиотеки с моделью блока, записывает этот текст в файл на диске
и запускает компилятор, указанный в настройках модуля. В RDS в одной динамической библиотеке
может содержаться несколько моделей блоков, но, для упрощения взаимодействия, все
стандартные модули автокомпиляции формируют библиотеки по принципу
&laquo;одна модель &ndash; одна библиотека&raquo;. Таким образом, если в схеме, например,
используется три разных автокомпилируемых модели (не важно, к скольким блокам они подключены),
модуль сформирует три отдельных исходных текста на языке C++ и три раза запустит компилятор для
формирования из них исполняемых файлов DLL. Если компиляция прошла без ошибок, полученные модели,
то есть функции, экспортированные из созданных библиотек, будут подключены к блокам и начнут работу.
Если же компилятор не смог создать исполняемые файлы из-за ошибок во введенных пользователем фрагментах,
модуль автокомпиляции разберет список ошибок, полученный от компилятора, и предъявит его пользователю.
Таков общий принцип работы модуля автокомпиляции. Разумеется, в описанном процессе есть множество
особенностей, которые могут быть настроены пользователем. Например, можно указать, какие
дополнительные описания помещаются в автоматически формируемый текст программы, как модель должна
перехватывать возникающие в программе исключения и т.п. &ndash; все это рассматривается в
<a href="um_index.htm#light_htm:um_3_9" title="&sect;3.9. Настройки стандартного модуля автокомпиляции">&sect;3.9</a>.</p>

<p><span id="ref22">Выше</span>
уже было упомянуто, что <span id="light_ref22">файлы моделей хранятся на диске</span>
не внутри файла самой схемы, а в
отдельных файлах, ссылки на которые находятся в файле схемы вместе с другими параметрами блоков,
что позволяет использовать одни и те же модели в разных схемах. Однако, это приводит к тому, что
для переноса схемы с такими моделями на другую машину или в другую папку на этой же машине
часто недостаточно скопировать только файл схемы
(&laquo;<span class="file">.rds</span>&raquo;) &ndash; кроме него требуются еще и файлы используемых в схеме моделей
(&laquo;<span class="file">.mdl</span>&raquo;).
<span id="ref23">Чтобы</span>
упростить перенос схем, файлы моделей обычно сохраняют либо в
ту же папку, в которой находится использующая их схема или несколько схем, либо в
<span id="light_ref23">папку стандартных моделей</span>,
которая указывается в
<a href="um_2_18.htm" title="&sect;2.18. Настройки RDS">настройках RDS</a>.
Если сохранить файл модели в ту же папку, что и схему, его имя будет запомнено в параметрах блока
без пути. При этом всю папку со схемой целиком можно будет перемещать, в том числе и с машины на
машину, без потери работоспособности &ndash; модуль автокомпиляции при отсутствии полного пути к
файлу модели всегда ищет его в папке со схемой. Это удобно для специализированных моделей,
используемых только в одной схеме или группе схем (такие схемы при этом лучше всего разместить в
одной папке).
<span id="ref24">Если</span>
же создаваемая модель будет достаточно универсальной, чтобы ее имело смысл
использовать в разных схемах, не связанных между собой, ее лучше записать в стандартную папку моделей.
В этом случае в имени файла модели, которое будет запомнено в схеме, вместо конкретного пути будет
подставлено <span id="light_ref24">символическое обозначение
&laquo;$MODELS$&raquo;</span>. При загрузке этой схемы модуль автокомпиляции будет искать указанный
файл модели в стандартной папке, где бы она ни находилась, и схему тоже можно будет перемещать
без потери ее работоспособности. Разумеется, при перемещении схемы на другую машину следует
скопировать файл модели в папку стандартных моделей на этой машине.</p>

<p>Технически модуль автокомпиляции позволяет сохранить файл модели в любую папку,
в том числе и не относящуюся к RDS или к конкретной схеме, в которую входит блок с этой моделью.
Однако, это не рекомендуется из-за возможных проблем при переносе схемы: если пользователь решит
передать кому-либо созданную им схему и все ее модели, эти модели на другой машине придется размещать в
папках с точно такими же именами. Например, если на машине пользователя модель находилась в папке
&laquo;<span class="file">e:\documents\user\models</span>&raquo;, и этот полный путь был запомнен в какой-либо схеме,
загрузка такой схемы на другой машине будет требовать наличия файла модели именно в этой папке, что
может создать проблемы, особенно, если на этой машине нет диска &laquo;<span class="file">e:</span>&raquo;. Следует также
учитывать, что, если сохранять файл модели в одну из
<a href="um_2_18.htm#ref8" title="Стандартные папки RDS">стандартных папок RDS</a>, модуль автокомпиляции всегда будет
заменять путь к ней на
<a href="rdsGetFullFilePath.htm#ref1" title="Символические обозначения стандартных путей">соответствующее символическое обозначение</a>
&ndash; это касается не только
стандартной папки моделей, вместо пути к которой подставляется
&laquo;$MODELS$&raquo;, но и папки DLL (&laquo;$DLL$&raquo;), папки настроек
(&laquo;$INI$&raquo;) и т.п.</p>

<p><span id="ref25">Создаваемый</span>
при помощи стандартного модуля автокомпиляции файл динамической библиотеки с
моделью блока всегда располагается в одной папке с файлом этой модели и получает то же имя, что и
этот файл, только с
<span id="light_ref25">расширением &laquo;<span class="file">.dll</span>&raquo;</span>. Если, например, файл модели с
именем &laquo;<span class="file">whatever.mdl</span>&raquo; находится в папке стандартных моделей RDS, то
исполняемый файл DLL, созданный на его основе, тоже будет находится в папке стандартных моделей и
получит имя &laquo;<span class="file">whatever.dll</span>&raquo;. Если файл модели находится в одной папке со схемой,
скомпилированный файл тоже будет находиться в папке со схемой, и т.п. По времени изменения
скомпилированного файла модуль проверяет необходимость компиляции модели: если файл модели имеет
более позднее время изменения, чем соответствующий ему файл DLL, значит, после последней компиляции в
модель были внесены изменения, и компиляцию следует выполнить заново. Если системные часы по какой-либо
причине работают неверно (например, их время сбросилось из-за разряда батарейки), эта проверка может
не сработать, и, несмотря на наличие в модели изменений, модуль не будет ее компилировать.
<span id="ref26">В</span>
этом
случае можно выбрать в
<a href="um_2_1.htm" title="&sect;2.1. Главное окно и главное меню">главном меню</a> RDS пункт
&laquo;<span class="menu">система | перекомпилировать все модели</span>&raquo;, который заставит все активные в данный момент
модули автокомпиляции <span id="light_ref26">принудительно скомпилировать все модели</span>,
используемые в загруженной схеме.
Можно также
<a href="um_3_6_1.htm#light_ref5" title="Принудительная компиляция редактируемой модели">принудительно скомпилировать конкретную модель</a>, открыв ее редактор.
Для удобства работы рекомендуется восстановить работу системных часов &ndash; в противном случае после
каждого изменения моделей придется вручную принудительно их компилировать.</p>

<p>Следует учитывать, что описанные принципы работы модулей (хранение моделей в отдельных файлах,
редактирование их текстов в отдельных окнах и т.п.) относятся только к стандартным модулям
автокомпиляции, входящим в состав RDS. Модули, созданные сторонними разработчиками, могут
работать по-другому.</p>

<p>В <a href="um_index.htm#light_htm:um_3_2" title="&sect;3.2. Установка стандартных модулей автокомпиляции и компиляторов">&sect;3.2</a>
рассмотрены процедуры установки и подключения конкретных компиляторов и настройка предназначенных
для них модулей.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_2_21_2.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_2_1.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_1">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
