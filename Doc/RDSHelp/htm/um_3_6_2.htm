<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.6.2. Статические переменные блока</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_6">&sect;3.6. Окно редактора модели</a></p>
<div class="level"><p>&sect;3.6.2. Статические переменные блока</p>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_6_1.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_6_3.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_6_2">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.6. Окно редактора модели</h3>
<h4>&sect;3.6.2. Статические переменные блока</h4>
<p class="abstract">Описывается добавление в модель блока статических переменных, которые могут служить входами и выходами этого блока. Именно через статические переменные блоки получают данные по связям.</p>


<p><a href="um_1_2.htm#ref4">Статические</a>
и <a href="um_1_2.htm#ref6">динамические</a>
переменные блока задаются на вкладке &laquo;<span class="menu">переменные</span>&raquo; дополнительной (левой) панели
<a href="um_3_6_1.htm" title="&sect;3.6.1. Элементы и меню окна редактора модели">окна редактора модели</a>. Если эта панель отключена, ее можно снова
включить пунктом меню &laquo;<span class="menu">вид | переменные и события</span>&raquo;.</p>

<div class="picright"><div class="container" id="pic1">
<img src="../img/AC_editor_vars.png" width="290" height="361" alt="Вкладка переменные дополнительной панели" />
<p id="light_pic1">Рис.&nbsp;333. Вкладка &laquo;<span class="menu">переменные</span>&raquo;<br />дополнительной панели</p>
</div></div>


<p>Вкладка (<a href="#pic1" title="Вкладка переменные дополнительной панели">рис.&nbsp;333</a>)
разделена по вертикали на две части: в верхней вводятся статические переменные, в нижней &ndash; динамические
(границу раздела можно перетаскивать вверх и вниз левой кнопкой мыши).
Задание динамических переменных описываются в
<a href="um_3_6_3.htm" title="&sect;3.6.3. Динамические переменные блока">&sect;3.6.3</a>.</p>

<p>Статические переменные используются как входы и выходы блока, а также для хранения промежуточных значений.
Статическими эти переменные называются потому, что они создаются перед подключением модели к блоку и, хотя
их значения и изменяются в процессе работы, их структура остается постоянной. Технически RDS позволяет
моделям блоков изменять структуру и типы своих статических переменных в процессе работы при помощи
<a href="pm_2_16_1.htm" title="&sect;2.16.1. Изменение структуры переменных блока">специальных вызовов</a>, но эта возможность используется редко и
не поддерживается стандартными модулями автокомпиляции. Таким образом, в автокомпилируемой модели набор
статических переменных с их именами и и типами остается постоянным в течение всего времени жизни блока.</p>

<p>Каждая статическая переменная имеет роль (вход, выход или внутренняя переменная), определенный
тип, уникальное в блоке имя, значение по умолчанию и, возможно, комментарий, выводящийся вместе с ее именем
в <a href="um_2_7_1.htm#ref3" title="Меню создания связи">меню подключения связи</a>
к блоку. Кроме того, с входами и выходами могут быть связаны дополнительные переменные,
<a href="um_3_7_2_8.htm" title="&sect;3.7.2.8. Использование выходов с управляющими переменными">разрешающие или запрещающие работу выхода</a>
и <a href="um_3_7_2_7.htm" title="&sect;3.7.2.7. Использование входов со связанными сигналами">получающие сигнал о срабатывании входа</a>.</p>

<p><span id="light_ref1">Входы</span>
и <span id="light_ref2">выходы</span> &ndash; основные роли статических переменных блока.
Большинство блоков, как стандартных, так и пользовательских, занимаются тем, что считывают полученные по
связям от других блоков значения со своих входов и вычисляют по ним значения своих выходов, которые точно так
же, по связям, передаются в другие блоки. Простейший пример модели блока, выдающего на выход сумму двух своих
входов, приведен в <a href="um_3_3.htm" title="&sect;3.3. Создание нового блока с автокомпилируемой моделью">&sect;3.3</a>. Если у блока нет входов или выходов, к нему
невозможно подключить связи, и он может обмениваться информацией с другими только через
<a href="um_index.htm#light_htm:um_3_7_12" title="&sect;3.7.13. Вызов функций блоков">вызовы функций</a> или
<a href="um_index.htm#light_htm:um_3_7_3" title="&sect;3.7.3. Работа с динамическими переменными">динамические переменные</a> &ndash; такие блоки тоже встречаются, но
гораздо реже. <span id="light_ref3">Внутренние статические переменные</span> используются,
в основном, для хранения промежуточных значений.</p>

<p>Возможные
<span id="light_ref4">типы переменных блока</span>, поддерживаемые RDS, подробно описаны в
<a href="um_1_4.htm" title="&sect;1.4. Статические переменные блоков">&sect;1.4</a>.
<span id="ref5">Все</span>
они, <span id="light_ref5">за исключением произвольного</span>, то есть программно
изменяемого, типа, поддерживаются стандартным модулем автокомпиляции. Таким образом, статическая переменная
в автокомпилируемом блоке может иметь один из следующих типов:</p>

<ul>
  <li><span class="emph">Целые типы</span> &ndash;
  &laquo;<span class="cpp"><span id="light_ref6">char</span></span>&raquo;,
  &laquo;<span class="cpp"><span id="light_ref7">short</span></span>&raquo; и
  &laquo;<span class="cpp"><span id="light_ref8">int</span></span>&raquo; &ndash; предназначены
  для работы с целыми числами. В автокомпилируемых моделях лучше всего применять тип &laquo;<span class="cpp">int</span>&raquo;: из всех
  трех целых типов у него самая большая разрядность (32 бита), и в переменной такого типа может храниться число в
  диапазоне &minus;2147483648&thinsp;&hellip;&thinsp;+2147483647. Типы &laquo;<span class="cpp">short</span>&raquo; и &laquo;<span class="cpp">char</span>&raquo; добавлены в
  RDS для совместимости и используются крайне редко.</li>

  <li><span class="emph">Вещественные типы</span> &ndash;
  &laquo;<span class="cpp"><span id="light_ref9">float</span></span>&raquo; и
  &laquo;<span class="cpp"><span id="light_ref10">double</span></span>&raquo; &ndash; позволяют работать с вещественными числами. В
  автокомпилируемых моделях имеет смысл использовать тип &laquo;<span class="cpp">double</span>&raquo;: у
  него больше разрядность и диапазон значений &ndash; модуль числа типа <span class="cpp">double</span> может находиться в диапазоне
  2.23&times;10<sup>&minus;308</sup>&thinsp;&hellip;&thinsp;1.79&times;10<sup>308</sup>. Кроме того, все
  стандартные математические блоки в RDS используют именно тип &laquo;<span class="cpp">double</span>&raquo;,
  и для него предусмотрено специальное значение, обозначающее ошибку выполнения математической операции.
  <span id="ref11">В</span>
  автокомпилируемых моделях это значение хранится в глобальной переменной
  <span class="cpp" id="light_ref11">rdsbcppHugeDouble</span> (пример ее использования приведен в
  <a href="um_3_7_2_1.htm" title="&sect;3.7.2.1. Модели с простыми статическими переменными">&sect;3.7.2.1</a>).</li>

  <li><span class="emph"><span id="light_ref12">Логический тип</span></span>
  &ndash; переменная такого типа может принимать значения 0 (&laquo;ложь&raquo;) и 1
  (&laquo;истина&raquo;).</li>

  <li><span class="emph"><span id="light_ref13">Сигнальный тип</span></span> &ndash; как и логический,
  может иметь только значения 0 и 1, но передача сигналов по связям принципиально отличается: значение сигнального
  выхода передается на сигнальный вход только в том случае, если оно равно единице. Таким образом, появившаяся на
  сигнальном входе блока единица никогда не будет заменена нулем по связи и останется там до тех пор, пока сам
  блок не сотрет значение своего собственного входа &ndash; это полезно для регистрации наступления какого-либо
  события, обозначаемого сигнальной связью. Особенности передачи сигналов подробно рассмотрены в
  <a href="um_1_4.htm" title="&sect;1.4. Статические переменные блоков">&sect;1.4 описания пользователя</a> и в <a href="pm_2_5_2.htm" title="&sect;2.5.2. Особенности использования сигналов">&sect;2.5.2 руководства программиста</a>.
  Пример автокомпилируемой модели, использующей сигнальные переменные, приведен в
  <a href="um_3_7_2_6.htm" title="&sect;3.7.2.6. Использование сигналов">&sect;3.7.2.6</a>.</li>

  <li><span class="emph"><span id="light_ref14">Массив</span></span> &ndash; набор пронумерованных
  переменных одинакового типа. Элементы массива нумеруются начиная с нуля, для обращения к конкретному элементу
  его индекс, как принято в языке C, записывается в квадратных скобках: <span class="cpp">i</span>-й элемент массива
  <span class="cpp">A</span> записывается как &laquo;<span class="cpp">A[i]</span>&raquo;. Тип элемента массива может быть любым, за
  исключением другого массива (тем не менее, можно создавать массивы матриц, см. ниже). Размер массива не
  фиксирован, он может изменяться в процессе работы блока. По умолчанию проверка допустимости индекса не
  производится, и если попытаться обратиться к элементу за пределами текущего размера массива, работа модели будет
  аварийно завершена. В параметрах модели можно
  <a href="um_3_6_7.htm#ref8" title="Автоматическая проверка индексов массивов">включить такую проверку</a>
  &ndash; это может замедлить работу модели блока, но зато, при ошибке, модель
  выдаст более понятное диагностическое сообщение. Пример работы с массивами в модели блока приведен в
  <a href="um_3_7_2_3.htm" title="&sect;3.7.2.3. Модели с массивами">&sect;3.7.2.3</a>.</li>

  <li><span class="emph"><span id="light_ref15">Матрица</span></span> &ndash;
  двумерная таблица переменных одинакового типа. Элемент матрицы определяется индексом строки и
  индексом столбца, начинающимися с нуля. Обращения к конкретному элементу матрицы в интерфейсе RDS
  (например, при <a href="um_2_7_3.htm" title="&sect;2.7.3. Подключение связей к полям структур и элементам массивов">присоединении к нему связи</a>) и в программе отличаются:
  в RDS индексы перечисляются в квадратных скобках через запятую (&laquo;<span class="cpp">M[2,7]</span>&raquo; &ndash; элемент
  матрицы <span class="cpp">M</span> в строке с индексом 2 и столбце с индексом 7), а в программе индексы пишутся в
  отдельных квадратных скобках по правилам языка C (&laquo;<span class="cpp">M[r][c]</span>&raquo; &ndash; элемент матрицы
  <span class="cpp">M</span> в строке с индексом <span class="cpp">r</span> и столбце с индексом
  <span class="cpp">c</span>). Тип элемента матрицы может быть любым, в том числе и другой матрицей (в
  RDS вложенность матриц ограничена пятью). Размер матрицы, как и у массива, не фиксирован, он может
  изменяться в процессе работы блока. По умолчанию обращение к элементу матрицы за пределами ее текущего размера
  не отслеживается и может прервать работу модели. В параметрах модели можно
  <a href="um_3_6_7.htm#ref8" title="Автоматическая проверка индексов массивов">включить такую проверку</a> ценой некоторого уменьшения скорости работы. Пример
  работы с матрицами в модели блока приведен в <a href="um_3_7_2_2.htm" title="&sect;3.7.2.2. Модели с матрицами">&sect;3.7.2.2</a>.</li>

  <li><span class="emph"><span id="light_ref16">Строка</span></span> &ndash;
  <span id="ref17">последовательность</span>
  символов в <span id="light_ref17">кодировке Windows CP1251</span>, завершающаяся нулевым байтом.
  Многобайтовые символы Unicode не поддерживаются.</li>

  <li><span class="emph"><span id="light_ref18">Структура</span></span> &ndash; жестко
  заданный набор полей, каждое из которых имеет свое имя и тип. Всей структуре целиком присваивается имя типа,
  под которым она будет известна пользователю. Набор полей структуры с именами и типами и имя ее собственного
  типа задаются через
  <a href="um_2_14.htm" title="&sect;2.14. Создание и изменение структур">окно списка структур</a>, вызываемое пунктом главного меню RDS
  &laquo;<span class="menu">система | структуры</span>&raquo;. Стандартные блоки RDS используют единственную структуру с именем типа
  &laquo;<span class="rdsvar">Complex</span>&raquo; и двумя вещественными полями &laquo;<span class="rdsvar">Re</span>&raquo; и
  &laquo;<span class="rdsvar">Im</span>&raquo;, предназначенную для работы с комплексными числами. Пользователь может добавлять и
  редактировать свои структуры, но следует иметь в виду, что редактирование состава полей структуры, уже
  используемой в модели какого-либо блока, может привести к неработоспособности этого блока. К автокомпилируемым
  моделям это относится в меньшей степени: после редактирования структуры следует просто скомпилировать модель
  заново, и, если в тексте программы нет обращений к удаленным полям структуры, блок восстановит работоспособность.
  Пример работы со структурами в модели блока приведен в <a href="um_3_7_2_4.htm" title="&sect;3.7.2.4. Модели со структурами">&sect;3.7.2.4</a>.</li>
</ul>

<p class="noindent">Первые две переменные простого блока всегда представляют собой сигнальный вход и сигнальный выход,
пользователь не может ни удалить их, ни изменить их роль и тип &ndash; их можно только переименовать.
<span id="ref19">Сигнальный</span>
вход (по умолчанию он называется &laquo;<span class="rdsvar"><span id="light_ref19">Start</span></span>&raquo;) разрешает срабатывание
модели блока, если в параметрах блока не установлен флажок
&laquo;<a href="um_2_9_1.htm#light_ref8" title="Установка режима запуска блока">запуск каждый такт</a>&raquo;.
<span id="ref20">Сигнальный</span> выход (по умолчанию &ndash;
&laquo;<span id="light_ref20">Ready</span>&raquo;) сообщает подключенным к нему блокам об успешном
срабатывании данного блока. Подробнее эти фиксированные сигналы описаны в
<a href="um_1_4.htm" title="&sect;1.4. Статические переменные блоков">&sect;1.4</a> и в примерах в
<a href="um_3_7_2_6.htm#ref2" title="Пример использования сигнала Start">&sect;3.7.2.6</a> и <a href="um_3_7_3_1.htm#light_ref6" title="Пример присвоения значения сигналу готовности блока">&sect;3.7.3.1</a>.</p>

<p>Список статических переменных блока отображается на верхней части вкладки
&laquo;<span class="menu">переменные</span>&raquo; в окне редактора модели (см. <a href="#pic1" title="Вкладка переменные дополнительной панели">рис.&nbsp;333</a>).
В списке &ndash; четыре колонки:</p>

<ul>
  <li><span class="emph">колонка без названия</span> &ndash; роль переменной (вход, выход или внутренняя),
  изображаемая такими же картинками, как и в
  <a href="um_2_7_1.htm#ref3" title="Меню создания связи">меню присоединения связей</a>:
  &laquo;круг и стрелка от него&raquo; &ndash; выход, &laquo;круг и стрелка к нему&raquo; &ndash; вход,
  отсутствие картинки &ndash; внутренняя;</li>

  <li>&laquo;<span class="menu">имя</span>&raquo; &ndash; имя переменной;</li>

  <li>&laquo;<span class="menu">тип</span>&raquo; &ndash; название или условное обозначение типа переменной;</li>

  <li>&laquo;<span class="menu">логика</span>&raquo; &ndash; имя вспомогательной логической, сигнальной или целой переменной,
  подключенной к данной (см. примеры в <a href="um_3_7_2_7.htm" title="&sect;3.7.2.7. Использование входов со связанными сигналами">&sect;3.7.2.7</a> и
  <a href="um_3_7_2_8.htm" title="&sect;3.7.2.8. Использование выходов с управляющими переменными">&sect;3.7.2.8</a>);</li>

  <li>&laquo;<span class="menu">значение</span>&raquo; &ndash; значение переменной по умолчанию, которое она получает при
  <a href="um_1_3.htm#ref9" title="Сброс расчета">сбросе расчета</a>.</li>
</ul>

<p><span id="ref21">Колонки</span>
в списке можно переставлять и менять их ширину, перетаскивая левой кнопкой мыши их заголовки или
границы заголовков. Нажатием
<span class="keys">Ctrl</span>&nbsp;+&nbsp;<span class="keys">C</span> выделенную в списке переменную можно скопировать в буфер обмена для последующей
вставки в текст программы.
Редактировать переменные непосредственно в списке нельзя, для этого следует нажимать кнопку
&laquo;<span class="menu">изменить</span>&raquo; под списком, которая вызывает стандартное <span id="light_ref21">окно
<a href="um_2_9_2.htm" title="&sect;2.9.2. Редактирование списка переменных блока">редактора переменных</a></span> RDS. Кнопка
&laquo;<span class="menu">очистить</span>&raquo; полностью очищает список статических переменных блока &ndash; при пустом списке для
блоков с данной моделью не будет устанавливаться структура переменных. Разумеется, упомянутые выше сигнальные
переменные &laquo;<span class="rdsvar">Start</span>&raquo; и &laquo;<span class="rdsvar">Ready</span>&raquo; у простых блоков все равно будут присутствовать,
просто они будут недоступны для программы модели.</p>

<p>Для каждой статической переменной в формируемый модулем автокомпиляции текст программы автоматически добавляется
одноименный объект, принадлежащий одному из специальных классов доступа к статическим переменным. При этом
внутри реакций на события, которые вводятся в правой части окна редактора, к переменным можно обращаться просто по
имени, используя их в стандартных выражениях языка C. Если, например, в модели заданы вещественные статические
переменные &laquo;<span class="rdsvar">x</span>&raquo;, &laquo;<span class="rdsvar">y</span>&raquo; и &laquo;<span class="rdsvar">K</span>&raquo;, в тексте программы можно писать
&laquo;<span class="cpp">y=K*x;</span>&raquo;. К полям структур можно обращаться, как и принято в C, отделяя их точкой от имени
переменной структуры, индексы массивов и матриц указываются в квадратных скобках (примеры моделей, использующих
различные типы переменных, приведены в <a href="um_index.htm#light_htm:um_3_7_2" title="&sect;3.7.2. Работа со статическими переменными блока">&sect;3.7.2</a>. При этом следует помнить, что,
с точки зрения компилятора, все переменные блока &ndash; это объекты некоторых специальных классов C++, для
которых определены операторы присваивания, операторы приведения типов и т.п. и за которыми скрыты
&laquo;настоящие&raquo; переменные блока. Это не имеет значения, если переменные используются в математических
выражениях: в приведенном выше примере &laquo;<span class="cpp">y=K*x;</span>&raquo; для объектов <span class="cpp">K</span> и
<span class="cpp">x</span> будет автоматически вызван оператор приведения к вещественному типу, а для объекта
<span class="cpp">y</span> &ndash; оператор присваивания этому объекту вещественного числа. Однако, если попытаться
взять указатель на <span class="cpp">y</span>, это будет не указатель на вещественное число, а указатель на
объект некоторого класса, что <a href="um_3_7_1.htm#ref24" title="Проблемы указателей на переменные блока">следует учитывать</a> при написании моделей.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_6_1.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_6_3.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_6_2">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
