<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.7.12. Добавление пунктов в контекстное и системное меню</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</a></p>
<div class="level"><p>&sect;3.7.12. Добавление пунктов в контекстное и системное меню</p>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_7_10.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_12_1.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_11">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</h3>
<h4>&sect;3.7.12. Добавление пунктов в контекстное и системное меню</h4>
<p class="abstract">Рассматривается программное добавление моделью блока новых пунктов в контекстное (вызываемое по правой кнопке) и главное меню RDS. При помощи этих пунктов блок может принимать от пользователя команды в режиме редактирования, в котором большинство остальных способов взаимодействия моделей блоков с пользователем отключено.</p>


<p>Модели блоков могут добавлять свои собственные пункты как в
<a href="um_2_6.htm#pic3" title="Контекстное меню блока (поля ввода)">контекстное меню</a>
(меню, которое вызывается при нажатии правой кнопки мыши на изображении блока), так и в
<a href="um_2_1.htm" title="&sect;2.1. Главное окно и главное меню">главное меню</a> RDS.
Добавление пунктов в контекстное меню обычно используется для предоставления пользователю быстрого доступа
к каким-либо функциям, выполняемым блоком, или для переключения режимов работы этого блока. Добавление пунктов
в главное меню используется гораздо реже: в отличие от контекстного, индивидуального для каждого блока,
главное меню &ndash; общее для всей схемы, поэтому туда имеет смысл добавлять пункты для действий,
уникальных для данной схемы. Например, в главное меню можно добавить пункт для открытия какого-либо
очень важного окна подсистемы, чтобы пользователь не искал эту подсистему по всей схеме.</p>

<p>Пункты контекстного меню всегда добавляются в его конец, а пункты главного
&ndash; в специальный подпункт &laquo;<span class="menu">система | дополнительно</span>&raquo;. Доступность этих пунктов
пользователю определяется не режимом RDS, а разработчиком модели: он может разрешать или запрещать
различные пункты в зависимости от текущего состояния блока по своему желанию. Здесь будут приведены
только самые простые примеры добавления пунктов в меню, более подробно эти вопросы рассмотрены в
<a href="pm_2_12_6.htm" title="&sect;2.12.6. Добавление пунктов в контекстное меню блока">&sect;2.12.6</a> и
<a href="pm_2_12_7.htm" title="&sect;2.12.7. Добавление пунктов в системное меню RDS">&sect;2.12.7 руководства программиста</a>.</p>

<p>В <a href="um_3_7_10.htm" title="&sect;3.7.11. Реакция блока на мышь">&sect;3.7.11</a> рассматривался
<a href="um_3_7_10.htm#ref19" title="Пример модели двухкоординатной рукоятки">блок-рукоятка</a>, с помощью которого пользователь мог задавать
значения двух координат, перемещая мышью круг внутри прямоугольника. Добавим в контекстное меню этого
блока пункты, позволяющие обнулять одну из задаваемых координат или обе координаты сразу: это позволит
не только точно приводить к нулю выходы блока (точно переместить мышью круг может оказаться не такой
простой задачей), но и даст пользователю возможность сбрасывать значения блока не только в
режимах <a href="um_1_3.htm#ref2" title="Режим моделирования">моделирования</a> и
<a href="um_1_3.htm#ref3" title="Режим расчета">расчета</a>, но и в режиме
<a href="um_1_3.htm#ref1" title="Режим редактирования">редактирования</a>, в котором реакции блока на мышь не вызываются.</p>

<p>Чтобы добавить пункты в контекстное меню блока, в модель этого блока необходимо ввести сразу две
реакции: реакцию на вызов контекстного меню, в которой и будут добавлены новые пункты, и реакцию на
выбор пункта меню, в которой модель блока будет реагировать на выбор пользователем одного из этих
добавленных пунктов. В
<a href="um_3_6_4.htm" title="&sect;3.6.4. Описания программы и реакции блока на события">списке событий</a>
редактора модели обе эти реакции находятся в разделе
&laquo;<span class="menu">разное</span>&raquo;
(<a href="#pic1" title="Реакции на вызов меню и выбор пункта в списке событий">рис.&nbsp;456</a>).</p>

<div class="pic"><div class="container" id="pic1">
<img src="../img/AC_events_menu.png" width="484" height="299" alt="Реакции на вызов меню и выбор пункта в списке событий" />
<p id="light_pic1">Рис.&nbsp;456. Реакции на вызов меню и выбор пункта в списке событий</p>
</div></div>


<p>Введем в ранее созданный блок-рукоятку реакцию на открытие контекстного меню, в которой мы добавим в
меню три новых пункта. Для этого откроем редактор модели этого блока, на вкладке
&laquo;<span class="menu">события</span>&raquo; в разделе &laquo;<span class="menu">разное</span>&raquo; дважды щелкнем на подразделе
&laquo;<span class="menu">вызов контекстного меню</span>&raquo; и введем на открывшейся вкладке
&laquo;<span class="menu">вызов меню</span>&raquo; следующий текст:</p>

<pre class="cpp">  <span id="ref1">//</span> <span id="ref2">Разделитель</span>
  <span id="light_ref1"><a class="hidden" href="rdsAdditionalContextMenuItemEx.htm" title="А.5.17.2. rdsAdditionalContextMenuItemEx &ndash; добавить временный пункт в контекстное меню блока">rdsAdditionalContextMenuItemEx</a></span>(NULL,<span id="light_ref2">RDS_MENU_DIVIDER</span>,0,0);

  <span id="ref3">//</span> Исполняемые пункты
  <a class="hidden" href="rdsAdditionalContextMenuItemEx.htm" title="А.5.17.2. rdsAdditionalContextMenuItemEx &ndash; добавить временный пункт в контекстное меню блока">rdsAdditionalContextMenuItemEx</a>("Обнулить X",
    x==0.0?<span id="light_ref3">RDS_MENU_DISABLED</span>:0,1,0);
  <a class="hidden" href="rdsAdditionalContextMenuItemEx.htm" title="А.5.17.2. rdsAdditionalContextMenuItemEx &ndash; добавить временный пункт в контекстное меню блока">rdsAdditionalContextMenuItemEx</a>("Обнулить Y",
    y==0.0?RDS_MENU_DISABLED:0,2,0);
  <a class="hidden" href="rdsAdditionalContextMenuItemEx.htm" title="А.5.17.2. rdsAdditionalContextMenuItemEx &ndash; добавить временный пункт в контекстное меню блока">rdsAdditionalContextMenuItemEx</a>("Обнулить все",
    x==0.0&amp;&amp;y==0.0?RDS_MENU_DISABLED:0,3,0);</pre>

<p>Для добавления пунктов в контекстное меню из реакции на вызов этого меню мы используем функцию
<span class="cpp"><a href="rdsAdditionalContextMenuItemEx.htm" title="А.5.17.2. rdsAdditionalContextMenuItemEx &ndash; добавить временный пункт в контекстное меню блока">rdsAdditionalContextMenuItemEx</a></span>. В первом параметре функции передается
текст добавляемого пункта, во втором &ndash; набор битовых флагов, определяющих его внешний вид, в
третьем и четвертом &ndash; два целых числа, которые без изменения будут переданы в реакцию
модели на выбор этого пункта (можно считать эти числа идентификатором пункта, по которому
модель сможет понять, какой именно из добавленных пунктов был выбран пользователем).</p>

<p>В самом первом вызове функции вместо текста пункта передается <span class="cpp">NULL</span>, а в
битовых флагах &ndash; <span class="cpp">RDS_MENU_DIVIDER</span>. Это приведет к тому, что вместо
нормального пункта в контекстное меню будет добавлена горизонтальная линия, которая визуально отделит
добавляемые нами пункты от остальной части меню, за которую отвечает RDS. На самом деле, можно было
бы и не передавать флаг <span class="cpp">RDS_MENU_DIVIDER</span>, поскольку
<span class="cpp">NULL</span> вместо текста пункта уже дает RDS понять, что нужно добавить не пункт
меню, а горизонтальный разделитель. Два последних параметра <span class="cpp">rdsAdditionalContextMenuItemEx</span>
при таком вызове игнорируются (разделитель не может быть выбран пользователем), поэтому в них можно
передать что угодно &ndash; мы передаем нули.</p>

<p>Следующие три вызова <span class="cpp">rdsAdditionalContextMenuItemEx</span> добавляют в меню пункты
&laquo;<span class="menu">обнулить X</span>&raquo;, &laquo;<span class="menu">обнулить Y</span>&raquo; и
&laquo;<span class="menu">обнулить все</span>&raquo;, с которыми мы связываем пары целых чисел (1,0), (2,0) и (3,0)
соответственно. В реакции на выбор пункта меню нам достаточно будет проверять только первое из этих
чисел: значение 1 будет означать, что выбран пункт &laquo;<span class="menu">обнулить X</span>&raquo;, значение 2
&ndash; &laquo;<span class="menu">обнулить Y</span>&raquo;, значение 3
&ndash; &laquo;<span class="menu">обнулить все</span>&raquo;. Во втором параметре каждого вызова стоит условное выражение,
имеющее значение <span class="cpp">RDS_MENU_DISABLED</span>, если соответствующие этому пункту меню
переменные блока уже равны нулю, и ноль в противном случае. Битовый флаг
<span class="cpp">RDS_MENU_DISABLED</span> указывает RDS на то, что пункт меню должен быть
запрещенным и что пользователь не может его выбрать. Таким образом, пункты
&laquo;<span class="menu">обнулить&hellip;</span>&raquo; будут разрешенными, только если соответствующие им координаты еще
не обнулены &ndash; это даст пользователю некоторую визуальную обратную связь.</p>

<p>Добавление пунктов мы реализовали, теперь нужно ввести в модель реакцию на их выбор. На вкладке
&laquo;<span class="menu">события</span>&raquo; в разделе &laquo;<span class="menu">разное</span>&raquo; дважды щелкнем на подразделе
&laquo;<span class="menu">выбор пункта меню</span>&raquo; и введем на открывшейся вкладке
&laquo;<span class="menu">пункт меню</span>&raquo; следующий текст:</p>

<pre class="cpp">  <span id="ref4">//</span> Какой пункт выбран
  switch(<span id="light_ref4">MenuData</span>-&gt;Function)
    { case 1: x=0; break;	// Обнулить X
      case 2: y=0; break;	// Обнулить Y
      case 3: x=y=0; break;	// Обнулить все
    }
  // Взводим сигнал готовности для передачи выходов по связям
  Ready=1;</pre>

<p><span id="ref5">В</span>
эту реакцию в параметре <span class="cpp">MenuData</span> передается указатель на структуру
<span id="light_ref5"><span class="cpp"><a href="RDS_BFM_MENUFUNCTION.htm#ref1" title="Структура RDS_MENUFUNCDATA">RDS_MENUFUNCDATA</a></span></span>, состоящую всего из двух целых полей:
<span class="cpp">Function</span> и <span class="cpp">MenuData</span>.
В поле <span class="cpp">Function</span> записано первое из двух целых чисел, которые мы связали с
выбранным пользователем пунктом меню в вызове <span class="cpp">rdsAdditionalContextMenuItemEx</span>,
в поле <span class="cpp">MenuData</span> &ndash; второе из них. Таким образом, для того, чтобы выяснить,
какой их трех добавленных нами пунктов выбрал пользователь, нам нужно сравнить
<span class="cpp">MenuData-&gt;Function</span> с числами 1, 2 и 3, что мы и делаем в операторе
<span class="cpp">switch</span>.</p>

<p>После того, как, в зависимости от выбранного пользователем пункта, мы обнулили нужный выход
блока, мы, как всегда, взводим сигнал готовности блока
<span class="cpp"><a href="um_1_4.htm#ref27" title="Сигнал готовности блока">Ready</a></span>, чтобы новое значение выхода
передалось по связям.</p>

<p>Теперь, если скомпилировать модель и щелкнуть на блоке правой кнопкой мыши, в конце его
контекстного меню появятся разделитель и три новых пункта
(<a href="#pic2" title="Контекстное меню блока в режиме редактирования (слева) и моделирования (справа)">рис.&nbsp;457</a>).
Меню будет выглядеть по-разному, в зависимости от режима RDS, но добавленные нами пункты будут в
нем присутствовать всегда. При этом пункт обнуления выхода будет разрешенным только в том случае, если
этот выход не равен нулю в точности (на рисунке выход &laquo;<span class="rdsvar">x</span>&raquo; в точности равен нулю, и
пункт &laquo;<span class="menu">обнулить X</span>&raquo; заблокирован).</p>

<div class="pic"><div class="container" id="pic2">
<img src="../img/AC_contextmenu_test.png" width="566" height="506" alt="Контекстное меню блока в режиме редактирования (слева) и моделирования (справа)" />
<p id="light_pic2">Рис.&nbsp;457. Контекстное меню блока в режиме редактирования (слева)<br />и моделирования (справа)</p>
</div></div>


<p>Теперь рассмотрим добавление пунктов меню в главное меню RDS. Это несколько сложнее, чем
добавлять пункты в контекстное. В рассмотренном выше примере мы добавляли в контекстное меню временные
пункты, которые автоматически уничтожались RDS при закрытии этого меню (подробнее об этом
&ndash; в <a href="pm_2_12_6.htm" title="&sect;2.12.6. Добавление пунктов в контекстное меню блока">&sect;2.12.6 руководства программиста</a>). Главное меню, в отличие от
контекстного, не связано с каким-либо конкретным блоком, поэтому у блока не может быть реакции на
открытие главного меню. Если бы такая реакция была предусмотрена в RDS, ее пришлось бы вызывать
для всех блоков загруженной схемы, спрашивая у модели каждого из них, не желает ли она
добавить что-либо в главное меню. Такое усложнение не было бы оправданным, поэтому добавление пунктов
в главное меню устроено иначе. Модель блока в любой момент своего существования может создать в
главном меню свой собственный пункт при помощи вызова
<span class="cpp"><a href="rdsRegisterMenuItem.htm" title="А.5.17.8. rdsRegisterMenuItem &ndash; создать пункт системного меню RDS">rdsRegisterMenuItem</a></span>, RDS запомнит этот факт и свяжет этот пункт с
создавшим его блоком, пока модель не уничтожит этот пункт или пока блок не будет удален.</p>

<p>Чтобы проиллюстрировать возможность добавления пунктов в главное меню, создадим блок, который
будет вычислять скорость расчета RDS в
<a href="um_1_3.htm#ref4" title="Такт расчета">тактах</a>
в секунду. Значение этой скорости будет
показываться пользователю при выборе пункта меню
&laquo;<span class="menu">система | дополнительно | статистика</span>&raquo; или при нажатии сочетания клавиш
<span class="keys">Ctrl</span>+<span class="keys">Alt</span>+<span class="keys">S</span>.
<span id="ref6">Наш</span>
блок будет
работать следующим образом: при запуске расчета он запомнит время с момента загрузки Windows, возвращаемое
стандартной функцией API <span class="cpp" id="light_ref6">GetTickCount</span>.
В каждом такте расчета он будет увеличивать на единицу внутреннюю переменную &ndash; счетчик тактов.
При запросе пользователем статистики модель разделит число тактов на прошедший интервал времени и
покажет результат пользователю. Чтобы статистику можно было вызвать и при остановленном расчете, в
момент остановки блок тоже будет запоминать результат <span class="cpp">GetTickCount</span> в
специальной переменной, и, при запросе статистики, показывать скорость последнего выполненного расчета.
Внутренний счетчик тактов блока мы назовем &laquo;<span class="rdsvar">Num</span>&raquo;, переменную для хранения времени начала расчета
&ndash; &laquo;<span class="rdsvar">StartTick</span>&raquo;, переменную, для хранения времени его конца &ndash;
&laquo;<span class="rdsvar">EndTick</span>&raquo;.  Таким образом, наш блок будет иметь следующую структуру
<a href="um_3_6_2.htm" title="&sect;3.6.2. Статические переменные блока">статических переменных</a>:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr><td class="vcenter">Start</td>
<td class="center">Сигнал</td>
<td class="center">Вход</td>
<td class="center">&checkmark;</td>
<td class="center">0</td>
</tr>
<tr><td class="vcenter">Ready</td>
<td class="center">Сигнал</td>
<td class="center">Выход</td>
<td></td>
<td class="center">0</td>
</tr>
<tr><td class="vcenter">Num</td>
<td class="center">int</td>
<td class="center">Внутренняя</td>
<td></td>
<td class="center">0</td>
</tr>
<tr><td class="vcenter">StartTick</td>
<td class="center">double</td>
<td class="center">Внутренняя</td>
<td></td>
<td class="center">0</td>
</tr>
<tr><td class="vcenter">EndTick</td>
<td class="center">double</td>
<td class="center">Внутренняя</td>
<td></td>
<td class="center">0</td>
</tr>


</table>
</div></div>

<p>Несмотря на то, что функция <span class="cpp">GetTickCount</span> возвращает целое число миллисекунд
с момента загрузки Windows, переменные для хранения результата ее возврата мы сделали вещественными
&ndash; для вычисления скорости нам потребуются вещественные числа, поскольку нам придется делить число
миллисекунд на тысячу, чтобы получить скорость в тактах в секунду.</p>

<p><a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">Создадим</a> в схеме новый блок и зададим ему указанную выше
структуру статических переменных. Нам нужно, чтобы блок запускался каждый такт (он должен считать
эти такты) &ndash; можно просто при его создании установить флаг запуска каждый такт
(см.  <a href="um_3_7_2_1.htm#pic2" title="Установка запуска по сигналу в окне параметров блока">рис.&nbsp;363</a>), а можно написать модель
таким образом, чтобы блок запускался каждый такт независимо от состояния этого флага. Так мы и поступим.</p>

<p>Прежде всего,
<a href="um_3_7_2_5.htm#ref5" title="Включение stdio.h в автокомпилируемую модель">добавим</a>
в нашу модель стандартный файл заголовков &laquo;<span class="file">stdio.h</span>&raquo;
&ndash; сообщение пользователю мы будем формировать функцией <span class="cpp">sprintf</span>, описанной в
этом файле. Раскроем на вкладке
&laquo;<span class="menu">события</span>&raquo; левой панели редактора раздел
&laquo;<span class="menu">описания</span>&raquo; и дважды щелкнем на открывшемся подразделе
&laquo;<span class="menu">глобальные описания</span>&raquo;. На появившейся в правой части окна пустой вкладке введем команду
включения нужного файла:</p>

<pre class="cpp">  #include &lt;stdio.h&gt;</pre>

<p>Теперь добавим в модель реакцию на запуск расчета: при запуске мы должны сбросить счетчик тактов и
запомнить время начала расчета. На вкладке &laquo;<span class="menu">события</span>&raquo; раскроем раздел
&laquo;<span class="menu">моделирование и режимы</span>&raquo; и дважды щелкнем на подразделе &laquo;<span class="menu">запуск расчета</span>&raquo;
(<a href="#pic3" title="Запуск и остановка расчета в списке событий">рис.&nbsp;458</a>).
Откроется вкладка &laquo;<span class="menu">запуск</span>&raquo;, на которой нужно ввести следующие команды:</p>

<pre class="cpp">  // Сброс счетчика тактов
  Num=0;
  // Запоминение времени старта
  StartTick=GetTickCount();
  // Принудительный запуск модели
  Start=1;</pre>

<div class="pic"><div class="container" id="pic3">
<img src="../img/AC_events_startstop.png" width="304" height="276" alt="Запуск и остановка расчета в списке событий" />
<p id="light_pic3">Рис.&nbsp;458. Запуск и остановка расчета в списке событий</p>
</div></div>


<p>В счетчик тактов <span class="cpp">Num</span> мы записываем ноль, в переменную времени начала расчета
&ndash; результат возврата <span class="cpp">GetTickCount</span> (то есть текущее время с момента загрузки
Windows в миллисекундах), а в сигнал запуска блока <span class="cpp"><a href="um_1_4.htm#ref25" title="Сигнал запуска блока">Start</a></span>
&ndash; единицу, что приведет к принудительному запуску модели в ближайшем такте расчета. Если для
блока установлен запуск каждый такт, то модель запустится независимо от значения <span class="cpp">Start</span>.
Если же установлен запуск по сигналу, то модель запустится потому, что мы только что взвели этот сигнал.</p>

<p>При остановке расчета нам нужно запомнить время этой остановки в переменной
<span class="cpp">EndTick</span>. Добавим в модель реакцию на остановку: в том же самом разделе
&laquo;<span class="menu">моделирование и режимы</span>&raquo; вкладки
&laquo;<span class="menu">события</span>&raquo; дважды щелкнем на подразделе
&laquo;<span class="menu">остановка расчета</span>&raquo; (см. <a href="#pic3" title="Запуск и остановка расчета в списке событий">рис.&nbsp;458</a>) и
на открывшейся вкладке &laquo;<span class="menu">остановка</span>&raquo; введем оператор присваивания:</p>

<pre class="cpp">  // Запоминение времени остановки
  EndTick=GetTickCount();</pre>

<p>В такте расчета мы должны, во-первых, увеличить на единицу счетчик тактов <span class="cpp">Num</span>, и,
во-вторых, взвести сигнал <span class="cpp">Start</span> для принудительного запуска модели в следующем
такте независимо от настроек блока. В разделе &laquo;<span class="menu">моделирование и режимы</span>&raquo; дважды щелкнем на
подразделе &laquo;<span class="menu">модель</span>&raquo; и введем на открывшейся вкладке следующий текст:</p>

<pre class="cpp">  // Увеличиваем счетчик тактов
  Num++;
  // Принудительный запуск модели
  Start=1;</pre>

<p><span id="ref7">Теперь</span>
<span id="ref8">перейдем</span>
<span id="ref9">собственно</span>
<span id="ref10">к</span>
<span id="ref11">добавлению</span>
пункта в главное меню. Будем делать это при инициализации блока,
то есть в момент подключения к нему модели. На вкладке
&laquo;<span class="menu">события</span>&raquo; раскроем раздел
&laquo;<span class="menu">создание и уничтожение</span>&raquo; и дважды щелкнем в нем на подразделе
&laquo;<span class="menu">инициализация блока</span>&raquo;
(<a href="#pic4" title="Инициализация блока в списке событий">рис.&nbsp;459</a>).
Откроется вкладка &laquo;<span class="menu">инициализация</span>&raquo;, на которой мы введем вызов для добавления пункта в
главное меню:</p>

<pre class="cpp">  <span id="light_ref7"><a class="hidden" href="rdsRegisterMenuItem.htm" title="А.5.17.8. rdsRegisterMenuItem &ndash; создать пункт системного меню RDS">rdsRegisterMenuItem</a></span>("Статистика",
    <span id="light_ref8">RDS_MENU_SHORTCUT</span>|<span id="light_ref9">RDS_MENU_UNIQUECAPTION</span>,
    'S',
    <span id="light_ref10"><a class="hidden" href="RDS_BFM_KEYDOWN.htm#light_ref9" title="RDS_KALT">RDS_KALT</a></span>|<span id="light_ref11"><a class="hidden" href="RDS_BFM_KEYDOWN.htm#light_ref10" title="RDS_KCTRL">RDS_KCTRL</a></span>,
    0,0);</pre>

<div class="pic"><div class="container" id="pic4">
<img src="../img/AC_events_init.png" width="290" height="277" alt="Инициализация блока в списке событий" />
<p id="light_pic4">Рис.&nbsp;459. Инициализация блока в списке событий</p>
</div></div>


<p>В первом параметре функции <span class="cpp"><a href="rdsRegisterMenuItem.htm" title="А.5.17.8. rdsRegisterMenuItem &ndash; создать пункт системного меню RDS">rdsRegisterMenuItem</a></span> передается текст добавляемого пункта меню
&ndash; в нашем случае, это &laquo;статистика&raquo;. Второй параметр содержит битовые флаги,
управляющие пунктом. У нас это объединение флага <span class="cpp">RDS_MENU_SHORTCUT</span>,
указывающего на то, что к пункту будет привязано сочетание клавиш, и флага
<span class="cpp">RDS_MENU_UNIQUECAPTION</span>, блокирующего добавление пункта, если другой пункт с
таким названием в меню уже есть. В третьем и четвертом параметрах передаются код и флаги
сочетания клавиш соответственно &ndash; у нас это клавиша &laquo;S&raquo; и объединение флагов
<span class="cpp"><a href="RDS_BFM_KEYDOWN.htm#light_ref9" title="RDS_KALT">RDS_KALT</a></span> и <span class="cpp"><a href="RDS_BFM_KEYDOWN.htm#light_ref10" title="RDS_KCTRL">RDS_KCTRL</a></span>, то есть сочетанием клавиш для нашего пункта будет
<span class="keys">Ctrl</span>+<span class="keys">Alt</span>+<span class="keys">S</span>.
Наконец, в двух последних параметрах передается пара целых чисел, по которым модель в реакции на
вызов пользовательского пункта меню сможет опознать этот пункт. Точно так же модель в предыдущем примере
опознавала пункты контекстного меню &ndash; реакция на выбор пункта контекстного и главного меню в
модели общая. В нашем случае мы передаем два нуля: наш блок имеет единственной пользовательский пункт
главного меню и не добавляет ничего в контекстное, поэтому в реакции на выбор пункта меню можно вообще
ничего не проверять: если модель реагирует на вызов какого-то созданного ей пункта, значит, это пункт
&laquo;<span class="menu">статистика</span>&raquo;.</p>

<p>Теперь можно добавить в модель реакцию на выбор пункта, точно так же, как мы делали это для
контекстного меню ранее. На вкладке
&laquo;<span class="menu">события</span>&raquo; в разделе
&laquo;<span class="menu">разное</span>&raquo; дважды щелкнем на подразделе
&laquo;<span class="menu">выбор пункта меню</span>&raquo;
(см. <a href="#pic1" title="Реакции на вызов меню и выбор пункта в списке событий">рис.&nbsp;456</a>)
и введем на открывшейся вкладке &laquo;<span class="menu">пункт меню</span>&raquo; следующий текст:</p>

<pre class="cpp">
  // У нас - единственный пункт меню
  double speed,msec; // Вспомогательные переменные
  char buffer[100];  // Буфер для сообщения пользователю

  <span id="ref12">if</span>(<span id="light_ref12"><a class="hidden" href="rdsCalcProcessIsRunning.htm" title="А.5.2.10. rdsCalcProcessIsRunning &ndash; RDS в режиме расчета">rdsCalcProcessIsRunning</a></span>()) // Расчет работает
    EndTick=GetTickCount(); // Текущее время
  else <span id="ref13">if</span>(<span id="light_ref13"><a class="hidden" href="rdsCalcProcessNeverStarted.htm" title="А.5.2.11. rdsCalcProcessNeverStarted &ndash; запускался ли расчет">rdsCalcProcessNeverStarted</a></span>())
    { <span id="ref14">//</span> Расчет остановлен и ни разу не запускался
      <span id="light_ref14"><a class="hidden" href="rdsMessageBox.htm" title="А.5.5.6. rdsMessageBox &ndash; вывод окна сообщения">rdsMessageBox</a></span>("Расчет еще не запускался","Статистика",
        MB_OK|MB_ICONWARNING);
      return;
    }

  // Расчет работает или остановлен, в EndTick – конечное время
  msec=EndTick-StartTick; // Прошло миллисекунд
  if(msec==0) // Невозможно вычислить скорость
    return;

  speed=Num/(msec/1000.0); // Скорость в тактах/сек

  // Формирование и вывод сообщения
  sprintf(buffer,"Скорость расчета: %d тактов/сек",(int)speed);
  rdsMessageBox(buffer,"Статистика",MB_OK|MB_ICONWARNING);</pre>

<p>Сначала мы вызываем функцию <span class="cpp"><a href="rdsCalcProcessIsRunning.htm" title="А.5.2.10. rdsCalcProcessIsRunning &ndash; RDS в режиме расчета">rdsCalcProcessIsRunning</a></span>,
чтобы узнать, работает ли сейчас расчет. Если он работает, мы записываем текущее время в переменную
<span class="cpp">EndTick</span>. В противном случае, то есть если расчет не работает, мы вызываем функцию
<span class="cpp"><a href="rdsCalcProcessNeverStarted.htm" title="А.5.2.11. rdsCalcProcessNeverStarted &ndash; запускался ли расчет">rdsCalcProcessNeverStarted</a></span>, чтобы
узнать, запускался ли расчет хотя бы один раз. Если расчет ни разу не запускался
(функция вернула <span class="cpp">TRUE</span>), мы не можем вычислить статистику, о чем функцией
<span class="cpp"><a href="rdsMessageBox.htm" title="А.5.5.6. rdsMessageBox &ndash; вывод окна сообщения">rdsMessageBox</a></span> выводится сообщение пользователю, и реакция завершается.
Если же расчет запускался, значит, он был остановлен, и в реакции на остановку в переменную
<span class="cpp">EndTick</span> уже было записано время конца расчета. Таким образом, в переменной
<span class="cpp">EndTick</span> будет записано либо текущее время, если расчет сейчас работает, либо
время остановки, если он был остановлен ранее. В обоих случаях мы можем вычислить скорость расчета.</p>

<p>Чтобы вычислить скорость, сначала мы определяем общее время расчета в миллисекундах &ndash; это разность между
<span class="cpp">EndTick</span> и <span class="cpp">StartTick</span>. Если эта разность равна нулю, мы
не можем вычислить скорость, и реакция завершается (впрочем, такая ситуация маловероятна: для этого
пользователь должен успеть вызвать пункт меню в той же миллисекунде, в которой запущен расчет). Далее мы
вычисляем скорость, разделив число выполненных тактов на время расчета, при помощи функции
<span class="cpp">sprintf</span> формируем текст сообщения и показываем его пользователю вызовом
<span class="cpp">rdsMessageBox</span>.</p>

<p>Теперь можно скомпилировать модель, и в главном меню появится новый пункт
&laquo;<span class="menu">система | дополнительно | статистика</span>&raquo;, рядом с которым будет указано вызывающее его
сочетание клавиш
(<a href="#pic5" title="Добавленный пункт главного меню">рис.&nbsp;460</a>).
Если запустить расчет и выбрать этот пункт или нажать
<span class="keys">Ctrl</span>+<span class="keys">Alt</span>+<span class="keys">S</span>, на экране должно
появиться сообщение с вычисленной скоростью расчета.</p>

<div class="pic"><div class="container" id="pic5">
<img src="../img/AC_systemmenuadd.png" width="582" height="344" alt="Добавленный пункт главного меню" />
<p id="light_pic5">Рис.&nbsp;460. Добавленный пункт главного меню</p>
</div></div>


<p>В этом примере мы добавляем пункт в главное меню, но не удаляем его: он будет удален автоматически
при отключении модели от блока (например, при удалении блока). Кроме того, при создании пункта мы
нигде не запомнили уникальный идентификатор, который возвращает функция
<span class="cpp">rdsRegisterMenuItem</span>. Если бы мы хотели как-то изменять пункт меню
(например, запрещать его, или включать возле него галочку), нужно было бы запомнить этот
идентификатор и передавать его в соответствующие функции RDS, описанные
в <a href="app_index.htm#light_htm:app_a_5_17" title="А.5.17. Системное меню и контекстное меню блока">А.5.17 приложений</a>. Этот идентификатор потребовался бы
и в том случае, если бы мы захотели удалить созданный пункт вручную.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_7_10.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_12_1.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_11">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
