<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.7.13.1. Общие принципы работы с функциями блока</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7_12">&sect;3.7.13. Вызов функций блоков</a></p>
<div class="level"><p>&sect;3.7.13.1. Общие принципы работы с функциями блока</p>
</div>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_7_11.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_12_2.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_12_1">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</h3>
<h4>&sect;3.7.13. Вызов функций блоков</h4>
<p class="abstract">Описывается добавление в модели блоков возможностей непосредственного вызова моделей других блоков и реакций на такие вызовы. Такие вызовы, называемые функциями блоков, позволяют блокам быстро передавать друг другу информацию любого типа без участия пользователя.</p>
<h5>&sect;3.7.13.1. Общие принципы работы с функциями блока</h5>
<p class="abstract">Рассматривается реализация вызовов функций блоков и реакций на их вызовы в модуле автокомпиляции. Описывается устройство автоматически создаваемых объектов, используемых в автокомпилируемых моделях для этих целей.</p>


<p>Модуль автокомпиляции облегчает разработчику реализацию в моделях блоков
<a href="um_1_6.htm#ref1" title="Коротко о функциях блоков">функций</a>, которые могут непосредственно вызываться другими блоками.
Каждой такой функции блока в RDS присваивается произвольное текстовое имя, по которому ее
опознают другие блоки. Эти блоки могут находиться в разных DLL, написанных на разных языках
программирования, поэтому всю передачу данных между ними берет на себя RDS. Чтобы добавить в модель
функцию блока (не важно &ndash; будет она вызываться у этого блока или, наоборот, этот блок будет
вызывать ее у других), необходимо добавить эту функцию на вкладку
&laquo;<span class="menu"><a href="um_3_6_5.htm" title="&sect;3.6.5. Функции блока">функции</a></span>&raquo;
левой панели редактора модели, указав для нее текстовое имя, тип ее параметра и имя внутреннего
объекта, который будет создан в модели для работы с ней. Для вызова функции у других блоков нужно будет
вызывать функции-члены этого объекта, передавая в них параметры функции и идентификаторы вызываемых блоков.
После того, как функция будет добавлена в модель, на вкладке
&laquo;<span class="menu"><a href="um_3_6_4.htm" title="&sect;3.6.4. Описания программы и реакции блока на события">события</a></span>&raquo; редактора появится новое событие
&ndash; вызов этой функции у данного блока. В реакции на это событие записываются все действия, которые
блок должен выполнить, если у него вызвана функция с таким именем.</p>

<p>Функции блоков создаются программистами их моделей, и пользователь не может как-то повлиять на их
работу. Как правило, все начинается с того, что создатель модели решает включить в свой блок не только
обработку данных на входах и выдачу результатов на выходы, но и возможность непосредственного выполнения команд
от других блоков &ndash; то есть добавляет в модель реакцию на вызов функции. Прежде всего необходимо
придумать для этой функции уникальное текстовое имя и набор данных, который будет передаваться при ее
вызове (у функции может быть только один параметр, поэтому обычно такие данные оформляют в виде структуры
и передают указатель на нее). Для обеспечения уникальности имени функции это имя обычно делают длинным и
каким-либо образом отражающим смысл выполняемых ей действий. Чтобы избежать возможных проблем с кодировкой строк,
в именах функций обычно используют только латинские буквы, цифры и знаки препинания, хотя в
RDS и нет жестких требований к этим именам. Общие рекомендации по выбору имен для новых функций даются
в <a href="pm_2_13_1.htm" title="&sect;2.13.1. Общие принципы вызова функций блоков">&sect;2.13.1 руководства программиста</a>, примеры имен стандартных функций приведены в
<a href="um_1_6.htm" title="&sect;1.6. Коротко о других способах взаимодействия блоков">&sect;1.6</a>.</p>

<p><span id="ref1">Придумав</span>
имя функции, необходимо решить, будут ли у нее <span id="light_ref1">параметры</span>, и если будут,
то какие именно. Формально у функции блока есть только один параметр типа <span class="cpp">void*</span>, то
есть &laquo;указатель на что-либо&raquo;. Если функции не нужны параметры, она просто игнорирует этот
указатель (при этом в нем чаще всего передают значение <span class="cpp">NULL</span>).
Если же параметры нужны, этот указатель обычно ссылается на какую-либо область памяти, содержащую
эти параметры. RDS передает указатель на область параметров от вызвавшей модели к вызванной без
каких-либо проверок, поэтому разработчику модели вызываемого блока следует самостоятельно проверять,
соответствуют ли переданные параметры вызванной функции. Такая проверка очень важна, поскольку модель
вызывающего блока может быть разработана другим программистом, и нельзя гарантировать того, что он
вызовет функцию, правильно передав ей параметры. Передача неправильных параметров может привести к
серьезным ошибкам. Допустим, например, что функция блока принимает один параметр типа
<span class="cpp">double</span>. Можно сделать параметром функции указатель на это число, при этом
реакция на вызов этой функции будет преобразовывать полученный указатель типа <span class="cpp">void*</span>
к типу <span class="cpp">double*</span> и обращаться через него к переданному числу. Однако, разработчик
вызывающей модели может по ошибке (или из-за недостаточно ясно написанного описания функции) передать в
нее не указатель на <span class="cpp">double</span>, а указатель на четырехбайтовое целое число
<span class="cpp">int</span>. RDS приведет этот указатель к типу
<span class="cpp">void*</span> и передаст его модели вызываемого блока. Эта модель, в свою очередь,
приведет этот указатель к типу <span class="cpp">double*</span> и попытается считать по нему вещественное
восьмибайтовое число. В лучшем случае она при этом считает неправильное значение, в худшем
&ndash; обращение к восьми байтам по адресу, по которому отведено только четыре, вызовет ошибку общей защиты
приложения (GPF).</p>

<p>Чтобы уменьшить вероятность возникновения подобных проблем, параметры функции, какими бы они ни
были, обычно оформляют в виде структуры, в первое поле которой записывают ее же размер. Например,
для функции, принимающей вещественное число <span class="cpp">double</span>, можно описать такую структуру
параметров:</p>

<pre class="cpp">  typedef struct
  { <a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> servSize; // Размер структуры параметров
    // ... параметры функции ...
    double Value;   // Передаваемое вещественное число
  } TMyFuncParam;</pre>

<p>При вызове функции в поле <span class="cpp">servSize</span> этой структуры нужно записать ее размер,
полученный стандартным оператором языка C <span class="cpp">sizeof</span>, а в поле
<span class="cpp">Value</span> &ndash; передаваемое при вызове функции вещественное значение:</p>

<pre class="cpp">  TMyFuncParam param;           // Структура параметров
  param.servSize=sizeof(param); // Размер структуры
  param.Value=12.34;            // Передаваемое число
  // При вызове функции в качестве параметра
  // будет передаваться &amp;param</pre>

<p>В реакции на вызов функции переданный указатель будет приводиться к типу <span class="cpp">TMyFuncParam*</span>
(&laquo;указатель на <span class="cpp">TMyFuncParam</span>&raquo;) &ndash; модуль автокомпиляции
вставляет операцию приведения типа автоматически. Вызванная модель при этом может сравнить значение поля
<span class="cpp">servSize</span> этой структуры с ее размером. Если значение поля не меньше размера структуры,
значит, передано достаточно данных для работы. В реакциях на вызов функции их параметр всегда имеет имя
<span class="cpp">Param</span>, поэтому текст реакции на вызов функции, вводимый пользователем, будет выглядеть
следующим образом:</p>

<pre class="cpp">  // Param имеет тип TMyFuncParam*
  if(Param!=NULL && Param-&gt;servSize&gt;=sizeof(TMyFuncParam))
    { // Можно выполнять функцию
      ...
    }</pre>

<p>Здесь не проверяется точное равенство значения поля (то есть размера структуры у вызвавшей модели)
размеру структуры у вызываемой, вместо этого проверяется <i>достаточность</i> размера переданной структуры.
Это делается для того, чтобы, если в будущем к структуре параметров функции будут добавлены дополнительные
поля для расширения ее возможностей, все ранее написанные модели, не пользующиеся этим новыми возможностями,
продолжили бы нормально работать. Если размер структуры, переданной в качестве параметра функции, окажется
больше ожидаемого, старая модель все равно может выполнить функцию, поскольку все нужные ей старые поля
в этой структуре присутствуют. Дополнительные поля в этом случае можно добавлять только в конец структуры,
не изменяя ту ее часть, с которой будут работать старые модели. При этом новая модель, выполняющая функцию,
должна по переданному размеру структуры определить, есть ли в структуре новые поля, и, если их нет, но
размер структуры достаточен для старой версии функции, выполнить ее. Например, можно написать реакцию
так:</p>

<pre class="cpp">  // Param имеет тип TMyFuncParam*
  if(Param!=NULL)
    { if(Param-&gt;servSize&gt;=sizeof(TMyFuncParam))
       { // Можно выполнять новую версию функции
           ...
       }
      else if(Param-&gt;servSize&gt;=<i>размер_для_старой_версии</i>)
       { // Можно выполнять старую версию функции
           ...
       }
    }</pre>

<p>Для того, чтобы вызвать функцию блока, необходимо знать ее имя, структуру ее параметров и идентификатор
блока, у которого она будет вызываться. Имя и структуру параметров обычно описывает разработчик,
придумавший эту функцию (описание структуры параметров часто выносят в отдельный файл заголовков).
Идентификатор блока, функция которого вызывается, нужно каким-либо образом получить у RDS. Чаще всего
используются следующие варианты:</p>

<ul>
  <li>одновременный вызов функции у всех блоков схемы;</li>
  <li>одновременный вызов функции у всех блоков
  <a href="um_1_2.htm#ref13" title="Родительская подсистема">родительской подсистемы</a>
  вызывающего блока (идентификатор этой подсистемы содержится в поле <span class="cpp">Parent</span> структуры
  данных блока, доступной по указателю <span class="cpp"><a href="um_3_7_1.htm#ref26" title="Указатель на структуру данных блока">rdsbcppBlockData</a></span>);</li>
  <li>вызов функции некоторого блока в ответ на вызов этим блоком функции данного блока (идентификатор вызвавшего
  функцию блока может быть считан из структуры <span class="cpp"><a href="RDS_BFM_FUNCTIONCALL.htm#ref1" title="Структура RDS_FUNCTIONCALLDATA">RDS_FUNCTIONCALLDATA</a></span>, указатель на которую
  доступен из реакции модели на вызов функции);</li>
  <li>вызов функции у блока, идентификатор которого получен путем анализа схемы при помощи сервисных функций
  RDS (например, можно перебрать все блоки,
  <a href="um_3_7_12_3.htm#ref3" title="Вызов функции у соединенных блоков">соединенные связями с данным</a>,
  и вызвать у них какую-либо функцию);</li>
  <li>вызов функции у блока, зарегистрировавшего себя в качестве
  <a href="um_3_7_12_4.htm" title="&sect;3.7.13.4. Регистрация и поиск исполнителя функции">исполнителя</a> этой функции.</li>
</ul>

<p>Можно получить идентификатор блока и другим способом (например, если известно
<a href="um_1_2.htm#ref19" title="Полное имя блока">полное имя блока</a>, можно получить его идентификатор при помощи функции
<span class="cpp"><a href="rdsBlockByFullName.htm" title="А.5.6.3. rdsBlockByFullName &ndash; блок по его полному имени">rdsBlockByFullName</a></span>), но перечисленные выше способы используются чаще всего.
В любом случае, вызов функции блока, как правило, используется для передачи этому блоку каких-либо
данных, и при этом, обычно, известно, какому именно блоку передаются данные. Если адресат данных неизвестен
(например, нужно выполнить какую-то команду, и не важно, кто именно ее выполнит), функцию вызывают сразу у
всех блоков схемы или у блока, который заявил RDS о том, что он выполняет данную функцию.</p>

<p>Для каждой добавленной в модель блока функции модуль автокомпиляции создает описание специального класса,
различные функции-члены которого отвечают за вызов функций блоков, поиск в схеме блоков-исполнителей функций
и т. п. Для работы с функцией модуль автоматически добавляет в программу объект такого класса. Например,
если для какой-либо функции, принимающей параметр типа <span class="cpp">TMyFuncParam*</span>
(&laquo;указатель на <span class="cpp">TMyFuncParam</span>&raquo;, эта структура описывалась
выше), был создан объект с именем <span class="cpp">MyFunc</span>, и необходимо вызвать эту функцию у всех
блоков родительской подсистемы вызывающего блока, этот вызов в модели будет записан так:</p>

<pre class="cpp">  TMyFuncParam param;            // Структура параметров
  param.servSize=sizeof(param);  // Размер структуры
  param.Value=12.34;             // Передаваемое число
  MyFunc.Broadcast(
    <a class="hidden" href="um_3_7_1.htm#ref26" title="Указатель на структуру данных блока">rdsbcppBlockData</a>-&gt;Parent,    // Родительская подсистема
    0,                           // Флаги вызова (нет)
    &amp;param);                     // Параметр функции</pre>

<p><span id="ref2">Перечислим</span>
коротко основные <span id="light_ref2">функции-члены класса</span> объектов, создаваемых для каждой функции:</p>

<dl>
  <dt><span class="cpp">int <span id="light_ref3">Id</span>(void)</span></dt>
  <dd>Уникальный целый идентификатор функции, присвоенный ей в RDS. Идентификатор функции может потребоваться
  в тех случаях, когда вызов функции производится не при помощи объекта, созданного модулем автокомпиляции, а
  напрямую, при помощи <a href="app_index.htm#light_htm:app_a_5_13" title="А.5.13. Вызов функций блоков">сервисных функций RDS</a>.
  Пример использования функции:<br />
  <pre class="cpp">  <a class="hidden" href="rdsBroadcastFuncCallsDelayed.htm" title="А.5.13.4. rdsBroadcastFuncCallsDelayed &ndash; отложенный вызов функции всех блоков подсистемы">rdsBroadcastFuncCallsDelayed</a>(   // Отложенный вызов
    <a class="hidden" href="um_3_7_1.htm#ref26" title="Указатель на структуру данных блока">rdsbcppBlockData</a>-&gt;Parent,     // Родительская подсистема
    MyFunc.Id(),                  // Идентификатор функции
    &amp;param,                       // Область параметров функции
    sizeof(param),                // Размер области
    0);                           // Флаги вызова (нет)</pre></dd>

  <dt><span class="cpp">int <span id="light_ref4">Call</span>(<a href="app_ids.htm#light_ref1" title="Идентификатор блока">RDS_BHANDLE</a> Block,<i>структура_параметров</i> *param)</span></dt>
  <dd>Вызов функции у блока с идентификатором <span class="cpp">Block</span>, если у функции есть параметр.
  В качестве параметра передается указатель <span class="cpp">param</span>, имеющий тип
  &laquo;указатель на данные типа <i>структура_параметров</i>&raquo;. Функция возвращает целое число,
  которое возвратила модель блока, среагировавшего на вызов функции. Пример использования функции:<br />
  <pre class="cpp">  // Вызов функции у своего собственного блока
  MyFunc.Call(               // Вызов
    <a class="hidden" href="um_3_7_1.htm#ref26" title="Указатель на структуру данных блока">rdsbcppBlockData</a>-&gt;Block, // Этот блок
    &amp;param);                 // Область параметров функции</pre></dd>

  <dt><span class="cpp">int <span id="light_ref5">Call</span>(<a href="app_ids.htm#light_ref1" title="Идентификатор блока">RDS_BHANDLE</a> Block)</span></dt>
  <dd>Вызов функции у блока с идентификатором <span class="cpp">Block</span>, если у функции нет параметра
  (вместо указателя на параметр в модель вызываемого блока передается <span class="cpp">NULL</span>). Используется
  точно так же, как и предыдущая функция.
  <a href="um_3_7_12_3.htm#ref6" title="Вызов функции блока без параметров">Пример</a> использования этой функции-члена приведен в
  <a href="um_3_7_12_3.htm" title="&sect;3.7.13.3. Вызов функции у одного блока">&sect;3.7.13.3</a>.</dd>

  <dt><span class="cpp">int <span id="light_ref6">Call</span>(<i>структура_параметров</i> *param)</span></dt>
  <dd>Вызов функции у блока, зарегистрированного как исполнитель данной функции, если у функции есть параметр.
  От двух предыдущих версий функции-члена <span class="cpp">Call</span> эта версия отличается тем, что в ней не
  указывается идентификатор вызываемого блока &ndash; RDS определяет его самостоятельно, находя блок,
  объявивший себя исполнителем этой функции. В качестве параметра передается указатель <span class="cpp">param</span>,
  имеющий тип &laquo;указатель на данные типа <i>структура_параметров</i>&raquo;. Функция возвращает целое
  число, которое возвратила модель блока, среагировавшего на вызов функции. Эту функцию-член можно вызывать
  <span class="emph">только из модели блока</span>, то есть из реакций блока на различные события и из функций,
  объявленных членами класса блока. Пример использования этой функции-члена приведен в
  <a href="um_3_7_12_4.htm" title="&sect;3.7.13.4. Регистрация и поиск исполнителя функции">&sect;3.7.13.4</a>.</dd>

  <dt><span class="cpp">int <span id="light_ref7">Call</span>(void)</span></dt>
  <dd>Вызов функции у блока, зарегистрированного как исполнитель данной функции, если у функции нет параметра
  (вместо указателя на параметр в модель вызываемого блока передается <span class="cpp">NULL</span>). Для этой
  функции-члена справедливы те же ограничения в использовании, что и для предыдущей &ndash; ее нельзя использовать
  вне модели блока, то есть в функциях из глобальных описаний (не являющихся членами класса блока).</dd>

  <dt><span class="cpp">int <span id="light_ref8">Broadcast</span>(<a href="app_ids.htm#light_ref1" title="Идентификатор блока">RDS_BHANDLE</a> Sys,<a href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> Flags,<i>структура_параметров</i> *param)</span></dt>
  <dd>Вызов функции у всех блоков подсистемы <span class="cpp">Sys</span>, если у функции есть параметр. В качестве
  параметра передается указатель <span class="cpp">param</span>, имеющий тип
  &laquo;указатель на данные типа <i>структура_параметров</i>&raquo;. <span class="cpp">Flags</span> &ndash;
  <a href="rdsBroadcastFuncCallsDelayed.htm#ref1" title="Флаги вызова функции блока">флаги</a>, управляющие вызовом функций. Функция возвращает общее
  число блоков, модели которых были вызваны. Пример использования функции:<br />
  <pre class="cpp">  // Вызов функции у всех блоков в родительской подсистеме
  MyFunc.Broadcast(           // Вызов у блоков подсистемы
    <a class="hidden" href="um_3_7_1.htm#ref26" title="Указатель на структуру данных блока">rdsbcppBlockData</a>-&gt;Parent, // Родительская подсистема
    0,                        // Флаги вызова (нет)
    &amp;param);                  // Область параметров функции</pre></dd>

  <dt><span class="cpp">int <span id="light_ref9">Broadcast</span>(<a href="app_ids.htm#light_ref1" title="Идентификатор блока">RDS_BHANDLE</a> Sys,<a href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> Flags)</span></dt>
  <dd>Вызов функции у всех блоков подсистемы <span class="cpp">Sys</span>, если у функции нет параметра
  (вместо указателя на параметр в модель вызываемого блока передается <span class="cpp">NULL</span>). Используется
  точно так же, как и предыдущая функция.</dd>

  <dt><span class="cpp">void <span id="light_ref10">RegisterProvider</span>(void)</span></dt>
  <dd>Зарегистрировать данный блок в RDS в качестве
  <a href="um_3_7_12_4.htm" title="&sect;3.7.13.4. Регистрация и поиск исполнителя функции">исполнителя функции</a>. Обычно такая регистрация
  делается автоматически при добавлении функции в редактор модели при помощи флажка
  &laquo;<span class="menu">объявить блок исполнителем функции</span>&raquo; на панели
  &laquo;<span class="menu">дополнительные действия</span>&raquo; окна параметров функции
  (см. <a href="um_3_6_5.htm#pic2" title="Окно параметров функции блока">рис.&nbsp;339</a>), поэтому в вызове
  <span class="cpp">RegisterProvider</span> нет необходимости. Этот вызов нужен только в том случае,
  если регистрация блока производится вручную &ndash; например, если разработчик хочет разрешать или
  запрещать ее в настройках блока. Вызывать <span class="cpp">RegisterProvider</span> можно
  <span class="emph">только из модели блока</span>, то есть из реакций на события и из функций,
  объявленных членами класса блока.</dd>

  <dt><span class="cpp">void <span id="light_ref11">UnregisterProvider</span>(void)</span></dt>
  <dd>Отменить регистрацию блока в качестве исполнителя функции. Эта функция-член нужна только при
  ручной регистрации блока вызовом <span class="cpp">RegisterProvider</span>. Если блок зарегистрирован установкой
  флажка при добавлении функции в редактор модели, при удалении блока регистрация будет отменена автоматически.</dd>

  <dt><span class="cpp">void <span id="light_ref12">SubscribeToProvider</span>(void)</span></dt>
  <dd>Найти и запомнить блок, объявивший себя исполнителем этой функции. После такого поиска для вызова
  функции можно пользоваться
  <a href="#light_ref6" title="Функция Call класса функции блока (у исполнителя)">версией функции-члена <span class="cpp">Call</span></a>,
  в которую не передается идентификатор вызываемого блока. При изменении блока-исполнителя (например, при
  его стирании и появлении нового) запомненная информация будет обновляться автоматически. Для поиска исполнителя
  достаточно установить флажок &laquo;<span class="menu">найти в схеме исполнителя функции</span>&raquo; на панели
  &laquo;<span class="menu">дополнительные действия</span>&raquo; окна параметров функции
  (см. <a href="um_3_6_5.htm#pic2" title="Окно параметров функции блока">рис.&nbsp;339</a>), поэтому в ручном вызове
  <span class="cpp">SubscribeToProvider</span> обычно нет необходимости. Вызывать эту функцию-член можно
  <span class="emph">только из модели блока</span>, то есть из реакций на события и из функций, объявленных
  членами класса блока.</dd>

  <dt><span class="cpp">void <span id="light_ref13">UnsubscribeFromProvider</span>(void)</span></dt>
  <dd>Прекратить слежение за блоками-исполнителями данной функции. Как правило, в ручном вызове этой функции нет
  необходимости. Как и предыдущую, эту функцию-член можно вызывать только непосредственно из модели блока.</dd>

  <dt><span class="cpp"><a href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> <span id="light_ref14">Subscribed</span>(void)</span></dt>
  <dd>Успешность поиска исполнителя функции (<span class="cpp">TRUE</span>, если исполнитель функции существует в
  схеме, <span class="cpp">FALSE</span> в противном случае). Вызывается только непосредственно из модели блока.</dd>

  <dt><span class="cpp"><a href="app_ids.htm#light_ref1" title="Идентификатор блока">RDS_BHANDLE</a> <span id="light_ref15">Provider</span>(void)</span></dt>
  <dd>Получить идентификатор найденного блока-исполнителя (если его нет, возвращается <span class="cpp">NULL</span>).
  Изнутри модели блока вызвать функцию у исполнителя можно и не получая в явном виде его идентификатор &ndash;
  для этого достаточно использовать
  <a href="#light_ref6" title="Функция Call класса функции блока (у исполнителя)">вариант функции-члена <span class="cpp">Call</span></a>, в который не
  передается идентификатор блока. Однако, если вызов функции блока производится не непосредственно из какой-либо
  реакции модели (то есть не из функции-члена класса блока), этот вариант <span class="cpp">Call</span> будет
  недоступен, и нужно будет пользоваться
  <a href="#light_ref4" title="Функция Call класса функции блока">другим вариантом</a> этой функции, в котором первым параметром будет
  идентификатор вызываемого блока. Для этого нужно будет как-то передать в то место программы, которое
  будет вызывать функцию, результат возврата <span class="cpp">Provider</span>. Эта функция тоже вызывается только
  непосредственно из модели блока (т. е. из реакций на события и из функций, объявленных членами класса блока),
  поэтому снаружи модели получить идентификатор блока-исполнителя из самого объекта функции невозможно.</dd>

  <dt><span class="cpp"><a href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> <span id="light_ref16">IsProvider</span>(void)</span></dt>
  <dd>Возвращает <span class="cpp">TRUE</span>, если данный блок зарегистрирован как исполнитель функции, и
  <span class="cpp">FALSE</span> в противном случае. Вызывается только непосредственно из модели блока.</dd>

</dl>

<p class="noindent">Примеры различных способов вызова функций при помощи объектов, создаваемых модулем
автокомпиляции, будут рассмотрены далее. Следует учитывать, что эти объекты поддерживают только прямой,
то есть немедленный, вызов функций блоков &ndash; отложенный вызов, если это потребуется, необходимо
выполнять при помощи <a href="app_index.htm#light_htm:app_a_5_13" title="А.5.13. Вызов функций блоков">сервисных функций RDS</a> (назначение и
особенности отложенного вызова функций блоков рассматриваются в
<a href="pm_2_13_5.htm" title="&sect;2.13.5. Отложенный вызов функций блоков">&sect;2.13.5 руководства программиста</a>).</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_7_11.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_12_2.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_12_1">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
