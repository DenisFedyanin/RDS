<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.7.13.2. Вызов функции у всех блоков подсистемы</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7_12">&sect;3.7.13. Вызов функций блоков</a></p>
<div class="level"><p>&sect;3.7.13.2. Вызов функции у всех блоков подсистемы</p>
</div>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_7_12_1.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_12_3.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_12_2">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</h3>
<h4 class="off">&sect;3.7.13. Вызов функций блоков</h4>
<h5>&sect;3.7.13.2. Вызов функции у всех блоков подсистемы</h5>
<p class="abstract">Рассматривается способ вызова заданной функции у всех блоков какой-либо подсистемы и, при необходимости, у блоков всех подсистем, вложенных в нее.</p>


<p>В <a href="um_3_7_10.htm" title="&sect;3.7.11. Реакция блока на мышь">&sect;3.7.11</a>
мы создали модель блока, который по
<a href="um_3_7_10.htm#ref13" title="Реакция на щелчки мыши на картинке блока">щелчкам мыши на элементах</a> своей картинки
увеличивал, уменьшал или сбрасывал в ноль значение своего выхода. Сделаем так, чтобы одним щелчком мыши
можно было увеличить, уменьшить или сбросить выходы всех таких блоков в подсистеме. Проще всего сделать
это при помощи вызова функций блоков: мы добавим в подсистему новый управляющий блок, который,
при щелчках мыши на нем, будет вызывать у всех блоков в одной с ним подсистеме функции для увеличения,
уменьшения или сброса выхода. В наш старый блок мы добавим реакции на вызов таких функций, в которых выход блока
будет изменяться согласно вызванной функции. Модели всех остальных блоков в подсистеме, включая, например,
стандартные индикаторы, не будут иметь реакций на вызов наших функций, и, поэтому, будут просто игнорировать
их. Это стандартная практика в RDS: если модель блока не рассчитана на выполнение какой-либо функции,
она немедленно завершается, не выполняя никаких действий. Таким образом, вызов у блока функции, которую он не
поддерживает, не приводит к каким-либо неприятным последствиям.</p>

<p>Решить нашу задачу с использованием функций блоков можно двумя путями. Во-первых, можно создать три
разных функции: одну для уменьшения, другую для увеличения, третью для сброса выхода. В этом случае у
функций не будет параметров, сам факт их вызова будет говорить блоку, что именно нужно сделать с его выходом.
Во-вторых, можно, вместо трех, создать единственную функцию с параметром, в котором будет содержаться команда
на увеличение, уменьшение или сброс выхода. Первый путь проще, поэтому, сначала мы пойдем по нему.</p>

<p>Сначала нужно придумать уникальные имена для наших функций. Создаваемая модель является частью описания
пользователя, поэтому включим в имена функций текст &laquo;UserManual&raquo;
(&laquo;описание пользователя&raquo;). Функции эти будут выполняться блоками, которые в
<a href="um_3_7_10.htm" title="&sect;3.7.11. Реакция блока на мышь">&sect;3.7.11</a> иллюстрировали щелчки мыши на картинке, поэтому добавим в имена
функций текст &laquo;PictureClick&raquo;
(&laquo;щелчок на картинке&raquo;). И, наконец, функции будут отвечать за увеличение, уменьшение и сброс
выхода блока, поэтому их имена будут содержать &laquo;Inc&raquo;,
&laquo;Dec&raquo; и &laquo;Reset&raquo; (сокращения от
&laquo;увеличить&raquo;, &laquo;уменьшить&raquo; и
&laquo;сбросить&raquo;). Перечислим все эти слова через точки, и получим имена для наших
новых функций:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя функции</th>
    <th>Параметр</th>
    <th>Назначение</th>
  </tr>

  <tr>
    <td>UserManual.PictureClick.Inc</td>
    <td class="center">нет</td>
    <td>увеличение выхода</td>
  </tr>
  <tr>
    <td>UserManual.PictureClick.Dec</td>
    <td class="center">нет</td>
    <td>уменьшение выхода</td>
  </tr>
  <tr>
    <td>UserManual.PictureClick.Reset</td>
    <td class="center">нет</td>
    <td>сброс выхода</td>
  </tr>

</table>
</div></div>

<p class="noindent">Мы уже решили, что в первом варианте моделей у функций параметров не будет.</p>

<div class="picright"><div class="container" id="pic1">
<img src="../img/AC_PictureClick_Cntrlr.png" width="119" height="48" alt="Картинка управляющего блока" />
<p id="light_pic1">Рис.&nbsp;461. Картинка<br />управляющего блока</p>
</div></div>


<p>Начнем с создания управляющего блока, который будет вызывать функции у всех блоков своей подсистемы.
<a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">Создадим</a> в схеме новый блок с автокомпилируемой моделью
и зададим для него векторную картинку, похожую на
<a href="um_3_7_10.htm#ref14" title="Картинка блока, распознающего щелчки мыши">картинку нашего старого блока</a>. Чтобы не путать эти
блоки, заменим в картинке простой белый прямоугольник на прямоугольник со скругленными углами, а
квадраты заменим кругами
(<a href="#pic1" title="Картинка управляющего блока">рис.&nbsp;461</a>, редактор векторной картинки блока и работа с ним
описывается в <a href="um_index.htm#light_htm:um_2_10" title="&sect;2.10. Редактирование векторной картинки блока">&sect;2.10</a>).
Идентификаторы кругов сделаем такими же,
какие <a href="um_3_7_10.htm#pic5" title="Идентификатор одного из элементов в редакторе картинки">были у квадратов</a>: красному (левому) кругу дадим
идентификатор 1, зеленому (правому)
&ndash; 2, а белому (центральному) &ndash; 3. Чтобы модель блока отзывалась на щелчки мыши,
разрешим в окне параметров блока
<a href="um_3_7_10.htm#pic2" title="Разрешение реакции на мышь в окне параметров блока">реакцию на мышь</a>.</p>

<p>Теперь нужно добавить в модель три придуманных нами функции блока. Откроем редактор модели и выберем на его
левой панели вкладку
&laquo;<span class="menu"><a href="um_3_6_5.htm" title="&sect;3.6.5. Функции блока">функции</a></span>&raquo; &ndash; она пока пуста. Добавим новую функцию:
нажмем в нижней части панели кнопку &laquo;<span class="menu">+</span>&raquo; и заполним открывшееся окно описанием функции
&laquo;UserManual.PictureClick.Inc&raquo;
(<a href="#pic2" title="Добавление функции UserManual.PictureClick.Inc в модель блока">рис.&nbsp;462</a>).</p>

<div class="pic"><div class="container" id="pic2">
<img src="../img/AC_PictureClick_FuncWin.png" width="567" height="411" alt="Добавление функции UserManual.PictureClick.Inc в модель блока" />
<p id="light_pic2">Рис.&nbsp;462. Добавление функции &laquo;UserManual.PictureClick.Inc&raquo; в модель блока</p>
</div></div>


<p>В верхней панели окна включим флажок &laquo;<span class="menu">произвольная функция</span>&raquo;: мы добавляем функцию,
которую придумали сами, она не относится к стандартным. В поле
&laquo;<span class="menu">имя функции в RDS</span>&raquo; введем &laquo;UserManual.PictureClick.Inc&raquo; &ndash;
это имя нашей функции. После того, как мы выйдем из этого поля, поля
&laquo;<span class="menu">объект для функции в программе</span>&raquo; и
&laquo;<span class="menu">имя функции реакции в классе блока</span>&raquo; заполнятся автоматически &ndash; они станут похожими на
введенное имя функции, и при этом такими, чтобы удовлетворять правилам синтаксиса языка C. В поле
&laquo;<span class="menu">объект для функции</span>&raquo; появится
&laquo;rdsfuncUserManual_PictureClick_Inc&raquo;, в поле
&laquo;<span class="menu">имя функции реакции</span>&raquo; &ndash; &laquo;rdsfuncUserManual_PictureClick_IncEvent&raquo;.
Чтобы вызывать эту функцию из модели блока, нам придется обращаться к созданному для функции объекту по
его имени, и длинное имя, предлагаемое для объекта по умолчанию, использовать не очень удобно. Поскольку это
имя будет использоваться только внутри нашей модели, мы можем изменить его как угодно &ndash; главное, чтобы
оно не совпало с именем какой-либо другой переменной в программе. Исправим его на
&laquo;rdsfuncUMPC_Inc&raquo;, так будет гораздо короче. При этом имя функции реакции тоже изменится
(оно преобразуется в &laquo;rdsfuncUMPC_IncEvent&raquo;), но нам это не важно: с именем функции реакции
мы напрямую не работаем, модуль автокомпиляции самостоятельно добавляет ее вызов там, где необходимо.</p>

<p>Параметра у нашей функции нет, поэтому поле &laquo;<span class="menu">тип параметра функции (указатель)</span>&raquo; мы
оставляем пустым. В нижней части окна на панели
&laquo;<span class="menu">дополнительные действия</span>&raquo; мы оставляем включенный по умолчанию флажок
&laquo;<span class="menu">никаких дополнительных действий</span>&raquo; &ndash; мы не собираемся регистрировать наш блок в
RDS в качестве выделенного исполнителя этой функции или искать такого исполнителя
(см. <a href="um_3_7_12_4.htm" title="&sect;3.7.13.4. Регистрация и поиск исполнителя функции">&sect;3.7.13.4</a>). Нажмем кнопку
&laquo;<span class="menu">OK</span>&raquo;, чтобы функция добавилась в редактор модели &ndash; она появится в списке на вкладке
&laquo;<span class="menu">функции</span>&raquo;.</p>

<p>Точно так же добавим в модель функции &laquo;UserManual.PictureClick.Dec&raquo; и
&laquo;UserManual.PictureClick.Reset&raquo;, изменяя предлагаемые по умолчанию имена их объектов на
&laquo;rdsfuncUMPC_Dec&raquo; и
&laquo;rdsfuncUMPC_Reset&raquo; соответственно. Если все сделано правильно, список на вкладке
&laquo;<span class="menu">функции</span>&raquo; примет вид, изображенный
на <a href="#pic3" title="Вкладка функции редактора модели после добавления функций (размеры панели и колонок увеличены для наглядности)">рис.&nbsp;463</a>:
в колонке &laquo;<span class="menu">имя C++</span>&raquo; будут содержаться имена объектов, созданных для функций, в колонке
&laquo;<span class="menu">имя в RDS</span>&raquo; &ndash; имена функций, колонка &laquo;<span class="menu">параметр</span>&raquo; будет пустой.
Все иконки в левой колонке будут пустыми белыми листами, поскольку в нашем блоке нет реакций на вызов
этих функций. Их и не будет: управляющий блок, который мы создаем, будет только вызывать эти функции у
других блоков.</p>

<div class="pic"><div class="container" id="pic3">
<img src="../img/AC_PictureClick_FuncPanel.png" width="496" height="178" alt="Вкладка функции редактора модели после добавления функций (размеры панели и колонок увеличены для наглядности)" />
<p id="light_pic3">Рис.&nbsp;463. Вкладка &laquo;<span class="menu">функции</span>&raquo; редактора модели после добавления функций<br />(размеры панели и колонок увеличены для наглядности)</p>
</div></div>


<p>Теперь нужно добавить в модель блока реакцию на нажатие кнопки мыши: в зависимости от того, на каком из
цветных кругов картинки блока щелкнет пользователь, блок должен будет вызвать ту или иную функцию у всех блоков
в одной с ним подсистеме. Как и в модели блока, которым мы собираемся управлять, в реакции на нажатие кнопки
мыши мы будем запрашивать у RDS идентификатор элемента векторной картинки под курсором. Разным цветным
кругам мы присвоили разные идентификаторы, и это позволит нам понять,
где пользователь щелкнул мышью.</p>

<p>На вкладке &laquo;<span class="menu">события</span>&raquo; левой панели окна редактора модели раскроем раздел
&laquo;<span class="menu">мышь и клавиатура</span>&raquo;
(см. <a href="um_3_7_10.htm#pic1" title="Реакции на мышь в списке событий">рис.&nbsp;447</a>),
дважды щелкнем на подразделе &laquo;<span class="menu">нажатие кнопки мыши</span>&raquo; и на появившейся справа одноименной
вкладке введем следующий текст:</p>

<pre class="cpp">  if(<a class="hidden" href="um_3_7_10.htm#ref1" title="Параметр MouseData">MouseData</a>-&gt;Button==<a class="hidden" href="RDS_BFM_MOUSEDBLCLICK.htm#light_ref4" title="RDS_MLEFTBUTTON">RDS_MLEFTBUTTON</a>) // Нажата левая
    { switch(<a class="hidden" href="rdsGetMouseObjectId.htm" title="А.5.6.31. rdsGetMouseObjectId &ndash; элемент векторной картинки блока под курсором мыши">rdsGetMouseObjectId</a>(<a class="hidden" href="um_3_7_10.htm#ref1" title="Параметр MouseData">MouseData</a>)) // Идентификатор
        { case 1: // Красный круг
            rdsfuncUMPC_Dec.<a class="hidden" href="um_3_7_12_1.htm#light_ref9" title="Функция Broadcast класса функции блока (без параметра)">Broadcast</a>(<a class="hidden" href="um_3_7_1.htm#ref26" title="Указатель на структуру данных блока">rdsbcppBlockData</a>-&gt;Parent,0);
            break;
          case 2: // Зеленый круг
            rdsfuncUMPC_Inc.<a class="hidden" href="um_3_7_12_1.htm#light_ref9" title="Функция Broadcast класса функции блока (без параметра)">Broadcast</a>(<a class="hidden" href="um_3_7_1.htm#ref26" title="Указатель на структуру данных блока">rdsbcppBlockData</a>-&gt;Parent,0);
            break;
          case 3: // Белый круг
            rdsfuncUMPC_Reset.<a class="hidden" href="um_3_7_12_1.htm#light_ref9" title="Функция Broadcast класса функции блока (без параметра)">Broadcast</a>(<a class="hidden" href="um_3_7_1.htm#ref26" title="Указатель на структуру данных блока">rdsbcppBlockData</a>-&gt;Parent,0);
            break;
        }
    }
  else // Нажата не левая
    Result=<a class="hidden" href="RDS_BFM_MOUSEDOWN.htm#light_ref2" title="RDS_BFR_SHOWMENU">RDS_BFR_SHOWMENU</a>; // Разрешаем контекстное меню</pre>

<p>Если нажата левая кнопка мыши, поле <span class="cpp">Button</span>
<a href="RDS_BFM_MOUSEDBLCLICK.htm#ref2" title="Структура RDS_MOUSEDATA">структуры описания события</a>, указатель
<span class="cpp"><a href="um_3_7_10.htm#ref1" title="Параметр MouseData">MouseData</a></span> на которую передается в функцию реакции,
будет содержать константу <span class="cpp"><a href="RDS_BFM_MOUSEDBLCLICK.htm#light_ref4" title="RDS_MLEFTBUTTON">RDS_MLEFTBUTTON</a></span>. В этом случае мы запрашиваем у
RDS идентификатор элемента картинки под курсором мыши при помощи функции
<span class="cpp"><a href="rdsGetMouseObjectId.htm" title="А.5.6.31. rdsGetMouseObjectId &ndash; элемент векторной картинки блока под курсором мыши">rdsGetMouseObjectId</a></span>, которая вернет идентификатор, присвоенный нами элементу в
редакторе векторной картинки. В зависимости от его значения, мы вызовем функцию, соответствующую объектам
<span class="cpp">rdsfuncUMPC_Dec</span>, <span class="cpp">rdsfuncUMPC_Inc</span> или
<span class="cpp">rdsfuncUMPC_Reset</span>, для всех блоков
<a href="um_1_2.htm#ref13" title="Родительская подсистема">родительской подсистемы</a>
нашего блока.</p>

<p>Для вызова функции всех блоков какой-либо подсистемы через созданный для этой функции объект
используется функция-член этого объекта
<span class="cpp"><a href="um_3_7_12_1.htm#light_ref8" title="Функция Broadcast класса функции блока">Broadcast</a></span>, принимающая два или три параметра.
Если, как в нашем случае, у функции блока, для которой создан объект, нет параметра, в
<span class="cpp">Broadcast</span> передается идентификатор подсистемы и флаги вызова функции. Если бы
у наших функций был параметр, он стал бы третьим параметром функции <span class="cpp">Broadcast</span>. В общем
виде вызов функции у всех блоков подсистемы выглядит так:</p>

<pre class="cpp">  <i>имя_объекта_функции</i>.<a class="hidden" href="um_3_7_12_1.htm#light_ref8" title="Функция Broadcast класса функции блока">Broadcast</a>(
    <i>идентификатор_подсистемы</i>,
    <i>битовые_флаги_вызова</i>,
    <i>параметр_функции</i>);	// Отсутствует для функций без параметра</pre>

<p>В качестве идентификатора подсистемы мы во всех трех случаях передаем идентификатор родительской
подсистемы нашего блока. Мы берем его из поля <span class="cpp">Parent</span>
<a href="RDS_BLOCKDATA.htm#ref3" title="Структура RDS_BLOCKDATA">структуры данных блока</a>, доступной в модели по указателю
<span class="cpp"><a href="um_3_7_1.htm#ref26" title="Указатель на структуру данных блока">rdsbcppBlockData</a></span>.
<a href="rdsBroadcastFuncCallsDelayed.htm#ref1" title="Флаги вызова функции блока">Битовые флаги</a> управляют вызовом функции у блоков. Мы передаем вместо
них ноль &ndash; это значит, что функция будет вызвана у всех блоков указанной подсистемы независимо от
их действий. Указание флага <span class="cpp"><a href="rdsBroadcastFuncCallsDelayed.htm#light_ref4" title="RDS_BCALL_SUBSYSTEMS">RDS_BCALL_SUBSYSTEMS</a></span> привело бы к тому, что функция была
бы вызвана и у всех блоков всех подсистем, вложенных в указанную, а указание флага
<span class="cpp"><a href="rdsBroadcastFuncCallsDelayed.htm#light_ref2" title="RDS_BCALL_ALLOWSTOP">RDS_BCALL_ALLOWSTOP</a></span> позволило бы какому-нибудь из блоков прекратить все дальнейшие вызовы.
Нам это не нужно, поэтому флагов мы не указываем. Параметра у наших функций нет, третий параметр во всех трех
вызовах <span class="cpp">Broadcast</span> отсутствует.</p>

<p>Если была нажата не левая кнопка мыши (то есть поле <span class="cpp">MouseData-&gt;Button</span> не равно
<span class="cpp">RDS_MLEFTBUTTON</span>), мы присваиваем переменной <span class="cpp">Result</span> значение
<span class="cpp"><a href="RDS_BFM_MOUSEDOWN.htm#light_ref2" title="RDS_BFR_SHOWMENU">RDS_BFR_SHOWMENU</a></span>, чтобы не блокировать вывод контекстного меню по правой кнопке мыши.</p>

<p>Модель управляющего блока готова &ndash; теперь в режимах
<a href="um_1_3.htm#ref2" title="Режим моделирования">моделирования</a>
и <a href="um_1_3.htm#ref3" title="Режим расчета">расчета</a>
по щелчкам мыши он будет вызывать одну из трех созданных нами функций у блоков своей подсистемы.
Только никто пока не будет отзываться на эти функции. Добавим в ранее созданную модель блока, которым
мы собираемся управлять (см. <a href="um_3_7_10.htm" title="&sect;3.7.11. Реакция блока на мышь">&sect;3.7.11</a>), реакцию на них.</p>

<p>Откроем редактор модели управляемого блока и добавим в него три наших функции &ndash; точно так же,
как мы делали для управляющего. Крайне важно не ошибиться в именах функций, они должны в точности
совпадать с именами, которые мы использовали для управляющего блока. Если они будут отличаться хотя бы
регистром символов, с точки зрения RDS это будут разные функции, и управляемый блок не
будет реагировать на вызов, сделанный управляющим. Объекты, создаваемые для функций в управляемом блоке,
можно не переименовывать: хотя у них и будут длинные, неудобные в использовании имена, в модели управляемого
блока мы не будем обращаться к этим объектам. Здесь мы только реагируем на вызов функций, а не вызываем их &ndash;
следовательно, имя объекта, через который вызывается функция, для нас не важно.</p>

<p>После добавления всех трех функций вкладка &laquo;<span class="menu">функции</span>&raquo; левой панели редактора будет выглядеть
примерно так же, как и у управляющего блока
(см. <a href="#pic3" title="Вкладка функции редактора модели после добавления функций (размеры панели и колонок увеличены для наглядности)">рис.&nbsp;463</a>). Нам нужно добавить в модель
реакции на вызов каждой из этих функций. Реакцию на вызов функции можно добавить как с вкладки
&laquo;<span class="menu">функции</span>&raquo;, так и, как обычно, с вкладки &laquo;<span class="menu">события</span>&raquo;. На вкладке
&laquo;<span class="menu">функции</span>&raquo; можно выбрать функцию в списке и нажать кнопку с листком в левой нижней части
вкладки. На вкладке &laquo;<span class="menu">события</span>&raquo; нужно раскрыть группу
&laquo;<span class="menu">функции блока</span>&raquo; и дважды щелкнуть на ее подразделе с именем нужной функции
(<a href="#pic4" title="События реакций на вызовы функций">рис.&nbsp;464</a>).</p>

<div class="pic"><div class="container" id="pic4">
<img src="../img/AC_PictureClick_FuncEvents.png" width="333" height="291" alt="События реакций на вызовы функций" />
<p id="light_pic4">Рис.&nbsp;464. События реакций на вызовы функций</p>
</div></div>


<p>Сначала любым из этих способов добавим реакцию на вызов функции блока
&laquo;UserManual.PictureClick.Inc&raquo; &ndash; реагируя на нее, блок должен увеличить свой выход
на единицу. На открывшейся пустой вкладке с названием этой функции нужно ввести следующий текст:</p>

<pre class="cpp">  y++; // Увеличиваем выход
  // Взводим сигнал готовности для передачи выхода по связям
  <a class="hidden" href="um_1_4.htm#ref27" title="Сигнал готовности блока">Ready</a>=1;</pre>

<p>Реакция содержит всего два оператора: первый увеличивает выход <span class="cpp">y</span> на единицу, второй
&ndash; взводит сигнал готовности блока
<span class="cpp"><a href="um_1_4.htm#ref27" title="Сигнал готовности блока">Ready</a></span>, чтобы по окончании очередного
<a href="um_1_3.htm#ref4" title="Такт расчета">такта расчета</a> новое значение выхода передалось по связям в соединенные с
ним блоки. Сигнал готовности блока взводится автоматически только при вызове модели этого
блока в такте расчета, вызов функции блока не взводит его, поэтому нам, как и в реакции на щелчок мыши в
этом же блоке, нужно сделать это вручную.</p>

<p>Реакция на вызов функции &laquo;UserManual.PictureClick.Dec&raquo;, в которой блок должен уменьшать выход,
будет аналогичной:</p>

<pre class="cpp">  y--; // Уменьшаем выход
  // Взводим сигнал готовности для передачи выхода по связям
  <a class="hidden" href="um_1_4.htm#ref27" title="Сигнал готовности блока">Ready</a>=1;</pre>

<p>Реакция на функцию сброса выхода &laquo;UserManual.PictureClick.Reset&raquo; тоже будет похожей:</p>

<pre class="cpp">  y=0; // Сбрасываем выход
  // Взводим сигнал готовности для передачи выхода по связям
  <a class="hidden" href="um_1_4.htm#ref27" title="Сигнал готовности блока">Ready</a>=1;</pre>

<div class="picright"><div class="container" id="pic5">
<img src="../img/AC_PictureClick_FuncTest.png" width="338" height="98" alt="Управляющий (справа) и управляемые (слева) блоки" />
<p id="light_pic5">Рис.&nbsp;465. Управляющий (справа) и<br />управляемые (слева) блоки</p>
</div></div>


<p>Модель блока готова. Теперь, если поместить один управляющий и несколько управляемых блоков в одну
и ту же подсистему
(<a href="#pic5" title="Управляющий (справа) и управляемые (слева) блоки">рис.&nbsp;465</a>) и запустить расчет, щелчки на
зеленом круге управляющего блока будут одновременно увеличивать выходы всех управляемых, щелчки
на красном &ndash; уменьшать их, а щелчки на белом &ndash; сбрасывать. При этом в подсистему можно
добавлять сколько угодно управляемых блоков, все они будут получать команды от управляющего, и для
этого пользователю не потребуется проводить новые связи.</p>

<p><span id="ref1">В</span>
этом примере для увеличения, уменьшения и сброса выхода управляемого блока мы использовали три
разных функции.
<span id="light_ref1">Можно было обойтись единственной функцией</span>, сделав
команду блоку (уменьшить, увеличить или сбросить выход) параметром этой функции. По аналогии с ранее
созданными, дадим этой новой функции имя
&laquo;UserManual.PictureClick.Cmd&raquo; и придумаем для нее
<a href="um_3_7_12_1.htm#ref1" title="Параметры функции блока">структуру параметров</a>. Чтобы вызываемая
модель могла проверить правильность переданных ей параметров, оформим параметры функции в виде структуры,
первым полем которой будет размер этой структуры. Поскольку эта структура нам будет нужна и в модели
управляющего, и в модели управляемого блоков, запишем ее в файл
&laquo;<span class="file">pictureclick.h</span>&raquo;, который разместим в одной папке с файлами моделей этих блоков
&ndash; в этом случае в обеих моделях нам нужно будет просто добавить в глобальные описания команду
&laquo;<span class="cpp">#include</span>&raquo; для этого файла. В &laquo;<span class="file">pictureclick.h</span>&raquo;
нужно ввести следующее описание:</p>

<pre class="cpp">  struct TPictureClickFuncParam
  { <a class="hidden" href="app_ids.htm#light_ref14" title="Беззнаковое целое 32 бита">DWORD</a> servSize; // Размер структуры
    int Command;    // Команда блоку
  };</pre>

<p>Первое поле структуры (<span class="cpp">servSize</span>) будет содержать ее собственный размер, а в
целое поле <span class="cpp">Command</span> мы будем записывать команду управляемому блоку. Для упрощения
модели сделаем так, чтобы команды совпадали с идентификаторами элементов векторной картинки, щелчки по
которым должны изменять выходы блоков (эти идентификаторы мы сделали одинаковыми и в управляющем, и в
управляемом блоках): 1 &ndash; уменьшить выход, 2 &ndash; увеличить, 3 &ndash; сбросить. Таким образом,
в управляющем блоке в качестве посылаемой через функцию команды можно будет использовать идентификатор элемента
картинки, на котором щелкнул пользователь.</p>

<p><span id="ref2">Как</span>
и в прошлый раз, начнем с модели управляющего блока. Откроем ее редактор, сотрем три добавленных
ранее функции (см. <a href="um_3_6_5.htm" title="&sect;3.6.5. Функции блока">&sect;3.6.5</a>) и <span id="light_ref2">добавим новую с именем
&laquo;UserManual.PictureClick.Cmd&raquo;</span>
(<a href="#pic6" title="Добавление функции UserManual.PictureClick.Cmd в модель блока">рис.&nbsp;466</a>).</p>

<div class="pic"><div class="container" id="pic6">
<img src="../img/AC_PictureClick_FuncWin2.png" width="567" height="411" alt="Добавление функции UserManual.PictureClick.Cmd в модель блока" />
<p id="light_pic6">Рис.&nbsp;466. Добавление функции &laquo;UserManual.PictureClick.Cmd&raquo; в модель блока</p>
</div></div>


<p>Длинное имя объекта для функции в программе, предлагаемое по умолчанию, заменим на
&laquo;rdsfuncUMPC_Cmd&raquo; (с коротким именем удобнее работать), а поле
&laquo;<span class="menu">тип параметра</span>&raquo; на этот раз не будем оставлять пустым: введем в него
&laquo;TPictureClickFuncParam*&raquo;, то есть
&laquo;указатель на <span class="cpp">TPictureClickFuncParam</span>&raquo;. После нажатия
&laquo;<span class="menu">OK</span>&raquo; в списке функций блока будет единственная функция &ndash;
&laquo;UserManual.PictureClick.Cmd&raquo;
(<a href="#pic7" title="Вкладка функции редактора модели после добавления функции с параметром (размеры панели и колонок увеличены для наглядности)">рис.&nbsp;467</a>).</p>

<div class="pic"><div class="container" id="pic7">
<img src="../img/AC_PictureClick_FuncPanel2.png" width="549" height="153" alt="Вкладка функции редактора модели после добавления функции с параметром (размеры панели и колонок увеличены для наглядности)" />
<p id="light_pic7">Рис.&nbsp;467. Вкладка &laquo;<span class="menu">функции</span>&raquo; редактора модели после добавления функции<br />с параметром (размеры панели и колонок увеличены для наглядности)</p>
</div></div>


<p>Реакцию управляющего блока на нажатие кнопки мыши мы изменим следующим образом:</p>

<pre class="cpp">
  if(<a class="hidden" href="um_3_7_10.htm#ref1" title="Параметр MouseData">MouseData</a>-&gt;Button==<a class="hidden" href="RDS_BFM_MOUSEDBLCLICK.htm#light_ref4" title="RDS_MLEFTBUTTON">RDS_MLEFTBUTTON</a>) // Нажата левая
    { TPictureClickFuncParam param; // Структура параметров
      param.servSize=sizeof(param); // Размер
      // Команда – это идентификатор элемента под курсором
      param.Command=<a class="hidden" href="rdsGetMouseObjectId.htm" title="А.5.6.31. rdsGetMouseObjectId &ndash; элемент векторной картинки блока под курсором мыши">rdsGetMouseObjectId</a>(<a class="hidden" href="um_3_7_10.htm#ref1" title="Параметр MouseData">MouseData</a>);
      rdsfuncUMPC_Cmd.<a class="hidden" href="um_3_7_12_1.htm#light_ref8" title="Функция Broadcast класса функции блока">Broadcast</a>( // Вызов функции всех блоков
        <a class="hidden" href="um_3_7_1.htm#ref26" title="Указатель на структуру данных блока">rdsbcppBlockData</a>-&gt;Parent,0,&amp;param);
    }
  else // Нажата не левая
    Result=<a class="hidden" href="RDS_BFM_MOUSEDOWN.htm#light_ref2" title="RDS_BFR_SHOWMENU">RDS_BFR_SHOWMENU</a>; // Разрешаем контекстное меню</pre>

<p>Если нажата левая кнопка мыши, мы заполняем вспомогательную структуру <span class="cpp">param</span> созданного
нами типа <span class="cpp">TPictureClickFuncParam</span> (команду включения файла
&laquo;<span class="file">pictureclick.h</span>&raquo;, в котором он описан, мы добавим позже) параметрами функции, которую
мы будем вызывать. В поле <span class="cpp">servSize</span> мы записываем размер самой структуры,
полученный оператором <span class="cpp">sizeof</span>, а в поле <span class="cpp">Command</span> &ndash;
идентификатор элемента картинки под курсором, как и раньше, полученный при помощи вызова
<span class="cpp"><a href="rdsGetMouseObjectId.htm" title="А.5.6.31. rdsGetMouseObjectId &ndash; элемент векторной картинки блока под курсором мыши">rdsGetMouseObjectId</a></span>. Затем мы вызываем уже знакомую нам функцию-член
<a href="um_3_7_12_1.htm#light_ref8" title="Функция Broadcast класса функции блока">Broadcast</a> у объекта функции <span class="cpp">rdsfuncUMPC_Cmd</span>
&ndash; это приведет к вызову &laquo;UserManual.PictureClick.Cmd&raquo; у всех блоков подсистемы.
Поскольку у нашей новой функции есть параметр, в третьем параметре
<span class="cpp">Broadcast</span> мы передаем указатель на структуру <span class="cpp">param</span>.</p>

<p>Если нажата не левая кнопка, мы, как и во всех предыдущих моделях, присваиваем переменной
<span class="cpp">Result</span> значение <span class="cpp"><a href="RDS_BFM_MOUSEDOWN.htm#light_ref2" title="RDS_BFR_SHOWMENU">RDS_BFR_SHOWMENU</a></span>, иначе контекстное меню блока
не будет показано.</p>

<p>Можно обратить внимание на то, что теперь мы не проверяем, что вернула функция
<span class="cpp">rdsGetMouseObjectId</span>, то есть какой именно элемент картинки оказался под курсором.
Если пользователь щелкнет мышью в пределах картинки блока, но не попадет ни в один из цветных кругов,
<span class="cpp">rdsGetMouseObjectId</span> вернет ноль, и этот ноль будет передан в качестве команды в
параметре функции. Однако, такой команды у нас нет, поэтому управляемые блоки ничего не выполнят, и никаких
последствий от такого вызова не будет.</p>

<p>Нам осталось только добавить в модель команду включения файла &laquo;<span class="file">pictureclick.h</span>&raquo;,
в котором описан тип параметра нашей функции. Для этого на вкладке
&laquo;<span class="menu"><a href="um_3_6_4.htm" title="&sect;3.6.4. Описания программы и реакции блока на события">события</a></span>&raquo; левой панели редактора нужно раскрыть раздел
&laquo;<span class="menu">описания</span>&raquo;, дважды щелкнуть на его подразделе
&laquo;<span class="menu">глобальные описания</span>&raquo;, и на открывшейся пустой вкладке &laquo;<span class="menu">описания</span>&raquo;
в правой части окна ввести единственную строчку:</p>

<pre class="cpp">  #include "pictureclick.h"</pre>

<p>Модель управляющего блока готова. Изменим теперь модель управляемого, чтобы она реагировала на
новую функцию с параметром. Прежде всего, сотрем в ней три имеющихся на данный момент функции.
Поскольку для этих функций введены реакции, редактор модели будет предупреждать об их существовании.
Нужно согласиться на удаление функции вместе с текстом реакции &ndash; эти реакции в новой модели нам
не понадобятся. Затем нужно добавить в список функцию
&laquo;UserManual.PictureClick.Cmd&raquo; точно так же, как мы только что сделали в модели
управляющего блока. И, как и в модели управляющего блока, добавить в глобальные описания команду для включения файла
&laquo;<span class="file">pictureclick.h</span>&raquo;.</p>

<p>Теперь нужно ввести реакцию на вызов функции &laquo;UserManual.PictureClick.Cmd&raquo;.
Проще всего выбрать эту функцию на вкладке &laquo;<span class="menu">функции</span>&raquo; левой панели редактора
(она там единственная) и нажать кнопку с листком в левой нижней части этой вкладки
(см. <a href="#pic7" title="Вкладка функции редактора модели после добавления функции с параметром (размеры панели и колонок увеличены для наглядности)">рис.&nbsp;467</a>). На открывшейся вкладке с
названием функции нужно ввести следующий текст:</p>

<pre class="cpp">  if(Param==NULL || Param-&gt;servSize&lt;sizeof(TPictureClickFuncParam))
    return; // Нет параметра или недостаточный размер структуры
  // Параметр в порядке
  switch(Param-&gt;Command)
    { case 1: y--; break;
      case 2: y++; break;
      case 3: y=0; break;
    }
  // Взводим сигнал готовности для передачи выхода по связям
  <a class="hidden" href="um_1_4.htm#ref27" title="Сигнал готовности блока">Ready</a>=1;</pre>

<p>Прежде, чем разбирать текст этой реакции, следует обратить внимание на заголовок создаваемой для
нее функции, который редактор модели показывает к верхней части вкладки. Он выглядит так:</p>

<pre class="cpp">  void <a class="hidden" href="um_3_7_1.htm#ref13" title="Класс блока в актокомпилируемых моделях">rdsbcppBlockClass</a>::rdsfuncUMPC_CmdEvent(
    TPictureClickFuncParam* Param,
    <a class="hidden" href="RDS_BFM_FUNCTIONCALL.htm#ref2" title="Указатель на RDS_FUNCTIONCALLDATA">RDS_PFUNCTIONCALLDATA</a> FData,
    int &amp;Result)</pre>

<p>У функции реакции, текст которой мы пишем, три параметра. Параметр <span class="cpp">Param</span> типа
<span class="cpp">TPictureClickFuncParam*</span> &ndash; это тот самый параметр функции, который мы
описывали при ее создании, и который передается от вызывающего блока в последнем параметре функции-члена
<span class="cpp">Broadcast</span>. Именно к <span class="cpp">Param</span> мы будем обращаться, чтобы
считать команду блока. Параметр <span class="cpp">FData</span> представляет собой указатель на
<a href="RDS_BFM_FUNCTIONCALL.htm#ref1" title="Структура RDS_FUNCTIONCALLDATA">структуру описания функции</a>, из которой можно узнать, какой
именно блок вызвал функцию, сколько блоков уже вызвано и т.п. В нашей модели эта информация нам не
потребуется, как и целый параметр <span class="cpp">Result</span>, передаваемый по ссылке, через который
функция может вернуть вызвавшему блоку одно целое число (наша функция ничего не возвращает).</p>

<p>Вернемся теперь к реакции на вызов функции. Сначала мы проверяем допустимость переданного параметра. Если
<span class="cpp">Param</span> равен <span class="cpp">NULL</span>, значит, при вызове нашей функции не
был передан параметр. Если <span class="cpp">Param</span> не равен <span class="cpp">NULL</span>, но первое
поле структуры по этому указателю меньше размера структуры <span class="cpp">TPictureClickFuncParam</span>,
значит, вызвавшая модель передала указатель на неправильную структуру. В обоих случая мы немедленно
завершаем реакцию, поскольку считать команду из параметра функции невозможно. Если же параметр прошел обе
проверки, мы читаем из переданной структуры поле <span class="cpp">Command</span> и, в зависимости от
его значения, увеличиваем, уменьшаем или сбрасываем выход блока, после чего принудительно взводим сигнал готовности
<span class="cpp">Ready</span> для передачи выхода по связям.</p>

<p>Если все было сделано правильно, схема с новыми моделями управляющего и управляемого блоков будет работать
точно так же, как и со старыми: щелчки на зеленом круге управляющего блока будут одновременно увеличивать выходы
всех управляемых, щелчки на красном &ndash; уменьшать их, а щелчки на белом &ndash; сбрасывать.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_7_12_1.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_12_3.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_12_2">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
