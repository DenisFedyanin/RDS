<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.7.2.1. Модели с простыми статическими переменными</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7_2">&sect;3.7.2. Работа со статическими переменными блока</a></p>
<div class="level"><p>&sect;3.7.2.1. Модели с простыми статическими переменными</p>
</div>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_7_1.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_2_2.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_2_1">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</h3>
<h4>&sect;3.7.2. Работа со статическими переменными блока</h4>
<p class="abstract">Описывается использование в моделях статических переменных блока, которые могут быть его входами и выходами. Отдельно рассматриваются разные типы переменных и их возможности.</p>
<h5>&sect;3.7.2.1. Модели с простыми статическими переменными</h5>
<p class="abstract">Описывается использование в моделях статических переменных простых типов: целых, вещественных и логических. Это наиболее часто используемые типы входов и выходов блока. Также рассматриваются особенности использования объектов, создаваемых для работы с переменными, и создание моделей, срабатывающих не в каждом такте расчета, а только при изменении входов блока.</p>


<p>Вернемся к рассмотренной в
<a href="um_3_3.htm" title="&sect;3.3. Создание нового блока с автокомпилируемой моделью">&sect;3.3</a> простейшей модели: сумматору, выдающему на вещественный выход
&laquo;<span class="rdsvar">y</span>&raquo; сумму вещественных входов &laquo;<span class="rdsvar">x1</span>&raquo; и &laquo;<span class="rdsvar">x2</span>&raquo;. Эта модель вполне
работоспособна, но у нее есть пара недостатков.</p>

<p>Во-первых, сумматор с такой моделью будет работать только в том случае, если в параметрах блока будет
<a href="um_2_9_1.htm#light_ref8" title="Установка режима запуска блока">установлен флаг запуска каждый такт</a>. По умолчанию этот флаг устанавливается
для каждого вновь созданного блока, поэтому в <a href="um_3_3.htm" title="&sect;3.3. Создание нового блока с автокомпилируемой моделью">&sect;3.3</a> он не упоминается.
Такой способ запуска приводит к тому, что функция модели будет принудительно выполняться в каждом
<a href="um_1_3.htm#ref4" title="Такт расчета">такте</a>, вычисляя значение выхода, даже если значения входов не изменились.
В данном случае модель очень простая, и ее лишние запуски не приведут к существенному замедлению работы схемы,
однако, для более сложных моделей замедление может стать заметным. В RDS считается хорошим тоном писать
модели блоков, выходы которых зависят только от входов, так, чтобы они запускались только при изменении этих
входов.</p>

<p><span id="ref1">Во-вторых</span>, описанная модель не рассчитана на то, что на один из ее входов
может вместо вещественного числа
поступить специальная константа (в математической библиотеке языка C она называется
<span id="light_ref1" class="cpp">HUGE_VAL</span>), используемая в качестве признака математической ошибки. Такую
константу выдают на выход стандартные блоки RDS, попытавшиеся выполнить недопустимую математическую операцию
&ndash; например, деление на ноль. Как правило, при обнаружении на любом своем входе этой константы, блок, не
выполняя вычислений, выдает ее же на свой выход, сообщая тем самым всем соединенным с ним блокам о произошедшей
ошибке. По желанию разработчика, можно предусмотреть и другие возможные реакции. На самом деле, такая простая
модель, несмотря на отсутствие в ней каких-либо проверок входов, все равно выдаст на выход константу
<span class="cpp">HUGE_VAL</span> при поступлении ее на один из входов: так устроена операция сложения.
Кроме того, включенный по умолчанию флажок
&laquo;<span class="menu">перехватывать ошибки математических функций</span>&raquo; в <a href="um_3_6_7.htm" title="&sect;3.6.7. Параметры модели">параметрах модели</a>
автоматически заменит результат невыполнимой математической операции на эту константу. Однако, более сложным моделям
необходимо опознавать ошибочные значения входов и предпринимать по этому поводу какие-либо действия, поэтому, для
примера, мы добавим в нашу модель такие проверки.</p>

<p>Исправим созданную ранее модель сумматора. Сначала разберемся с запуском каждый такт &ndash; это не требует
внесения изменений в текст введенного фрагмента программы модели, достаточно изменить некоторые параметры блока
и его переменных. Загрузим схему с блоком, созданным в <a href="um_3_3.htm" title="&sect;3.3. Создание нового блока с автокомпилируемой моделью">&sect;3.3</a>
(если она не сохранена, нужно просто проделать заново все описанные там шаги), и откроем окно редактора модели
двойным щелчком на этом блоке. На левой панели редактора выберем
вкладку &laquo;<span class="menu">переменные</span>&raquo; (см. 
<a href="um_3_3.htm#pic8" title="Окно редактора пустой модели">рис.&nbsp;321</a>, если левая панель отсутствует, следует включить ее
пунктом меню &laquo;<span class="menu">вид | переменные и события</span>&raquo;) и нажмем кнопку
&laquo;<span class="menu">изменить</span>&raquo; под списком статических переменных (см.
<a href="um_3_3.htm#pic9" title="Вызов редактора статических переменных блока">рис.&nbsp;322</a>). Откроется окно редактирования
<a href="um_1_4.htm" title="&sect;1.4. Статические переменные блоков">статических переменных</a>
блока, в котором нужно внести изменения, изображенные
на <a href="#pic1" title="Изменения в статических переменных простого сумматора">рис.&nbsp;362</a>.</p>

<div class="pic"><div class="container" id="pic1">
<img src="../img/AC_sum_vars_2.png" width="670" height="319" alt="Изменения в статических переменных простого сумматора" />
<p id="light_pic1">Рис.&nbsp;362. Изменения в статических переменных простого сумматора</p>
</div></div>


<p><span id="ref2">Прежде</span>
<span id="ref3">всего</span>, необходимо включить флажки в колонке &laquo;<span class="menu">пуск</span>&raquo; напротив входов блока
&laquo;<span class="rdsvar">x1</span>&raquo; и &laquo;<span class="rdsvar">x2</span>&raquo;. Это приведет к тому, что при срабатывании любой связи,
подключенной к этим входам,
<span id="light_ref2"><a href="um_1_4.htm#ref25" title="Сигнал запуска блока">сигналу запуска блока</a></span>, то есть его первой
переменной (в данном блоке она называется
&laquo;<span class="rdsvar"><span id="light_ref3">Start</span></span>&raquo; &ndash; это ее обычное имя, даваемое ей при создании блока), будет автоматически присвоено
значение 1, а это, в свою очередь, вызовет запуск модели блока в следующем такте расчета. Кроме того, переменной
&laquo;<span class="rdsvar">Start</span>&raquo; нужно дать единичное значение по умолчанию, чтобы при самом первом запуске расчета модель
сложила начальные значения своих входов и выдала сумму на выход. Если этого не сделать, модель запустится только
после первого срабатывания связи, а начальные значения входов не будут обработаны. Может показаться, что достаточно
просто дать выходу значение по умолчанию, равное сумме значений входов, однако, это не так. Перед первым
запуском расчета производится начальная передача данных по связям, о которой модели блоков не информируются:
если, например, к входам блока будут подключены поля ввода, на момент самого первого запуска расчета (или
запуска после сброса) значения входов &laquo;<span class="rdsvar">x1</span>&raquo; и &laquo;<span class="rdsvar">x2</span>&raquo; будут не нулевыми, а
равными значениям этих полей ввода, причем сигнал &laquo;<span class="rdsvar">Start</span>&raquo; при этой начальной передаче данных
автоматически взведен не будет. По этой причине в моделях, полагающихся на автоматический запуск при
срабатывании входных связей, сигналу запуска следует присваивать единицу либо в качестве значения по умолчанию,
как в данном случае, либо принудительно в реакции на
<a href="ac_RDS_BFM_STARTCALC.htm" title="&sect;3.8.3.2. Запуск расчета">событие запуска расчета</a>
<span class="cpp"><a href="RDS_BFM_STARTCALC.htm" title="А.2.4.14. RDS_BFM_STARTCALC &ndash; запуск расчета">RDS_BFM_STARTCALC</a></span>.</p>

<p>Внеся изменения в статические переменные блока, следует закрыть окно редактирования переменных кнопкой
&laquo;<span class="menu">OK</span>&raquo;.</p>

<p>Теперь наша модель способна запускаться при срабатывании входных связей, но в параметрах блока, к которому
она подключена, пока еще установлен ее запуск каждый такт. Необходимо перевести этот блок в режим запуска по
сигналу, то есть запуска только при ненулевом значении переменной &laquo;<span class="menu">Start</span>&raquo;. Поскольку этот блок
&ndash; единственный, можно просто открыть
<a href="um_2_9_1.htm" title="&sect;2.9.1. Создание простого блока и окно его параметров">окно его параметров</a>
и переключить флажок на
вкладке &laquo;<span class="menu">общие</span>&raquo;
(<a href="#pic2" title="Установка запуска по сигналу в окне параметров блока">рис.&nbsp;363</a>).
Если бы таких блоков было несколько, пришлось бы открывать окно параметров для каждого из них, поэтому
переключим режим запуска модели блока при помощи
<a href="um_3_6_8.htm" title="&sect;3.6.8. Установка параметров блоков с автокомпилируемой моделью">функции групповой установки</a>, которая обработает все блоки с нашей
моделью во всех подсистемах. Для этого следует открыть окно групповой установки, выбрав в
<a href="um_3_6_1.htm" title="&sect;3.6.1. Элементы и меню окна редактора модели">окне редактора модели</a>
пункт меню &laquo;<span class="menu">модель | установка параметров блоков</span>&raquo; или нажать соответствующую ему кнопку. В окне
следует включить флажок &laquo;<span class="menu">установить запуск модели</span>&raquo; и подчиненный ему
&laquo;<span class="menu">по сигналу готовности</span>&raquo;
(<a href="#pic3" title="Установка запуска по сигналу в окне групповой установки">рис.&nbsp;364</a>),
после чего закрыть окно кнопкой &laquo;<span class="menu">OK</span>&raquo;.</p>

<div class="pic"><div class="container" id="pic2">
<img src="../img/AC_SimpleBlockParams_onsignal.png" width="534" height="318" alt="Установка запуска по сигналу в окне параметров блока" />
<p id="light_pic2">Рис.&nbsp;363. Установка запуска по сигналу в окне параметров блока</p>
</div></div>


<div class="pic"><div class="container" id="pic3">
<img src="../img/AC_sum_groupset.png" width="638" height="374" alt="Установка запуска по сигналу в окне групповой установки" />
<p id="light_pic3">Рис.&nbsp;364. Установка запуска по сигналу в окне групповой установки</p>
</div></div>


<p>Теперь модель блока будет запускаться один раз при первом запуске расчета, и далее каждый раз при
срабатывании одной из входных связей. С точки зрения пользователя поведение сумматора не изменится: он
складывает свои входы, как и раньше (простая схема для тестирования сумматора изображена
на <a href="um_3_3.htm#pic12" title="Тестирование сумматора">рис.&nbsp;325</a>),
но теперь его работа меньше нагружает систему.</p>

<p>Добавим в нашу модель проверку значений входов на константу, сигнализирующую о математической ошибке. Как
уже объяснялось выше, для такой простой модели, да еще и с включенным перехватом ошибок математики, в этой
проверке нет необходимости. Здесь эта проверка приводится только в качестве примера. Она будет полезна, а,
в некоторых случаях, и обязательна, в более сложных блоках. Например, если бы модель выполняла не сложение,
а деление, и перехват ошибок математики был бы выключен, подача на оба входа константы ошибки привело бы к
исключению в модели (впрочем, как и деление на ноль, на которое тоже пришлось бы делать проверку).</p>

<p><span id="ref4">В</span>
автоматически компилируемых моделях блоков в качестве значения, указывающего на математическую ошибку,
лучше всего брать не константу <span class="cpp">HUGE_VAL</span>, а содержимое глобальной переменной
<span class="cpp" id="light_ref4"><a href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a></span>.
В этой переменной хранится константа <span class="cpp">HUGE_VAL</span>, полученная из RDS при помощи
сервисной функции <span class="cpp"><a href="rdsGetHugeDouble.htm" title="А.5.2.22. rdsGetHugeDouble &ndash; получение значения-индикатора математической ошибки">rdsGetHugeDouble</a></span>. Вызов этой функции добавляется в программу
модели без участия пользователя. Использование этой переменной вместо константы гарантирует, что во всех
моделях блоков, независимо от того, какими компиляторами с какими версиями библиотек они созданы, в качестве
ошибки математической операции используется одно и то же число. Следует учитывать, что эта переменная
имеет тип <span class="cpp">double</span>, и, поэтому, она пригодна только для работы с переменными блока
того же типа. Для типа <span class="cpp">float</span> в RDS нет специально выделенного значения ошибки,
поэтому при создании автокомпилируемых моделей следует, по возможности, использовать именно тип
<span class="cpp">double</span>.</p>

<p><span id="ref5">Поскольку</span>
занесение значения в глобальную переменную <span class="cpp">rdsbcppHugeDouble</span> выполняется
без нашего участия, все, что нам нужно сделать &ndash; это добавить в реакцию на такт расчета нашей модели
(<a href="um_3_3.htm#pic11" title="Окно редактора модели простейшего сумматора">вкладка &laquo;<span class="menu">модель</span>&raquo;</a> в редакторе)
<span id="light_ref5">оператор <span class="cpp">if</span></span>
(цветом выделен добавленный в модель текст):</p>

<pre class="cpp"><span class="changes">  if(x1==rdsbcppHugeDouble || x2==rdsbcppHugeDouble)
    y=rdsbcppHugeDouble;
  else
</span>    y=x1+x2;</pre>

<p>Теперь, если хотя бы один из входов блока будет равен значению <span class="cpp">rdsbcppHugeDouble</span>,
выходу будет присвоено это же значение, и вычисления выполнены не будут. При желании, при ошибке на входе
можно взводить какой-либо дополнительный выход ошибки, или выдавать на выход нулевое значение &ndash; все
зависит от того, каких целей добивается создатель модели.</p>

<p>В программе модели можно использовать не только простые математические операции, но и любые функции языка C
&ndash; например, тригонометрические. Рассмотрим еще одну модель, которая будет вычислять синус или косинус входа
блока. В этом блоке тоже будут только простые статические переменные: вещественный вход &laquo;<span class="rdsvar">x</span>&raquo;,
вещественный выход &laquo;<span class="rdsvar">y</span>&raquo; и целый вход &laquo;<span class="rdsvar">func</span>&raquo;, на который будет подаваться ноль,
если необходимо вычислить синус, и единица, если косинус. Сразу заложим в этот блок запуск при срабатывании входных
связей и введем в него проверку на поступление на вход значения-индикатора ошибки.</p>

<p><span id="light_ref6">Создадим новый пустой блок</span>,
переключим его в режим работы по сигналу и создадим для него новую модель, как это
было описано в <a href="um_3_3.htm" title="&sect;3.3. Создание нового блока с автокомпилируемой моделью">&sect;3.3</a>. Для этого необходимо:</p>

<ul>
  <li>нажать на свободном месте окна подсистемы правую кнопку мыши;</li>
  <li>выбрать в открывшемся контекстном меню пункт &laquo;<span class="menu">создать | новый блок</span>&raquo;
  (см. <a href="um_3_3.htm#pic1_0" title="Создание простого блока (а) и вызов окна его параметров (б)">рис.&nbsp;314&nbsp;а</a>);</li>
  <li>нажать на созданном блоке (он будет выглядеть как белый квадрат с черной рамкой) правую кнопку мыши;</li>
  <li>выбрать в открывшемся контекстном меню пункт &laquo;<span class="menu">параметры</span>&raquo; (см.
  <a href="um_3_3.htm#pic1_1" title="Создание простого блока (а) и вызов окна его параметров (б)">рис.&nbsp;314&nbsp;б</a>);</li>
  <li>на вкладке &laquo;<span class="menu">общие</span>&raquo; открывшегося окна включить флажок &laquo;<span class="menu">по сигналу</span>&raquo; на панели
  &laquo;<span class="menu">запуск</span>&raquo; (см. <a href="#pic2" title="Установка запуска по сигналу в окне параметров блока">рис.&nbsp;363</a>);</li>
  <li>на вкладке &laquo;<span class="menu">компиляция</span>&raquo; установить флажок &laquo;<span class="menu">функция блока компилируется автоматически</span>&raquo;,
  выбрать в выпадающем списке подключенный модуль автокомпиляции и нажать кнопку &laquo;<span class="menu">новый</span>&raquo;
  (см. <a href="um_3_3.htm#pic2" title="Создание для блока новой автокомпилируемой модели">рис.&nbsp;315</a>);</li>
  <li>в появившемся окне &laquo;<span class="menu">новая модель</span>&raquo; выбрать флажок &laquo;<span class="menu">создать пустую модель</span>&raquo;
  (см. <a href="um_3_3.htm#pic3" title="Выбор создания пустой автокомпилируемой модели">рис.&nbsp;316</a>) и закрыть окно кнопкой &laquo;<span class="menu">OK</span>&raquo;
  (если в используемой версии RDS нет шаблонов моделей, этот шаг будет пропущен и сразу откроется диалог
  сохранения);</li>
  <li>в диалоге сохранения модели ввести имя нового файла, в который будет записана создаваемая модель
  (см. <a href="um_3_3.htm#pic5" title="Диалог сохранения файла модели">рис.&nbsp;318</a>), и нажать кнопку &laquo;<span class="menu">сохранить</span>&raquo;;</li>
  <li>закрыть окно параметров блока кнопкой &laquo;<span class="menu">OK</span>&raquo;.</li>
</ul>

<p class="noindent">После выполнения перечисленных выше действий откроется
<a href="um_3_3.htm#pic8" title="Окно редактора пустой модели">пустое окно редактора модели</a>, в котором нужно создать структуру
статических переменных блока и ввести реакцию на выполнение такта расчета. Для ввода статических переменных
необходимо на вкладке &laquo;<span class="menu">переменные</span>&raquo; левой панели окна редактора нажать кнопку
&laquo;<span class="menu">изменить</span>&raquo; (см. <a href="um_3_3.htm#pic9" title="Вызов редактора статических переменных блока">рис.&nbsp;322</a>) и заполнить
таблицу переменных в окне следующим образом:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td>Start</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">1</td>
  </tr>

  <tr>
    <td>Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>x</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>func</td>
    <td class="center">int</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>y</td>
    <td class="center">double</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>
</table>
</div></div>

<p>Теперь на вкладке &laquo;<span class="menu">модель</span>&raquo; в правой части окна редактора
(см. <a href="um_3_3.htm#pic8" title="Окно редактора пустой модели">рис.&nbsp;321</a>) нужно ввести следующий фрагмент программы:</p>

<pre class="cpp">  if(x==rdsbcppHugeDouble)
    { y=rdsbcppHugeDouble;
      return;
    }
  switch(func)
    { case 0:  // Синус
        y=sin(x);
        break;
      case 1:  // Косинус
        y=cos(x);
        break;
      default: // Ошибка
        y=rdsbcppHugeDouble;
    }</pre>

<p>Этот фрагмент будет выполняться в каждом такте расчета, если в этом такте блок получит сигнал запуска, то есть,
если значение сигнала готовности (переменной &laquo;<span class="rdsvar">Start</span>&raquo;) нашего блока не будет равно нулю.
Мы дали этой переменной начальное значение, равное единице, поэтому наша модель обязательно выполнится при первом
запуске расчета. Кроме того, мы поставили флажки в колонке &laquo;<span class="menu">пуск</span>&raquo; напротив входов блока
&laquo;<span class="rdsvar">x</span>&raquo; и &laquo;<span class="rdsvar">func</span>&raquo;, поэтому при срабатывании связей, соединенных с
этими входами, сигнал готовности автоматически взведется, и модель тоже выполнится. Рассмотрим введенный фрагмент
программы подробно.</p>

<p>Самый первый оператор в этом фрагменте &ndash; сравнение значения входа блока <span class="cpp">x</span>
с глобальной переменной <span class="cpp">rdsbcppHugeDouble</span>, в которой хранится значение-индикатор ошибки
вычисления (<span class="cpp">HUGE_VAL</span>). Если на входе нашего блока окажется это значение, оно же будет
присвоено выходу <span class="cpp">y</span>, и модель немедленно завершится оператором <span class="cpp">return</span>.
Таким образом, при получении признака ошибки наш блок просто передает его на выход, не выполняя никаких вычислений.
Значение входа <span class="cpp">func</span> мы с признаком ошибки не сравниваем &ndash; это целый вход, а для
целых чисел в RDS не предусмотрено каких-либо индикаторов ошибок вычисления.</p>

<p>Далее выполняется оператор <span class="cpp">switch</span>, в котором, в зависимости от значения входа
<span class="cpp">func</span>, вычисляется выход блока. Если значение <span class="cpp">func</span>
&ndash; 0 или 1, выходу <span class="cpp">y</span> присваивается синус или косинус входа соответственно.
При любом другом значении <span class="cpp">func</span> выходу присваивается значение-индикатор ошибки
<span class="cpp">rdsbcppHugeDouble</span>.</p>

<p>Теперь можно скомпилировать модель (пункт меню
<a href="um_3_6_1.htm" title="&sect;3.6.1. Элементы и меню окна редактора модели">редактора</a>
&laquo;<span class="menu">модель | компилировать</span>&raquo; или
кнопка с желтой шестеренкой) и проверить ее работу. Для тестирования модели можно собрать схему, изображенную
на <a href="#pic4" title="Тестирование модели вычисления синуса и косинуса">рис.&nbsp;365</a>
или подобную ей. На рисунке вход блока &laquo;<span class="rdsvar">x</span>&raquo; соединен с выходом текущего времени &laquo;<span class="rdsvar">Time</span>&raquo;
стандартного блока-планировщика. Следует иметь в виду, что &laquo;<span class="rdsvar">Time</span>&raquo; &ndash; скрытый выход, и
он не будет отображаться отдельным пунктом в меню подключения связи
(см. <a href="um_2_7_1.htm" title="&sect;2.7.1. Общие принципы создания связей">&sect;2.7.1</a>), для его выбора придется использовать пункт
&laquo;<span class="menu">список</span>&raquo; в этом меню.</p>

<div class="pic"><div class="container" id="pic4">
<img src="../img/AC_sincostest.png" width="579" height="209" alt="Тестирование модели вычисления синуса и косинуса" />
<p id="light_pic4">Рис.&nbsp;365. Тестирование модели вычисления синуса и косинуса</p>
</div></div>


<p>Запустив расчет, можно будет наблюдать на графике синусоиду или косинусоиду, в зависимости от значения,
поданного на &laquo;<span class="rdsvar">func</span>&raquo;. Если вход &laquo;<span class="rdsvar">func</span>&raquo; не будет равен нулю или единице, график
рисоваться не будет, а в заголовке его вертикальной оси в скобках вместо текущего значения будет отображаться
вопросительный знак &ndash; так в RDS выводится значение-индикатор ошибки.</p>

<p>В обоих приведенных выше примерах мы использовали переменные блока в программе так, как будто это переменные
типов <span class="cpp">int</span> и <span class="cpp">double</span>, а не объекты специальных классов, за
которыми скрыты настоящие значения
(см. <a href="um_3_7_1.htm" title="&sect;3.7.1. Устройство формируемой модулем программы">&sect;3.7.1</a>). Об этом можно не задумываться до тех пор, пока где-нибудь
в программе не потребуется указатель на переменную блока. В этом случае необходимо принимать специальные
меры, что мы сейчас проиллюстрируем на примере.</p>

<p>Создадим модель блока, разбивающего поступившее на его вход &laquo;<span class="rdsvar">x</span>&raquo; вещественное число на целую
и дробную части и выдающего целую часть на выход &laquo;<span class="rdsvar">integer</span>&raquo;, а дробную &ndash; на выход
&laquo;<span class="rdsvar">fraction</span>&raquo; (оба выхода сделаем вещественными). Блок будет иметь следующую структуру
переменных:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td>Start</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">1</td>
  </tr>

  <tr>
    <td>Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>x</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>integer</td>
    <td class="center">double</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>fraction</td>
    <td class="center">double</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>
</table>
</div></div>

<p><a href="#light_ref6" title="Создание нового блока с моделью">Создадим</a>
новый блок с автокомпилируемой моделью, зададим для него запуск по сигналу и введем в модель приведенную
выше структуру статических переменных.
<span id="ref7">Для</span>
разбиения вещественного числа на целую и дробную части логично
использовать функцию <span class="cpp" id="light_ref7">modf</span> из стандартной математической библиотеки. В
&laquo;<span class="file">math.h</span>&raquo; она описана следующим образом:</p>

<pre class="cpp">  <span class="kw">double</span> modf(<span class="kw">double</span> x, <span class="kw">double</span> *ipart);</pre>

<p>Здесь <span class="cpp">x</span> &ndash; разбиваемое число, <span class="cpp">ipart</span> &ndash; указатель
на переменную, в которую функция запишет целую часть числа, а дробную часть функция вернет по значению.
Поскольку &laquo;<span class="rdsvar">x</span>&raquo;, &laquo;<span class="rdsvar">integer</span>&raquo; и &laquo;<span class="rdsvar">fraction</span>&raquo; &ndash;
статические переменные блока, имеющие тип &laquo;double&raquo;, возникает желание ввести на вкладку
&laquo;<span class="menu">модель</span>&raquo; редактора следующий текст:</p>

<pre class="cpp">  fraction=modf(x,&integer);</pre>

<p>Однако, если скомпилировать такую модель, компилятор выдаст сообщение об ошибке примерно следующего содержания:
&laquo;сannot convert 'rdsbcstDouble*' to 'double*' in function rdsbcppBlockClass::rdsbcppModel&raquo;
(&laquo;невозможно преобразовать тип rdsbcstDouble* в тип double* в функции-члене rdsbcppModel класса rdsbcppBlockClass&raquo;).
Действительно, несмотря на то, что в блоке переменная с именем &laquo;<span class="rdsvar">integer</span>&raquo; имеет тип &laquo;double&raquo;,
объект <span class="cpp">integer</span> в классе блока, с которым мы работаем в программе, имеет тип
<span class="cpp">rdsbcstDouble</span> (результат работы макроса, создающего этот класс, приведен
в <a href="um_3_7_1.htm#ref21" title="Макросы классов переменных">&sect;3.7.1</a>).
Таким образом, выражение &laquo;<span class="cpp">&integer</span>&raquo;, которое мы подставили во второй параметр функции
<span class="cpp">modf</span>, имеет тип
&laquo;указатель на <span class="cpp">rdsbcstDouble</span>&raquo;, а не
&laquo;указатель на <span class="cpp">double</span>&raquo;, и компилятор не знает, что
с ним делать.</p>

<p>Из этой ситуации есть два выхода. Во-первых, можно использовать вспомогательную переменную для вызова
<span class="cpp">modf</span>, а затем присвоить ее значение объекту <span class="cpp">integer</span>:</p>

<pre class="cpp">  double i_aux;
  fraction=modf(x,&i_aux);
  integer=i_aux;</pre>

<p>Здесь вводится локальная переменная <span class="cpp">i_aux</span>, указатель на которую передается в
<span class="cpp">modf</span>. Это &laquo;настоящая&raquo; переменная типа <span class="cpp">double</span>,
поэтому никаких ошибок не возникнет. После вызова <span class="cpp">modf</span> в
<span class="cpp">i_aux</span> будет находиться целая часть числа, и ее можно присвоить
<span class="cpp">integer</span> (операторы присваивания для класса <span class="cpp">rdsbcstDouble</span>
переопределены, никакие указатели здесь не используются, поэтому ошибок тоже не возникнет).</p>

<p><span id="ref8">Во-вторых</span>, и этот вариант будет гораздо короче, можно воспользоваться функцией-членом
<span class="cpp" id="light_ref8">GetPtr</span>, которая есть в любом классе, создаваемом модулем
автокомпиляции для простых статических переменных: эта функция возвращает указатель на скрытую в объекте
класса переменную блока. Для переменных блока типа &laquo;double&raquo;, обслуживаемых классом
<span class="cpp">rdsbcstDouble</span>, эта функция будет иметь тип &laquo;<span class="cpp">double*</span>&raquo;, то есть
&laquo;указатель на <span class="cpp">double</span>&raquo;, что нам и требуется. Модель при
этом будет выглядеть так:</p>

<pre class="cpp">  fraction=modf(x,integer.GetPtr());</pre>

<p>Вторым параметром в <span class="cpp">modf</span> здесь передается указатель на вещественную переменную,
скрытую в объекте <span class="cpp">integer</span>, поэтому целая часть числа сразу будет записана в
нужный выход блока.</p>

<p>На всякий случай, можно добавить в модель проверку входа на
<a href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">значение-индикатор ошибки</a>. Если не добавлять
эту проверку, функция <span class="cpp">modf</span> запишет <span class="cpp">HUGE_VAL</span> в переменную
<span class="cpp">integer</span>, а переменная <span class="cpp">fraction</span> получит значение 0. Если
такое поведение блока нам подходит, можно оставить в модели только вызов функции <span class="cpp">modf</span>,
как указано выше. Если же нужно сделать так, чтобы при поступлении значения ошибки на вход оба выхода получали это
же значение, модель будет выглядеть так:</p>

<pre class="cpp">  if(x==rdsbcppHugeDouble)
    { fraction=integer=rdsbcppHugeDouble;
      return;
    }
  fraction=modf(x,integer.GetPtr());</pre>

<p>Для тестирования созданной модели можно собрать схему, изображенную
на <a href="#pic5" title="Тестирование модели разбиения числа на целую и дробную части">рис.&nbsp;366</a>.
Запустив расчет и вводя разные числа в поле ввода слева от блока, можно наблюдать на индикаторах справа
целую и дробную части введенного числа.</p>

<div class="pic"><div class="container" id="pic5">
<img src="../img/AC_modf_test.png" width="286" height="72" alt="Тестирование модели разбиения числа на целую и дробную части" />
<p id="light_pic5">Рис.&nbsp;366. Тестирование модели разбиения числа на целую и дробную части</p>
</div></div>


</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_7_1.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_2_2.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_2_1">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
