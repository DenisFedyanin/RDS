<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.7.2.2. Модели с матрицами</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7_2">&sect;3.7.2. Работа со статическими переменными блока</a></p>
<div class="level"><p>&sect;3.7.2.2. Модели с матрицами</p>
</div>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_7_2_1.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_2_3.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_2_2">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</h3>
<h4 class="off">&sect;3.7.2. Работа со статическими переменными блока</h4>
<h5>&sect;3.7.2.2. Модели с матрицами</h5>
<p class="abstract">Рассматриваются особенности использования матриц в моделях блоков. Описываются функции для работы с матрицами (в частности, для программного задания их размеров) и способ обращения к их элементам.</p>


<p>Матрица в RDS &ndash; это двумерная таблица переменных одного типа, в которой конкретный элемент
определяется индексом строки и индексом столбца. Индексы строк и столбцов всегда начинаются с нуля.
<a href="um_1_4.htm#ref1" title="Типы переменных блока">Тип</a>
элемента матрицы может быть любым, в том числе, и другой матрицей, но, чаще всего, используются матрицы
простых типов &ndash; например, вещественных чисел. Как и любые
<a href="um_1_4.htm" title="&sect;1.4. Статические переменные блоков">статические переменные</a>
блока, матрицы
<a href="um_1_4.htm#ref20" title="Роли переменных в блоке">могут быть</a>
входами, выходами и внутренними переменными. Размер матрицы, то есть число ее строк и столбцов, не
фиксирован, и может изменяться в процессе расчета: матрицы-входы получают свои значения по
<a href="um_2_7_1.htm" title="&sect;2.7.1. Общие принципы создания связей">связям</a>, и их размеры определяются размерами подключенных к ним
матриц-выходов других блоков, а размеры матриц-выходов и внутренних переменных задаются программно в модели
блока. Матрица может быть пустой, то есть не иметь элементов (в этом случае считается, что ее размер
&ndash; ноль строк на ноль столбцов).</p>

<p>Как и для простых статических переменных, для матриц модуль автокомпиляции создает специальные классы доступа и
добавляет в класс блока <span class="cpp">rdsbcppBlockClass</span> по одному объекту для каждой матрицы, причем
имена этих объектов совпадают с именами переменных блока. В результате внутри фрагментов программ, вводимых
пользователем, к матрицам, являющимся статическими переменными блока, можно обращаться просто по именам. Для
доступа к конкретному элементу матрицы используется стандартный синтаксис языка C с квадратными скобками: если,
например, матрица имеет имя <span class="cpp">M</span>, ее элемент в строке <span class="cpp">r</span> и столбце
<span class="cpp">c</span> записывается как &laquo;<span class="cpp">M[r][c]</span>&raquo;. В классы матриц, создаваемые модулем
автокомпиляции, включаются различные функции-члены для определения числа строк и столбцов в матрице, установки
ее размера и т.п., все эти функции можно использовать в реакциях на события. Ниже приведены основные функции-члены
классов матриц (во всех примерах предполагается, что <span class="cpp">M</span> и <span class="cpp">M1</span> &ndash;
матрицы переменных типа <span class="cpp">double</span>):</p>

<dl>
  <dt><span class="cpp"><i>вспомогательный_тип</i> operator[](int row)</span></dt>
  <dd>Обращение к строке матрицы. Здесь <span class="cpp">row</span> &ndash; целый номер строки, начинающийся с
  нуля, а <span class="cpp"><i>вспомогательный_тип</i></span> &ndash; специальный тип, такой, что применение к
  нему еще одного оператора &laquo;<span class="cpp">[col]</span>&raquo; вернет элемент матрицы в строке <span class="cpp">row</span>
  и столбце <span class="cpp">col</span>. Например, для матриц вещественных чисел таким типом будет
  &laquo;<span class="cpp">double*</span>&raquo;, т.е. &laquo;указатель на <span class="cpp">double</span>&raquo;.
  Таким образом, &laquo;<span class="cpp">M[row][col]</span>&raquo; позволяет обратиться к элементу матрицы <span class="cpp">M</span>,
  находящемуся в строке <span class="cpp">row</span> и столбце <span class="cpp">col</span>. Такая запись может
  находиться как в левой, так и в правой части выражения, то есть можно не только получать значения элементов
  матриц, но и присваивать их. По умолчанию проверка индексов не производится, и попытка обратиться к элементу
  матрицы за пределами ее текущего размера вызовет критическую ошибку. Проверку индексов можно включить,
  установив в <a href="um_3_6_7.htm" title="&sect;3.6.7. Параметры модели">параметрах модели</a>
  флажок &laquo;<span class="menu">проверять индексы в массивах и матрицах (медленно)</span>&raquo;), при этом попытка обращения к
  элементу за пределами матрицы оператором &laquo;<span class="cpp">[&nbsp;]</span>&raquo; вызовет остановку расчета и сообщение об
  ошибке. Следует учитывать, что включение этой проверки замедляет работу модели, поэтому проверять индексы в уже
  отлаженной модели следует вручную перед обращением к элементам матрицы. Примеры использования оператора:<br />
  <pre class="cpp">  M[r][c]=2.0;
  double x=M[10][0];
  double y=sin(M[r][c]);</pre></dd>

  <dt><span class="cpp"><i>тип_элемента</i> & <span id="light_ref1">Item</span>(int row,int col)</span></dt>
  <dd>Обращение к элементу матрицы при помощи одной функции. Здесь <span class="cpp">row</span> &ndash; номер строки,
  <span class="cpp">col</span> &ndash; номер столбца (оба номера начинаются с нуля),
  <span class="cpp"><i>тип_элемента</i></span> &ndash; тип элемента матрицы (для матриц вещественных чисел, например,
  это будет тип <span class="cpp">double</span>). Эта функция всегда выполняет проверку допустимости индексов
  независимо от установок параметров модели, поэтому она работает медленнее оператора &laquo;<span class="cpp">[&nbsp;]</span>&raquo;.
  Как и указанный оператор, ее вызов может находиться и в левой, и в правой части выражения. Примеры использования
  функции:<br />
  <pre class="cpp">  M.Item(r,c)=2.0;
  double x=M.Item(10,0);
  double y=sin(M.Item(r,c));</pre></dd>

  <dt><span class="cpp"><a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> <span id="light_ref2">IsEmpty</span>(void)</span></dt>
  <dd>Возвращает <span class="cpp">TRUE</span>, если матрица пустая (0&times;0), и <span class="cpp">FALSE</span>, если
  в ней есть элементы. Пример использования функции:<br />
  <pre class="cpp">  if(M.IsEmpty())
    return; // В матрице нет элементов</pre></dd>

  <dt><span class="cpp"><a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> <span id="light_ref3">HasData</span>(void)</span></dt>
  <dd>Возвращает <span class="cpp">TRUE</span>, если в матрице есть элементы, и <span class="cpp">FALSE</span>,
  если она пустая. Пример использования функции:<br />
  <pre class="cpp">  if(M.HasData()) // Обработка данных матрицы
    { &hellip; }</pre></dd>

  <dt><span class="cpp">int <span id="light_ref4">Cols</span>(void)</span></dt>
  <dd>Число столбцов матрицы. Для пустой матрицы возвращается 0. Пример использования функции:<br />
  <pre class="cpp">  int ncolumns=M.Cols();</pre></dd>

  <dt><span class="cpp">int <span id="light_ref5">Rows</span>(void)</span></dt>
  <dd>Число строк матрицы. Для пустой матрицы возвращается 0. Пример использования функции:<br />
  <pre class="cpp">  int nrows=M.Rows();</pre></dd>

  <dt><span class="cpp"><a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> <span id="light_ref6">Resize</span>(int rows,int cols,<a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> keep=FALSE)</span></dt>
  <dd>Изменяет размер матрицы. Здесь <span class="cpp">rows</span> &ndash; новое число строк матрицы, <span class="cpp">cols</span>
  &ndash; новое число столбцов, необязательный параметр <span class="cpp">keep</span> &ndash; <span class="cpp">TRUE</span>,
  если при изменении размера нужно сохранить текущее содержимое матрицы, и <span class="cpp">FALSE</span>, если ее
  всю нужно заполнить значением элемента по умолчанию. Если параметр <span class="cpp">keep</span> не указан,
  после изменения размера вся матрица будет заполнена значением по умолчанию. Функция возвращает
  <span class="cpp">TRUE</span>, если изменение размера выполнено успешно. В большинстве случаев результат возврата
  функции можно не проверять &ndash; по крайней мере, пока идет работа с матрицами обозримых размеров. Если
  передать в параметрах <span class="cpp">rows</span> и <span class="cpp">cols</span> нулевые значения, матрица
  станет пустой. Примеры использования функции:<br />
  <pre class="cpp">  // Установить размер 3x4
  M.Resize(3,4);
  // Добавить к матрице строку с сохранением содержимого
  M.Resize(M.Rows()+1,M.Cols(),TRUE);
  // Сделать матрицу пустой
  M.Resize(0,0);</pre></dd>

  <dt><span class="cpp"><i>класс_матрицы</i> & operator=(const <i>класс_матрицы</i> &matr)</span></dt>
  <dd>Оператор присваивания, позволяющий копировать одну матрицу в другую (матрицы должны быть одинаковых типов).
  Здесь <span class="cpp"><i>класс_матрицы</i></span> &ndash; имя класса, созданного модулем автокомпиляции для
  матриц данного типа, <span class="cpp">matr</span> &ndash; копируемая матрица. Необходимость полностью скопировать
  одну матрицу в другую возникает достаточно редко, тем не менее, этот оператор позволяет выполнить ее без
  использования цикла по элементам. Следует учитывать, что обе матрицы должны обязательно быть одного и того же
  типа &ndash; нельзя, например, скопировать таким образом матрицу целых чисел в матрицу вещественных.
  Копирование матриц разного типа необходимо производить вручную поэлементно. Пример использования оператора:<br />
  <pre class="cpp">  M1=M; // Скопировать матрицу M в матрицу M1</pre></dd>
</dl>

<p>В качестве примера создадим модель блока, который будет складывать матрицы вещественных чисел, поступающие на его
входы &laquo;<span class="rdsvar">X1</span>&raquo; и &laquo;<span class="rdsvar">X2</span>&raquo; и выдавать результат на выход &laquo;<span class="rdsvar">Y</span>&raquo;. Причем, если
размеры &laquo;<span class="rdsvar">X1</span>&raquo; и &laquo;<span class="rdsvar">X2</span>&raquo; отличаются, будем считать недостающие в них строки и столбцы
заполненными нулями &ndash; таким образом, размер выходной матрицы &laquo;<span class="rdsvar">Y</span>&raquo; будет максимальным из
размеров &laquo;<span class="rdsvar">X1</span>&raquo; и &laquo;<span class="rdsvar">X2</span>&raquo; и по числу строк, и по числу столбцов. Например, складывая
матрицы 2&times;3 и 3&times;2, мы получим на выходе матрицу размером 3&times;3. Наш блок будет иметь следующую
структуру переменных:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td>Start</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">1</td>
  </tr>

  <tr>
    <td>Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>X1</td>
    <td class="center">Матрица double</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">[&nbsp;]&nbsp;0</td>
  </tr>

  <tr>
    <td>X2</td>
    <td class="center">Матрица double</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">[&nbsp;]&nbsp;0</td>
  </tr>

  <tr>
    <td>Y</td>
    <td class="center">Матрица double</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">[&nbsp;]&nbsp;0</td>
  </tr>

</table>
</div></div>

<p><a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">Создадим</a> новый блок с автокомпилируемой моделью, зададим для него
запуск
<a href="um_3_7_2_1.htm#pic2" title="Установка запуска по сигналу в окне параметров блока">по сигналу</a> и введем в его модель эту структуру переменных. На
<a href="um_3_3.htm#pic8" title="Окно редактора пустой модели">вкладке &laquo;<span class="menu">модель</span>&raquo;</a>
в правой части окна редактора введем следующий текст:</p>

<pre class="cpp">  // Локальные переменные
  int maxrows,maxcols;
  double v1,v2;

  // Определение максимального размера матриц X1 и X2
  maxrows=max(X1.<a class="hidden" href="#light_ref5" title="Функция Rows класса матрицы">Rows</a>(),X2.<a class="hidden" href="#light_ref5" title="Функция Rows класса матрицы">Rows</a>());
  maxcols=max(X1.<a class="hidden" href="#light_ref4" title="Функция Cols класса матрицы">Cols</a>(),X2.<a class="hidden" href="#light_ref4" title="Функция Cols класса матрицы">Cols</a>());

  // Задание размера выходной матрицы
  Y.<a class="hidden" href="#light_ref6" title="Функция Resize класса матрицы">Resize</a>(maxrows,maxcols);

  // Цикл по элементам
  for(int r=0;r&lt;maxrows;r++) // r – строка
    for(int c=0;c&lt;maxcols;c++) // c – столбец
      { // v1 – элемент из X1
        if(r&lt;X1.<a class="hidden" href="#light_ref5" title="Функция Rows класса матрицы">Rows</a>() &amp;&amp; c&lt;X1.<a class="hidden" href="#light_ref4" title="Функция Cols класса матрицы">Cols</a>()) // [r,c] – в X1
          v1=X1[r][c];
        else // [r,c] – за пределами X1
          v1=0.0;
        // v2 – элемент из X2
        if(r&lt;X2.<a class="hidden" href="#light_ref5" title="Функция Rows класса матрицы">Rows</a>() &amp;&amp; c&lt;X2.<a class="hidden" href="#light_ref4" title="Функция Cols класса матрицы">Cols</a>()) // [r,c] – в X2
          v2=X2[r][c];
        else // [r,c] – за пределами X2
          v2=0.0;
        // Запись суммы в элемент Y
        Y[r][c]=v1+v2;
      }</pre>

<p>Этот фрагмент программы будет выполняться в каждом такте расчета, перед которым сработали связи, подключенные к
&laquo;<span class="rdsvar">X1</span>&raquo; или &laquo;<span class="rdsvar">X2</span>&raquo; (это обеспечат флажки в колонке
&laquo;<span class="menu">пуск</span>&raquo; напротив этих переменных). Сначала мы записываем во вспомогательную переменную
<span class="cpp">maxrows</span> наибольшее из чисел строк <span class="cpp">X1</span> и <span class="cpp">X2</span>, а в
<span class="cpp">maxcols</span> &ndash; наибольшее из чисел столбцов. Далее, вызывая функцию-член
<span class="cpp"><a href="#light_ref6" title="Функция Resize класса матрицы">Resize</a></span> у выходной матрицы <span class="cpp">Y</span>, мы делаем размер этой матрицы равным
<span class="cpp">maxrows</span>&times;<span class="cpp">maxcols</span>. Матрица <span class="cpp">Y</span> готова,
теперь нужно записать в ее элементы суммы соответствующих элементов матриц <span class="cpp">X1</span> и <span class="cpp">X2</span>.</p>

<p>Может показаться, что для поэлементного суммирования двух матриц и записи результата в третью можно использовать
цикл следующего вида:</p>

<pre class="cpp">  // Цикл по элементам
  for(int r=0;r&lt;maxrows;r++) // r – строка
    for(int c=0;c&lt;maxcols;c++) // c – столбец
      Y[r][c]=X1[r][c]+X2[r][c];</pre>

<p>Это было бы верно, если бы мы ограничились только суммированием матриц одинаковых размеров. Однако, мы решили
при несовпадении размеров матриц дополнять их нулями, поэтому, прежде, чем обращаться к элементу
&laquo;<span class="cpp">X1[r][c]</span>&raquo; или &laquo;<span class="cpp">X2[r][c]</span>&raquo;, нужно проверить, есть ли элемент
(<span class="cpp">r</span>,<span class="cpp">c</span>) в каждой из этих матриц. Действительно, переменная
<span class="cpp">r</span> изменяется от нуля до <span class="cpp">maxrows</span>&minus;1, а <span class="cpp">maxrows</span>
&ndash; это максимальный из двух вертикальных размеров матриц. Если в <span class="cpp">X1</span> будет две строки,
а в <span class="cpp">X2</span> &ndash; три, то <span class="cpp">maxrows</span> будет равно трем, и, когда
<span class="cpp">r</span> примет значение <span class="cpp">maxrows</span>&minus;1, то есть два, выполнение
оператора &laquo;<span class="cpp">X1[r][c]</span>&raquo;, вероятнее всего, вызовет критическую ошибку, поскольку в
<span class="cpp">X1</span> всего две строки с индексами 0 и 1, и элемент <span class="cpp">X1[2][c]</span> в
ней отсутствует. Поэтому в цикле суммируются не непосредственно элементы матриц <span class="cpp">X1</span> и
<span class="cpp">X2</span>, а вспомогательные переменные <span class="cpp">v1</span> и
<span class="cpp">v2</span>, равные элементам соответствующих матриц, если в этих матрицах есть элемент
(<span class="cpp">r</span>,<span class="cpp">c</span>), и нулю в противном случае.</p>

<p>Можно заметить, что в этой модели нет проверки элементов входных матриц на значение
<span class="cpp"><a href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a></span>. Можно не добавлять ее: единственная выполняемая в модели математическая
операция &ndash; это сложение, а сложение значения <span class="cpp">rdsbcppHugeDouble</span> с числом даст в
результате то же самое значение <span class="cpp">rdsbcppHugeDouble</span> (то есть <span class="cpp">HUGE_VAL</span>).</p>

<p>Для тестирования созданной модели следует собрать схему, изображенную
на <a href="#pic1" title="Тестирование модели сложения матриц">рис.&nbsp;367</a>
(перед присоединением связей к созданному блоку необходимо скомпилировать модель, чтобы заданная в ней
структура переменных была записана в этот блок). В этой схеме к входам блока присоединены стандартные библиотечные
блоки ввода матриц вещественных чисел, а к выходу &ndash; стандартный блок отображения таких матриц. Эти блоки
вводят и отображают матрицы в отдельных окнах, которые изображены на рисунке рядом с каждым блоком. Если
теперь задать обе входные матрицы и запустить расчет, в окне выходной матрицы можно будет увидеть их сумму.
На рисунке матрица <span class="cpp">X1</span> имеет размер 2&times;3, а <span class="cpp">X2</span>
&ndash; 3&times;2, поэтому
наш блок сложил эти матрицы, дополнив <span class="cpp">X1</span> нулевой строкой снизу, а
<span class="cpp">X2</span> &ndash; нулевым столбцом справа, и результат получил размер 3&times;3.</p>

<div class="pic"><div class="container" id="pic1">
<img src="../img/AC_matsum_test.png" width="673" height="335" alt="Тестирование модели сложения матриц" />
<p id="light_pic1">Рис.&nbsp;367. Тестирование модели сложения матриц</p>
</div></div>


<p>В описанном примере мы работали с матрицами вещественных чисел, точно так же можно работать с матрицами целых
чисел, логических значений и других простых типов. Модуль автокомпиляции также позволяет использовать в блоках
матрицы сложных типов:
<a href="um_1_4.htm#light_ref10" title="тип переменной: строка">строк</a>,
<a href="um_1_4.htm#light_ref14" title="тип переменной: структура">структур</a> и других матриц. Доступ к этим матрицам осуществляется точно так же,
нужно только иметь в виду, что элемент такой матрицы сам по себе представляет собой сложный тип и имеет свои
собственные функции-члены. Например, если <span class="cpp">Z</span> &ndash;
<b>матрица матриц</b> вещественных чисел,
то допустимы следующие операции:</p>

<pre class="cpp">  // Обращение к элементу [1,2] матрицы, находящейся в Z[3,4]
  double x=Z[3][4][1][2];
  // Задание размера матрицы, находящейся в Z[5,6]
  Z[5][6].<a class="hidden" href="#light_ref6" title="Функция Resize класса матрицы">Resize</a>(3,3);
  // Задание размера Z и ее элемента и заполнение элементов этого элемента
  Z.<a class="hidden" href="#light_ref6" title="Функция Resize класса матрицы">Resize</a>(10,10);     // Задание размера Z
  Z[0][0].<a class="hidden" href="#light_ref6" title="Функция Resize класса матрицы">Resize</a>(5,5); // Задание размера элемента Z[0,0]
  for(int i=0;i&lt;5;i++) // Занесение значений
    for(int j=0;j&lt;5;j++)
       Z[0][0][i][j]=i+j;</pre>

<p>Если элементами матрицы являются структуры, у этих элементов можно обращаться к полям, как и у обычных
переменных-структур. Точно так же, у строк, являющихся элементами матриц, можно вызывать те же функции-члены, что и
у обычных переменных-строк. Работа со структурами и строками  рассмотрена в
<a href="um_3_7_2_4.htm" title="&sect;3.7.2.4. Модели со структурами">&sect;3.7.2.4</a> и <a href="um_3_7_2_5.htm" title="&sect;3.7.2.5. Модели со строками">&sect;3.7.2.5</a> соответственно.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_7_2_1.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_2_3.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_2_2">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
