<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.7.2.3. Модели с массивами</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7_2">&sect;3.7.2. Работа со статическими переменными блока</a></p>
<div class="level"><p>&sect;3.7.2.3. Модели с массивами</p>
</div>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_7_2_2.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_2_4.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_2_3">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</h3>
<h4 class="off">&sect;3.7.2. Работа со статическими переменными блока</h4>
<h5>&sect;3.7.2.3. Модели с массивами</h5>
<p class="abstract">Рассматривается использование массивов в моделях блоков и описываются функции для работы с ними.</p>


<p>Технически, массивы в RDS &ndash; это
<a href="um_3_7_2_2.htm" title="&sect;3.7.2.2. Модели с матрицами">матрицы</a>, состоящие из единственной строки. Они хранятся в памяти
точно так же, как и матрицы, и могут соединяться с матрицами при помощи связей. Однако, с точки зрения
пользователя, массивы отличаются от матриц наличием одного индекса вместо двух: при
<a href="um_2_7_3.htm" title="&sect;2.7.3. Подключение связей к полям структур и элементам массивов">подключении связи к отдельному элементу матрицы</a> вводятся оба индекса элемента
(например, &laquo;<span class="cpp">M[1,2]</span>&raquo;), а при подключении связи к элементу массива &ndash; только один
(например, &laquo;<span class="cpp">A[3]</span>&raquo;).</p>

<p>Чаще всего массивы используются для создания блоков с произвольным числом входов и выходов, обрабатываемых
одинаково. Сумматор, модель которого рассмотрена
в <a href="um_3_3.htm" title="&sect;3.3. Создание нового блока с автокомпилируемой моделью">&sect;3.3</a>, рассчитан только на два входа. Если пользователю потребуется
складывать три числа, придется добавить в блок еще одну статическую переменную
&laquo;<span class="rdsvar">x3</span>&raquo; и изменить модель блока на &laquo;<span class="cpp">y=x1+x2+x3;</span>&raquo;. Гораздо лучше было бы создать
сумматор, число входов которого заранее не задано и определяется числом подсоединенных к нему связей. Этого
можно добиться, сделав вход блока массивом вещественных чисел с нулевым значением элемента по умолчанию и
выдавая на выход сумму всех элементов этого массива. Пользователь при этом сможет подключить столько связей к
отдельным элементам этого входного массива, сколько ему будет нужно &ndash; размер массива будет определяться
самым большим индексом элемента, к которому подключена связь. Если, например, подключить связи к элементам с
номерами 0, 1, 2 и 5, размер массива окажется равным шести (к элементам 3 и 4 связи не подключены, но они
все равно будут присутствовать в массиве). Интерфейс RDS позволяет достаточно просто подключать связи
к последовательным элементам массива &ndash; при присоединении очередной связи пользователю сразу
предлагается следующий, еще не использованный, номер элемента &ndash; поэтому такой сумматор будет удобен
в работе. Создадим такую модель, но сначала разберемся с классами, автоматически создаваемыми для доступа к
массиву, и их функциями-членами.</p>

<p>Классы доступа для массивов в целом похожи на классы матриц, но отличаются от них поддержкой
единственного индекса. В класс блока <span class="cpp">rdsbcppBlockClass</span> добавляется по одному
объекту для каждого массива, имена этих объектов совпадают с именами переменных блока. Для доступа к
конкретному элементу массива используется стандартный синтаксис языка C с квадратными скобками: элемент
<span class="cpp">n</span> массива <span class="cpp">A</span> записывается в программе как
&laquo;<span class="cpp">A[n]</span>&raquo;. Рассмотрим основные функции-члены классов массивов (во всех примерах
предполагается, что <span class="cpp">X</span> и <span class="cpp">Y</span> &ndash; массивы переменных типа
<span class="cpp">double</span>):</p>

<dl>
  <dt><span class="cpp"><i>тип_элемента</i> & operator[](int n)</span></dt>
  <dd>Обращение к элементу массива. Здесь <span class="cpp">n</span> &ndash; целый номер элемента, начинающийся с
  нуля, а <span class="cpp"><i>тип_элемента</i></span> &ndash; тип элемента массива (для матриц вещественных чисел,
  например, это будет тип <span class="cpp">double</span>). Таким образом, &laquo;<span class="cpp">X[n]</span>&raquo; позволяет
  обратиться к элементу массива <span class="cpp">X</span> с номером <span class="cpp">n</span>. Такая запись
  может находиться как в левой, так и в правой части выражения, то есть можно не только получать значения
  элементов массивов, но и присваивать их. Проверка допустимости индекса элемента по умолчанию не производится,
  и попытка обратиться к элементу за пределами текущего размера массива вызовет критическую ошибку. Проверку
  индексов можно включить, установив в <a href="um_3_6_7.htm" title="&sect;3.6.7. Параметры модели">параметрах модели</a> флажок
  &laquo;<span class="menu">проверять индексы в массивах и матрицах (медленно)</span>&raquo;, при этом попытка обращения к элементу
  за пределами массива оператором &laquo;<span class="cpp">[&nbsp;]</span>&raquo; вызовет остановку расчета и сообщение об ошибке.
  Следует учитывать, что включение этой проверки замедляет работу модели, поэтому проверять индексы желательно не
  автоматически, а вручную, перед обращением к элементам массива. Примеры использования оператора:<br />
  <pre class="cpp">  X[n]=2.0;
  double x=X[5];
  double y=sin(X[0]);</pre></dd>

  <dt><span class="cpp"><i>тип_элемента</i> & <span id="light_ref1">Item</span>(int n)</span></dt>
  <dd>Обращение к элементу массива при помощи функции. Здесь <span class="cpp">n</span> &ndash; целый номер
  элемента, начинающийся с нуля, <span class="cpp"><i>тип_элемента</i></span> &ndash; тип элемента массива.
  Эта функция всегда выполняет проверку допустимости индексов независимо от установок параметров модели,
  поэтому она работает медленнее оператора &laquo;<span class="cpp">[&nbsp;]</span>&raquo;. Как и указанный оператор, ее вызов
  может находиться и в левой, и в правой части выражения. Примеры использования функции:<br />
  <pre class="cpp">  X.Item(n)=2.0;
  double x=X.Item(5);
  double y=sin(X.Item(0));</pre></dd>

  <dt><span class="cpp"><a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> <span id="light_ref2">IsEmpty</span>(void)</span></dt>
  <dd>Возвращает <span class="cpp">TRUE</span>, если массив пустой (не содержит элементов), и
  <span class="cpp">FALSE</span> в противном случае. Пример использования функции:<br />
  <pre class="cpp">  if(X.IsEmpty())
    return; // В массиве нет элементов</pre></dd>

  <dt><span class="cpp"><a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> <span id="light_ref3">HasData</span>(void)</span></dt>
  <dd>Возвращает <span class="cpp">TRUE</span>, если в массиве есть элементы, и <span class="cpp">FALSE</span>,
  если он пустой. Пример использования функции:<br />
  <pre class="cpp">  if(X.HasData()) // Обработка элементов массива
    { &hellip; }</pre></dd>

  <dt><span class="cpp">int <span id="light_ref4">Size</span>(void)</span></dt>
  <dd>Число элементов в массиве. Для пустого массива возвращается 0. Пример использования функции:<br />
  <pre class="cpp">  // Суммирование элементов
  double s=0.0;
  for(int i=0;i&lt;X.Size();i++)
    s+=X[i];</pre></dd>

  <dt><span class="cpp"><a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> <span id="light_ref5">Resize</span>(int size,<a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> keep=FALSE)</span></dt>
  <dd>Изменяет размер массива. Здесь <span class="cpp">size</span> &ndash; новое число элементов, необязательный
  параметр <span class="cpp">keep</span> &ndash; <span class="cpp">TRUE</span>, если при изменении размера
  нужно сохранить текущее содержимое массива, и <span class="cpp">FALSE</span>, если его нужно заполнить значением
  элемента по умолчанию. Если параметр <span class="cpp">keep</span> не указан, после изменения размера весь массив
  будет заполнен значением по умолчанию. Функция возвращает <span class="cpp">TRUE</span>, если изменение размера
  выполнено успешно (если не пытаться создавать массивы огромных размеров, не умещающиеся в память, результат
  возврата функции можно не проверять). Если передать в параметре <span class="cpp">size</span> нулевое значение,
  массив станет пустым. Примеры использования функции:<br />
  <pre class="cpp">  // Установить размер в три элемента
  X.Resize(3);
  // Добавить в конец массива три новых элемента
  X.Resize(X.Size()+3,TRUE);
  // Очистить массив
  X.Resize(0);</pre></dd>

  <dt><span class="cpp"><i>класс_массива</i> & operator=(const <i>класс_массива</i> &arr)</span></dt>
  <dd>Оператор присваивания, позволяющий копировать один массив в другой (оба должны иметь элементы
  одинаковых типов). Здесь <span class="cpp"><i>класс_массива</i></span> &ndash; имя класса, созданного
  модулем автокомпиляции для массивов
  с данным типом элементов, <span class="cpp">arr</span> &ndash; копируемый массив. Следует учитывать, что
  оба массива должны обязательно быть одного и того же типа &ndash; нельзя, например, скопировать таким образом
  массив целых чисел в массив вещественных (копирование массивов разного типа необходимо производить вручную
  поэлементно). Пример использования оператора:<br />
  <pre class="cpp">  Y=X; // Скопировать массив X в массив Y</pre></dd>

</dl>

<p>Рассмотрев функции, с помощью которых можно работать с массивами, создадим модель сумматора с произвольным
числом входов, использующего входной массив вещественных чисел. Наш блок будет иметь следующую структуру
переменных:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td>Start</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">1</td>
  </tr>

  <tr>
    <td>Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>X</td>
    <td class="center">Массив double</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">[&nbsp;]&nbsp;0</td>
  </tr>

  <tr>
    <td>y</td>
    <td class="center">double</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

</table>
</div></div>

<p><a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">Создадим</a> новый блок с автокомпилируемой моделью, зададим для него запуск
по сигналу и введем в его модель эту структуру переменных. На
<a href="um_3_3.htm#pic8" title="Окно редактора пустой модели">вкладке &laquo;<span class="menu">модель</span>&raquo;</a>
в правой части окна редактора введем следующий текст:</p>

<pre class="cpp">  y=0.0;
  for(int i=0;i&lt;X.<a class="hidden" href="#light_ref4" title="Функция Size класса массива">Size</a>();i++)
    y+=X[i];</pre>

<p>Модель получилась очень простой: сначала мы обнуляем выход <span class="cpp">y</span>, а затем, в цикле,
по очереди добавляем к нему все элементы входного массива <span class="cpp">X</span>. Введенный нами фрагмент
программы будет выполнен при первом запуске расчета (начальное значение сигнала запуска <span class="cpp">Start</span>
&ndash; единица), а также при срабатывании любой связи, соединенной с входом <span class="cpp">X</span>
или с каким-либо его отдельным элементом (это обеспечит флажок в колонке &laquo;<span class="menu">пуск</span>&raquo; напротив входа
<span class="cpp">X</span>). Здесь, как и в примере модели, работающей с матрицами
(см. <a href="um_3_7_2_2.htm" title="&sect;3.7.2.2. Модели с матрицами">&sect;3.7.2.2</a>), мы не сравниваем элементы входного массива со
значением <span class="cpp"><a href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a></span> &ndash; для операции сложения это не обязательно.</p>

<div class="picright"><div class="container" id="pic1">
<img src="../img/AC_arraysum_test.png" width="180" height="98" alt="Тестирование модели сумматора с входом-массивом" />
<p id="light_pic1">Рис.&nbsp;368. Тестирование модели<br />сумматора с входом-массивом</p>
</div></div>


<p>Для тестирования созданной модели можно собрать схему, изображенную
на <a href="#pic1" title="Тестирование модели сумматора с входом-массивом">рис.&nbsp;368</a>,
в которой к отдельным элементам массива &laquo;<span class="rdsvar">X</span>&raquo; подключены поля ввода. Если запустить расчет,
на индикаторе, подключенном к выходу &laquo;<span class="rdsvar">y</span>&raquo;, появится сумма элементов массива. Для того, чтобы
к блоку было удобнее подключать связи, параметры его внешнего вида изменены: в
<a href="um_2_9_1.htm#pic5" title="Вкладка внешний вид окна параметров простого блока при выбранном изображении картинкой (картинка отсутствует)">окне параметров</a>
для него было назначено изображение в виде прямоугольника с
текстом (в данном случае текст пустой) и разрешено масштабирование, после чего его вертикальный размер
был увеличен.</p>

<div class="picright"><div class="container" id="pic2">
<img src="../img/AC_arraysum_test1.png" width="413" height="158" alt="Матрица на входе-массиве" />
<p id="light_pic2">Рис.&nbsp;369. Матрица на входе-массиве</p>
</div></div>


<p>Созданную нами модель можно использовать не только для суммирования чисел, поданных по связям на отдельные
элементы массива. Поскольку в RDS разрешается соединять связями массивы и матрицы, мы можем подать на
вход нашего блока какую-либо матрицу или массив с выхода другого блока &ndash; например, с выхода
стандартного библиотечного блока ввода матрицы
(<a href="#pic2" title="Матрица на входе-массиве">рис.&nbsp;369</a>).
В этом случае наша модель вычислит сумму всех элементов матрицы, даже если в ней не одна строка, а
несколько: внутри модели матрица будет считаться одним длинным массивом. Например, если мы подадим на вход
блока матрицу размером 2&times;3 элемента, мы получим массив размером в шесть элементов.</p>

<p>В приведенном выше примере мы имели дело с массивом-входом, размер которого задается без нашего участия:
его определяет либо число связей, подключенных к элементам массива, как
на <a href="#pic1" title="Тестирование модели сумматора с входом-массивом">рис.&nbsp;368</a>,
либо размер массива или матрицы на выходе блока, соединенного связью со всем входом &laquo;<span class="rdsvar">X</span>&raquo;, как
на <a href="#pic2" title="Матрица на входе-массиве">рис.&nbsp;369</a>.
Рассмотрим теперь модель, в которой размер массива-выхода мы будем задавать самостоятельно.
<span id="ref6">Создадим модель</span>
<span id="light_ref6">блока-демультиплексора</span>, выходом которого будет массив вещественных чисел &laquo;<span class="rdsvar">Y</span>&raquo;. Блок будет
иметь целый вход &laquo;<span class="rdsvar">N</span>&raquo; и вещественный вход &laquo;<span class="rdsvar">x</span>&raquo;, в процессе работы он
будет копировать значение &laquo;<span class="rdsvar">x</span>&raquo; в элемент выходного массива с номером, определяемым входом
&laquo;<span class="rdsvar">N</span>&raquo;.</p>

<p>Блок будет иметь следующую структуру переменных:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td>Start</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">1</td>
  </tr>

  <tr>
    <td>Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>x</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>N</td>
    <td class="center">int</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>Y</td>
    <td class="center">Массив double</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">[&nbsp;]&nbsp;0</td>
  </tr>

</table>
</div></div>

<p><a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">Создадим</a> новый блок с автокомпилируемой моделью, зададим для него запуск
по сигналу и введем в его модель эту структуру переменных. На
<a href="um_3_3.htm#pic8" title="Окно редактора пустой модели">вкладке &laquo;<span class="menu">модель</span>&raquo;</a>
в правой части окна редактора введем следующий текст:</p>

<pre class="cpp">  if(N&lt;0) return; // Недопустимый номер
  // Проверка и увеличение размера массива
  if(Y.<a class="hidden" href="#light_ref4" title="Функция Size класса массива">Size</a>()&lt;N+1)
    Y.<a class="hidden" href="#light_ref5" title="Функция Resize класса массива">Resize</a>(N+1,TRUE);
  // Запись x в элемент массива N
  Y[N]=x;</pre>

<p>Введенный нами фрагмент программы, как и в предыдущей модели, будет выполнен при первом запуске расчета
(начальное значение
<a href="um_1_4.htm#ref25" title="Сигнал запуска блока">сигнала запуска</a>
<span class="cpp">Start</span> &ndash; единица), а также при срабатывании любой связи, соединенной с входами
блока (это обеспечат флажки в колонке &laquo;<span class="menu">пуск</span>&raquo; у обоих входов).</p>

<p>Первым оператором мы принудительно завершаем модель при отрицательных <span class="cpp">N</span> &ndash;
элементы массива не имеют отрицательных номеров. Затем мы проверяем, есть ли на данный момент элемент с
номером <span class="cpp">N</span> в массиве <span class="cpp">Y</span>: чтобы он существовал, размер массива
<span class="cpp">Y.<a href="#light_ref4" title="Функция Size класса массива">Size</a>()</span> должен быть не меньше <span class="cpp">N+1</span> (если в массиве,
например, три элемента, самый последний его элемент имеет номер два, поскольку номера начинаются с нуля:
0, 1, 2). Если размер массива окажется меньше, мы принудительно устанавливаем его в
<span class="cpp">N+1</span>, вызывая у объекта <span class="cpp">Y</span> функцию-член
<span class="cpp"><a href="#light_ref5" title="Функция Resize класса массива">Resize</a></span>. Во втором параметре этой функции передано
значение <span class="cpp">TRUE</span>, чтобы при увеличении размера массива его старое содержимое
сохранилось, а не было заменено на значение по умолчанию. После этого мы просто присваиваем элементу
<span class="cpp">Y[N]</span> значение <span class="cpp">x</span>. В этой модели не нужно никаких проверок
входного значения <span class="cpp">x</span> на равенство значению-индикатору ошибки
<span class="cpp"><a href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a></span>: модель вообще не выполняет никаких математических вычислений, а
просто переписывает на выход значение со своего входа.</p>

<div class="picright"><div class="container" id="pic3">
<img src="../img/AC_switch_test.png" width="226" height="94" alt="Тестирование модели демультиплексора" />
<p id="light_pic3">Рис.&nbsp;370. Тестирование<br />модели демультиплексора</p>
</div></div>


<p>Для тестирования модели можно собрать схему, изображенную
на <a href="#pic3" title="Тестирование модели демультиплексора">рис.&nbsp;370</a>.
Здесь, как и в прошлом примере, размер нашего блока увеличен, чтобы к нему удобнее было подключать связи.
К отдельным элементам массива &laquo;<span class="rdsvar">Y</span>&raquo; подключены индикаторы, к входам &laquo;<span class="rdsvar">x</span>&raquo; и
&laquo;<span class="rdsvar">N</span>&raquo; &ndash; поля ввода. Если запустить расчет и изменять значение на входе &laquo;<span class="rdsvar">x</span>&raquo;,
можно будет увидеть, что вместе с ним изменяется значение того индикатора, который подключен к элементу массива
с номером &laquo;<span class="rdsvar">N</span>&raquo;.</p>

<p>Созданная нами модель имеет один недостаток: независимо от значения &laquo;<span class="rdsvar">N</span>&raquo;, при ее
срабатывании активируются все ее выходные связи. Так устроена логика работы блоков и связей в
RDS &ndash; перед выполнением реакции блока на такт расчета его
<a href="um_1_4.htm#ref27" title="Сигнал готовности блока">сигнал готовности</a>
&laquo;<span class="rdsvar">Ready</span>&raquo; получает единичное значение, а в конце такта для всех блоков с ненулевыми
сигналами готовности запускается передача выходов по связям
(см. <a href="um_1_3.htm#ref4" title="Такт расчета">&sect;1.3</a>). В схеме на <a href="#pic3" title="Тестирование модели демультиплексора">рис.&nbsp;370</a>
к выходам блока подключены индикаторы, поэтому это не важно: многократного повторного срабатывания
&laquo;лишних&raquo; связей мы не заметим, поскольку по ним будут передаваться те же самые числа.
В частности, по связям, идущим от &laquo;<span class="rdsvar">Y[0]</span>&raquo; и &laquo;<span class="rdsvar">Y[2]</span>&raquo;> при каждом изменении
&laquo;<span class="rdsvar">x</span>&raquo; будут повторно передаваться нули, несмотря на то, что &laquo;<span class="rdsvar">N</span>&raquo;
на рисунке равно единице. Но лучше подавлять передачу ненужных данных: во-первых, это ускоряет работу
схемы, поскольку не активируются модели подключенных к &laquo;лишним&raquo; связям цепочек блоков,
во-вторых, некоторые сложные блоки реагируют не только на число, пришедшее по связи, но и на факт
ее срабатывания. В <a href="um_3_7_2_8.htm" title="&sect;3.7.2.8. Использование выходов с управляющими переменными">&sect;3.7.2.8</a> мы изменим нашу модель так, чтобы на
выходе блока срабатывала только одна связь &ndash; та, которая подключена к элементу массива,
соответствующему текущему значению &laquo;<span class="rdsvar">N</span>&raquo;.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_7_2_2.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_2_4.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_2_3">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
