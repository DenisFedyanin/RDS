<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.7.2.4. Модели со структурами</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7_2">&sect;3.7.2. Работа со статическими переменными блока</a></p>
<div class="level"><p>&sect;3.7.2.4. Модели со структурами</p>
</div>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_7_2_3.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_2_5.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_2_4">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</h3>
<h4 class="off">&sect;3.7.2. Работа со статическими переменными блока</h4>
<h5>&sect;3.7.2.4. Модели со структурами</h5>
<p class="abstract">Рассматривается использование структур в моделях блоков.</p>


<p>Структуры используются в тех случаях, когда необходимо передавать от блока к блоку несколько значений
одновременно. Можно, конечно, сделать все эти значения отдельными выходами и входами блоков, но при этом
пользователю придется проводить большое количество параллельных связей, которые, во-первых,
загромоздят схему, и, во-вторых, повысят вероятность совершения ошибки: если пользователь забудет
провести одну из этих связей, схема не будет работать, а обнаружить эту пропущенную связь в сложной схеме
может оказаться не очень просто. В том случае, если все передаваемые значения имеют один и тот же тип,
для этого можно использовать массив или матрицу. Например, в блоках, обрабатывающих трехмерные векторы,
можно сделать входами и выходами массивы вещественных чисел. Однако, при этом разработчик модели такого блока
должен все время контролировать размер массива на входе (он должен всегда содержать три элемента) и помнить,
какой номер элемента какой именно координате вектора соответствует. Соответствие координат номерам элементов
массива нужно помнить и пользователю, который будет работать с этими блоками: чтобы вывести на индикацию
нужную ему координату, пользователь должен подключить индикатор к элементу массива с соответствующим ей
номером. Если же кроме вещественных чисел между блоками должна передаваться какая-либо еще информация
(например, единица измерения вектора или его текстовое название), передавать данные массивом уже не получится
&ndash; все элементы массива должны иметь один и тот же тип.</p>

<p>Для одновременной передачи разнородных данных, каждый элемент которых имеет свое собственное имя, в
RDS используются <a href="um_2_14.htm" title="&sect;2.14. Создание и изменение структур">структуры</a>. Структуры состоят из полей,
которым можно дать имена, отражающие их назначение: например, структура, описывающая трехмерный вектор,
может иметь поля с именами &laquo;<span class="rdsvar">x</span>&raquo;, &laquo;<span class="rdsvar">y</span>&raquo; и &laquo;<span class="rdsvar">z</span>&raquo;, по названиям
координатных осей. Запись &laquo;<span class="rdsvar">v1.x</span>&raquo; при этом гораздо более удобна и информативна для пользователя,
чем &laquo;<span class="rdsvar">v1[0]</span>&raquo;, которую пришлось бы использовать при передаче векторов через массив. Поля
структур могут иметь любой тип, кроме <a href="um_3_7_2_3.htm" title="&sect;3.7.2.3. Модели с массивами">массива</a>
(вместо массивов можно использовать <a href="um_3_7_2_2.htm" title="&sect;3.7.2.2. Модели с матрицами">матрицы</a>) &ndash; ими
могут быть вещественные числа, строки, матрицы и другие структуры. В программе модели и при присоединении
связей имя поля структуры отделяется от имени переменной, имеющей структурный тип, точкой, как принято в языке C:
обращение к полю &laquo;<span class="rdsvar">x</span>&raquo; структуры, находящейся в переменной &laquo;<span class="rdsvar">v</span>&raquo;, записывается как
&laquo;<span class="cpp">v.x</span>&raquo;. Перед первым использованием структуры в блоке ее необходимо описать в RDS при
помощи пункта главного меню &laquo;<span class="menu">система | структуры</span>&raquo; &ndash; необходимые для этого действия подробно
рассмотрены в <a href="um_2_14.htm" title="&sect;2.14. Создание и изменение структур">&sect;2.14</a>. Если в схеме уже есть хотя бы один блок,
использующий данную структуру, описывать ее не нужно: описание структуры автоматически загружается вместе
с любым блоком, использующим ее.</p>

<p>Технически работа со структурами в автокомпилируемых моделях устроена так: для любой структуры,
использованной в качестве типа какой-либо переменной блока, модуль автокомпиляции создает в программе модели
специальный класс доступа, содержащий внутри себя все поля этой структуры, и добавляет в класс блока
<span class="cpp">rdsbcppBlockClass</span> по одному объекту этого созданного класса для каждой
переменной-структуры с таким типом. Имена этих объектов совпадают с именами переменных блока. В результате к
полям структуры внутри фрагментов программ, вводимых пользователем, можно обращаться, как и было указано выше,
через точку: &laquo;<span class="cpp"><i>имя_переменной</i>.<i>имя_поля</i></span>&raquo;, где
<span class="cpp"><i>имя_переменной</i></span> &ndash; это имя созданного внутри класса блока объекта для
переменной, а <span class="cpp"><i>имя_поля</i></span> &ndash; имя поля специального класса доступа,
созданного для поля структуры.</p>

<p>В качестве первого примера создадим собственную структуру для хранения трехмерного вектора и модель блока,
который будет складывать два таких вектора. Начнем с описания структуры. Назовем ее &laquo;<span class="rdsvar">Vector3D</span>&raquo;, и
создадим в ней три вещественных поля: &laquo;<span class="rdsvar">x</span>&raquo;, &laquo;<span class="rdsvar">y</span>&raquo; и &laquo;<span class="rdsvar">z</span>&raquo;. Чтобы
добавить в RDS новую структуру, нужно выполнить следующие шаги:</p>

<ul>
  <li>в режиме редактирования (должна быть загружена какая-либо схема или создана новая) выбрать пункт
  главного меню &laquo;<span class="menu">система | структуры</span>&raquo; &ndash; откроется
  <a href="um_2_14.htm#pic1" title="Окно списка структур">окно</a>
  со списком уже имеющихся в RDS структур;</li>

  <li>в окне структур нажать на кнопку со знаком &laquo;<span class="menu">+</span>&raquo; в правой части окна &ndash; откроется пустое
  <a href="um_2_14.htm#pic2" title="Окно редактирования структуры">окно</a> редактирования структуры;</li>

  <li>ввести в окне редактирования имя типа структуры &laquo;<span class="rdsvar">Vector3D</span>&raquo; и заполнить список полей
  согласно <a href="#pic1" title="Структура Vector3D в окне редактирования структуры">рис.&nbsp;371</a>;</li>

  <li>закрыть окно редактирования структуры кнопкой &laquo;<span class="menu">OK</span>&raquo;;</li>

  <li>закрыть окно списка структур кнопкой &laquo;<span class="menu">OK</span>&raquo;.</li>
</ul>

<div class="pic"><div class="container" id="pic1">
<img src="../img/AC_struct_vector3d.png" width="600" height="289" alt="Структура Vector3D в окне редактирования структуры" />
<p id="light_pic1">Рис.&nbsp;371. Структура &laquo;<span class="rdsvar">Vector3D</span>&raquo; в окне редактирования структуры</p>
</div></div>


<p>Теперь в текущей загруженной схеме есть структура с именем &laquo;<span class="rdsvar">Vector3D</span>&raquo; и тремя
вещественными полями. Это имя будет появляться в выпадающем списке типов при задании структуры переменных
блока.</p>

<p>Создадим модель блока, который будет суммировать два трехмерных вектора, поступивших на входы
&laquo;<span class="rdsvar">v1</span>&raquo; и &laquo;<span class="rdsvar">v2</span>&raquo;, и выдавать результат на выход &laquo;<span class="rdsvar">sum</span>&raquo;. Он будет
иметь следующую структуру переменных:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td>Start</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">1</td>
  </tr>

  <tr>
    <td>Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>v1</td>
    <td class="center">Vector3D</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">{0, 0, 0}</td>
  </tr>

  <tr>
    <td>v2</td>
    <td class="center">Vector3D</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">{0, 0, 0}</td>
  </tr>

  <tr>
    <td>sum</td>
    <td class="center">Vector3D</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">{0, 0, 0}</td>
  </tr>

</table>
</div></div>

<p><a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">Создадим</a> новый блок с автокомпилируемой моделью, зададим для него запуск
по сигналу и введем в его модель эту структуру переменных. На
<a href="um_3_3.htm#pic8" title="Окно редактора пустой модели">вкладке &laquo;<span class="menu">модель</span>&raquo;</a>
в правой части окна редактора введем следующий текст:</p>

<pre class="cpp">  sum.x=v1.x+v2.x;
  sum.y=v1.y+v2.y;
  sum.z=v1.z+v2.z;</pre>

<p>Здесь мы просто складываем одноименные поля структур в переменных <span class="cpp">v1</span> и <span class="cpp">v2</span>
и присваиваем результат полю переменной <span class="cpp">sum</span> с этим же именем. Имена полей отделяются от
имен переменных точками. Как и во всех предыдущих примерах, наша модель будет запускаться автоматически при
срабатывании любой связи, подключенной к входам &laquo;<span class="rdsvar">v1</span>&raquo; и &laquo;<span class="rdsvar">v2</span>&raquo; (в колонке
&laquo;<span class="menu">пуск</span>&raquo; для этих входов установлены флажки).</p>

<div class="picright"><div class="container" id="pic2">
<img src="../img/AC_vectorsum_test1.png" width="231" height="153" alt="Тестирование модели сложения векторов" />
<p id="light_pic2">Рис.&nbsp;372. Тестирование<br />модели сложения векторов</p>
</div></div>


<p>Для тестирования модели можно собрать схему, изображенную
на <a href="#pic2" title="Тестирование модели сложения векторов">рис.&nbsp;372</a>
(для того, чтобы к блоку было удобнее подключать связи, ему был назначен внешний вид в
виде прямоугольника с текстом, после чего его размер был увеличен). Запустив расчет, можно убедиться,
что векторы покомпонентно просуммированы. Может показаться, что сделав входы и выход блока структурами,
мы ничего не добились: к блоку все равно подключено большое количество связей &ndash; по одной связи на
каждое поле каждой структуры. Однако, это произошло только потому, что у нас нет стандартного блока,
позволяющего ввести или отобразить созданную нами структуру, и мы вынуждены использовать обычные вещественные
поля ввода и индикаторы, подключая их к отдельным полям структур на входах и выходе нашего блока. Если бы у
нас были такие блоки (их можно, при желании, создать), к блоку подходило бы всего три связи: по одной от
гипотетических блоков ввода векторов, и одна &ndash; к блоку индикации вектора.</p>

<div class="picright"><div class="container" id="pic3">
<img src="../img/AC_vectorsum_test2.png" width="311" height="259" alt="Сложение четырех векторов" />
<p id="light_pic3">Рис.&nbsp;373. Сложение четырех векторов</p>
</div></div>


<p>Соберем еще одну схему
(<a href="#pic3" title="Сложение четырех векторов">рис.&nbsp;373</a>),
в которой будем складывать четыре вектора при помощи трех блоков с созданной нами моделью. Уже
созданный блок можно размножить, копируя его в буфер обмена клавишами
<span class="keys">Ctrl</span>&nbsp;+&nbsp;<span class="keys">C</span> и вставляя оттуда клавишами <span class="keys">Ctrl</span>&nbsp;+&nbsp;<span class="keys">V</span>, при этом на
<a href="um_3_5.htm#pic2" title="Запрос, выдающийся пользователю при вставке блока с автокомпилируемой моделью из буфера обмена">запрос модуля автокомпиляции</a>
о том, нужно ли создавать новую модель для копии блока, следует отвечать
&laquo;<span class="menu">использовать тот же файл модели</span>&raquo;. В новой схеме четыре вектора разбиты на две пары:
сначала два блока слева складывают векторы внутри каждой пары, а затем точно такой же блок справа складывает
получившиеся суммы между собой. Можно заметить, что от каждого из двух левых блоков-сумматоров к правому
идет только одна связь: &laquo;sum &rarr; v1&raquo; и &laquo;sum &rarr; v2&raquo;. Каждая из этих
связей передает всю трехкомпонентную структуру &laquo;<span class="rdsvar">Vector3D</span>&raquo;, и это значительно удобнее,
чем передавать все три ее поля отдельными связями.</p>

<p>Суммировать несколько векторов, строя из сумматоров каскады, как
на <a href="#pic3" title="Сложение четырех векторов">рис.&nbsp;373</a>,
не очень удобно, поэтому сделаем еще одну модель сумматора векторов, входом которого будет
<a href="um_3_7_2_3.htm" title="&sect;3.7.2.3. Модели с массивами">массив</a>
структур
&laquo;<span class="rdsvar">Vector3D</span>&raquo;. Так мы сможем проиллюстрировать обращение к полям структур, являющихся
элементами массивов. Назовем вход нашего блока &laquo;<span class="rdsvar">V</span>&raquo;, а выход &ndash; &laquo;<span class="rdsvar">sum</span>&raquo;.
Если мы будем создавать этот блок в той же схеме, в которой мы работали с предыдущим, описывать структуру
&laquo;<span class="rdsvar">Vector3D</span>&raquo; не понадобится, поскольку она в этой схеме уже есть. Если создавать новый блок в
новой схеме, нужно либо повторить в ней описание структуры, либо просто вставить в нее (например, из
буфера обмена) уже созданный нами ранее блок, использующий эту структуру (структура при этом вставится в
схему вместе с блоком). Потом этот блок можно стереть, описание структуры останется в схеме.</p>

<p class="clear">Наш новый блок будет иметь следующую структуру переменных:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td>Start</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">1</td>
  </tr>

  <tr>
    <td>Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>V</td>
    <td class="center">Массив Vector3D</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">[&nbsp;]&nbsp;{0, 0, 0}</td>
  </tr>

  <tr>
    <td>sum</td>
    <td class="center">Vector3D</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">{0, 0, 0}</td>
  </tr>

</table>
</div></div>

<p><a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">Создадим</a> уже неоднократно описывавшимся способом новый блок с
автокомпилируемой модельюи зададим в этой модели приведенную выше структуру переменных. На вкладке
&laquo;<span class="menu">модель</span>&raquo; редактора введем следующий текст:</p>

<pre class="cpp">  // Обнуление перед суммированием
  sum.x=sum.y=sum.z=0;
  // Сложение векторов в цикле
  for(int i=0;i&lt;V.<a class="hidden" href="um_3_7_2_3.htm#light_ref4" title="Функция Size класса массива">Size</a>();i++)
    { sum.x+=V[i].x;
      sum.y+=V[i].y;
      sum.z+=V[i].z;
    }</pre>

<p>Здесь мы сначала обнуляем все три поля выхода блока, а затем, в цикле по всем элементам массива,
добавляем к ним одноименные поля элементов этого массива. Обращение к полю
<span class="cpp">x</span> элемента <span class="cpp">i</span> массива <span class="cpp">V</span> при этом
выглядит обычным для языка C образом: &laquo;<span class="cpp">V[i].x</span>&raquo;.</p>

<div class="picright"><div class="container" id="pic4">
<img src="../img/AC_vectorsum_test3.png" width="212" height="224" alt="Сложение массива векторов" />
<p id="light_pic4">Рис.&nbsp;374. Сложение<br />массива векторов</p>
</div></div>


<p>Для тестирования модели соберем схему, изображенную
на <a href="#pic4" title="Сложение массива векторов">рис.&nbsp;374</a>.
На ней девять полей ввода слева подключены к полям отдельных элементов входного массива &laquo;<span class="rdsvar">V</span>&raquo;.
Эти поля не будут появляться в меню присоединения связи к блоку, поскольку они находятся слишком
&laquo;глубоко&raquo; в иерархии переменных, поэтому при присоединении связи необходимо будет выбирать в
меню пункт &laquo;<span class="menu">список</span>&raquo; и вручную вводить имена &laquo;<span class="rdsvar">V[0].x</span>&raquo;, &laquo;<span class="rdsvar">V[0].y</span>&raquo; и т.д.
(см. <a href="um_2_7_3.htm" title="&sect;2.7.3. Подключение связей к полям структур и элементам массивов">&sect;2.7.3</a>). Это снова происходит из-за того, что у нас нет
стандартного блока для ввода нашей структуры и мы вынуждены пользоваться обычными вещественными полями ввода.
Если бы наш сумматор получал данные с выходов других блоков, имеющих тип &laquo;<span class="rdsvar">Vector3D</span>&raquo;,
присоединять связи было бы проще &ndash; открывалось бы окно выбора элемента массива с заранее установленным
первым свободным номером.</p>

<p>В обоих примерах полями структуры были вещественные числа. Если бы полями были другие структуры или матрицы,
индексы элементов матриц или поля этих вложенных структур записывались бы, как обычно, после имени поля-структуры
или поля-матрицы. Представим себе, например, некоторую структуру с именем &laquo;<span class="rdsvar">SomeStruct</span>&raquo;, имеющую
поля &laquo;<span class="rdsvar">vector</span>&raquo; типа &laquo;<span class="rdsvar">Vector3D</span>&raquo; и &laquo;<span class="rdsvar">vmatr</span>&raquo; типа
&laquo;<span class="rdsvar">матрица Vector3D</span>&raquo; (<a href="#pic5" title="Гипотетическая структура SomeStruct">рис.&nbsp;375</a>).</p>

<div class="pic"><div class="container" id="pic5">
<img src="../img/AC_somestruct.png" width="600" height="286" alt="Гипотетическая структура SomeStruct" />
<p id="light_pic5">Рис.&nbsp;375. Гипотетическая структура &laquo;<span class="rdsvar">SomeStruct</span>&raquo;</p>
</div></div>


<p>Пусть в каком-либо блоке с автокомпилируемой моделью есть переменная &laquo;<span class="rdsvar">var</span>&raquo; типа
&laquo;<span class="rdsvar">SomeStruct</span>&raquo;. В программе модели этого блока к отдельным полям и элементам этой сложной
переменной можно обращаться следующим образом:</p>

<ul>
  <li>&laquo;<span class="cpp">var.vector</span>&raquo; &ndash; поле <span class="cpp">vector</span> переменной
  <span class="cpp">var</span> (это поле будет структурой типа &laquo;<span class="rdsvar">Vector3D</span>&raquo;);</li>

  <li>&laquo;<span class="cpp">var.vector.y</span>&raquo; &ndash; вещественное поле <span class="cpp">y</span> структуры, находящейся в поле
  <span class="cpp">vector</span> переменной <span class="cpp">var</span>;</li>

  <li>&laquo;<span class="cpp">var.vmatr[1][2]</span>&raquo; &ndash; структура типа &laquo;<span class="rdsvar">Vector3D</span>&raquo;, находящаяся в строке
  1 и столбце 2 матрицы из поля <span class="cpp">vmatr</span> переменной <span class="cpp">var</span>;</li>

  <li>&laquo;<span class="cpp">var.vmatr.<a class="hidden" href="um_3_7_2_2.htm#light_ref5" title="Функция Rows класса матрицы">Rows</a>()</span>&raquo;
  &ndash; число строк матрицы, находящейся в поле <span class="cpp">vmatr</span> переменной
  <span class="cpp">var</span>;</li>

  <li>&laquo;<span class="cpp">var.vmatr[1][2].x</span>&raquo; &ndash; вещественное поле <span class="cpp">x</span> структуры типа
  &laquo;<span class="rdsvar">Vector3D</span>&raquo;, находящейся в строке 1 и столбце 2 матрицы из поля <span class="cpp">vmatr</span>
  переменной <span class="cpp">var</span>;</li>

  <li>и т.д.</li>
</ul>

<p>Таким образом, способ обращения к полям структур во всех этих случаях ничем не отличается от
стандартного синтаксиса языка C/C++.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_7_2_3.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_2_5.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_2_4">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
