<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.7.2.5. Модели со строками</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7_2">&sect;3.7.2. Работа со статическими переменными блока</a></p>
<div class="level"><p>&sect;3.7.2.5. Модели со строками</p>
</div>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_7_2_4.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_2_6.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_2_5">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</h3>
<h4 class="off">&sect;3.7.2. Работа со статическими переменными блока</h4>
<h5>&sect;3.7.2.5. Модели со строками</h5>
<p class="abstract">Рассматривается использование текстовых строк в переменных автокомпилируемых блоков. Описываются операторы и функции-члены класса для работы со строками.</p>


<p><a href="um_1_4.htm#light_ref10" title="тип переменной: строка">Строки</a>
используются в качестве переменных блоков достаточно редко. Как правило, схемы, собираемые в
RDS, предназначены для моделирования каких-либо технических процессов, в которых главную роль играют
операции с числами, массивами и матрицами, которые могут сами быть входами и выходами блоков или содержаться внутри
каких-либо структур. Тем не менее, RDS позволяет передавать строки по связям и работать с ними в
моделях блоков. Чаще всего переменные-строки используются в блоках, отображающих какие-либо данные при помощи своих
<a href="um_2_10_1.htm" title="&sect;2.10.1. Общие сведения о редакторе картинки">векторных картинок</a>:
<a href="um_2_10_5.htm" title="&sect;2.10.5. Создание строк и блоков текста">блоки текста</a>, являющиеся графическими элементами
таких векторных картинок, могут быть связаны с переменными блока и автоматически отображать их значения.
Если связать такой текстовый блок с переменной-строкой, на нем можно будет выводить любой текст по желанию
разработчика модели, для этого достаточно присвоить нужный текст этой переменной.</p>

<p><span id="ref1">Для</span>
работы со строками в автокомпилируемых моделях используется специальный класс с именем
<span class="cpp" id="light_ref1">rdsbcppString</span>. Для каждой переменной-строки в класс блока
<span class="cpp">rdsbcppBlockClass</span> добавляется по одному объекту класса <span class="cpp">rdsbcppString</span>,
через который и осуществляется работа с этой переменной. Имена этих объектов совпадают с именами переменных
блока, поэтому внутри фрагментов программ, вводимых пользователем, к строкам, являющимся статическими переменными
блока, можно обращаться просто по именам. Класс <span class="cpp">rdsbcppString</span> имеет несколько
переопределенных операторов и функций-членов, облегчающих работу со строками (во всех примерах далее будем
считать, что <span class="cpp">str</span>, <span class="cpp">str1</span> и <span class="cpp">str2</span>
&ndash; это переменные-строки какого-либо блока):</p>

<dl>
  <dt><span class="cpp">char *<span id="light_ref2">c_str</span>(void)</span></dt>
  <dd>Возвращает указатель на стандартную строку &laquo;<span class="cpp">char*</span>&raquo;, хранящуюся внутри переменной блока
  (тип &laquo;<span class="cpp">char*</span>&raquo; используется в большинстве стандартных функция языка C, работающих со строками).
  Если строка пуста, возвращает указатель на статическую пустую строку, то есть эта функция никогда не возвращает
  значение <span class="cpp">NULL</span>, даже если строка в переменной блока отсутствует. Пример использования
  функции:<br />
  <pre class="cpp">  // Преобразование строки str в целое число n
  int n=atoi(str.c_str());</pre></dd>

  <dt><span class="cpp"><a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> <span id="light_ref3">IsEmpty</span>(void)</span></dt>
  <dd>Возвращает <span class="cpp">TRUE</span>, если строка пуста (не имеет символов) и
  <span class="cpp">FALSE</span> в противном случае. Пример использования функции:<br />
  <pre class="cpp">  // Преобразование строки str в целое число n
  if(str.IsEmpty())
    { // Строка str пуста
      &hellip;
    }</pre></dd>

  <dt><span class="cpp">int <span id="light_ref4">Length</span>(void)</span></dt>
  <dd>Возвращает число символов в строке. Для пустой строки возвращается ноль. Пример использования функции:<br />
  <pre class="cpp">  int len=str.Length();</pre></dd>

  <dt><span class="cpp">char & operator[](int n)</span></dt>
  <dd>Символ строки номер <span class="cpp">n</span> (нумерация начинается с нуля). Проверка допустимости индекса
  <span class="cpp">n</span> не производится, попытка обратиться к символу за пределами строки (а также к
  любому символу пустой строки) вызовет критическую ошибку. Следует учитывать, что строки, как и положено в языке C,
  завершаются нулевым байтом. Выражение с этим оператором может находиться как в левой, так и в правой части
  оператора присваивания, то есть можно не только получать значения отдельных символов в строке, но и
  присваивать их. Примеры использования оператора:<br />
  <pre class="cpp">  // Запись первого символа строки str в переменную c
  char c;
  if(str.<a class="hidden" href="#light_ref3" title="Функция IsEmpty класса rdsbcppString">IsEmpty</a>()) c=0;
  else c=str[0];
  // Замена всех символов в строке str на пробелы
  for(int i=0;i&lt;str.<a class="hidden" href="#light_ref4" title="Функция Length класса rdsbcppString">Length</a>();i++)
    str[i]=' ';</pre></dd>

  <dt><span class="cpp">rdsbcppString operator+(const rdsbcppString &val)</span></dt>
  <dd>Переопределенный оператор &laquo;<span class="cpp">+</span>&raquo;, позволяющий складывать строки-переменные блоков.
  Пример использования оператора:<br />
  <pre class="cpp">  str=str1+str2;</pre></dd>

  <dt><span class="cpp">rdsbcppString operator+(char *val)</span></dt>
  <dd>Переопределенный оператор &laquo;<span class="cpp">+</span>&raquo;, позволяющий складывать строку-переменную блока и
  обычную строку &laquo;<span class="cpp">char*</span>&raquo;. Пример использования оператора:<br />
  <pre class="cpp">  str=str1+"текст";</pre></dd>

  <dt><span class="cpp">rdsbcppString & operator+=(const rdsbcppString &val)</span></dt>
  <dd>Оператор &laquo;<span class="cpp">+=</span>&raquo;, позволяющий добавить к концу строки в переменной блока строку из
  другой переменной. Пример использования оператора:<br />
  <pre class="cpp">  str+=str1;</pre></dd>

  <dt><span class="cpp">rdsbcppString & operator+=(char *val)</span></dt>
  <dd>Оператор &laquo;<span class="cpp">+=</span>&raquo;, позволяющий добавить к концу строки-переменной блока обычную строку
  &laquo;<span class="cpp">char*</span>&raquo;. Пример использования оператора:<br />
  <pre class="cpp">  str+="текст";</pre></dd>

  <dt><span class="cpp">rdsbcppString & operator=(const rdsbcppString &val)</span></dt>
  <dd>Оператор присваивания, копирующий в данную переменную блока строку из переменной <span class="cpp">val</span>.
  Пример использования оператора:<br />
  <pre class="cpp">  str=str1;</pre></dd>

  <dt><span class="cpp">rdsbcppString & operator=(char *val)</span></dt>
  <dd>Оператор присваивания, копирующий в данную переменную блока текст <span class="cpp">val</span>. Пример
  использования оператора:<br />
  <pre class="cpp">  str="текст";</pre></dd>

</dl>

<p>В большинстве случаев работа со строками в модели блока производится следующим образом: при помощи оператора
<span class="cpp"><a href="#light_ref2" title="Функция c_str класса rdsbcppString">c_str</a>()</span> считываются строки из входных переменных,
затем при помощи стандартных функций библиотек C с этими строками выполняются какие-либо действия, результаты
которых присваиваются выходным переменным блока. Если необходимо просто собирать длинный текст из нескольких
строк, вместо библиотечных функций C можно использовать оператор сложения, переопределенный в классе строки
<span class="cpp">rdsbcppString</span>.</p>

<p>В качестве примера создадим блок, который будет отображать строку, представляющую собой разделенный запятыми
список всех элементов его входного вещественного массива &laquo;<span class="rdsvar">X</span>&raquo;, число знаков после десятичной точки
в которых будет определяться целым входом &laquo;<span class="rdsvar">Dec</span>&raquo;. Переменную блока, в которой будет записана
сформированная строка, назовем &laquo;<span class="rdsvar">str</span>&raquo;, ее можно сделать внутренней переменной или выходом блока.
Таким образом, структура переменных у нашего блока будет такая:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td>Start</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">1</td>
  </tr>

  <tr>
    <td>Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>X</td>
    <td class="center">Массив double</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">[&nbsp;]&nbsp;0</td>
  </tr>

  <tr>
    <td>Dec</td>
    <td class="center">int</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>str</td>
    <td class="center">Строка</td>
    <td class="center">Выход</td>
    <td></td>
    <td></td>
  </tr>

</table>
</div></div>

<p><a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">Создадим</a> новый блок с автокомпилируемой моделью, зададим для него запуск
по сигналу и введем в его модель эту структуру переменных. На
<a href="um_3_3.htm#pic8" title="Окно редактора пустой модели">вкладке &laquo;<span class="menu">модель</span>&raquo;</a>
в правой части окна редактора введем следующий текст:</p>

<pre class="cpp">  char buf[100]; // Вспомогательный массив

  if(X.<a class="hidden" href="um_3_7_2_3.htm#light_ref2" title="Функция IsEmpty класса массива">IsEmpty</a>()) // Массив пуст
    { str=""; // Отображаем пустую строку
      return;
    }
  // В массиве есть элементы

  if(Dec&gt;10) // Выводим не более 10 символов после точки
    Dec=10;

  str="("; // Список начнется со скобки
  for(int i=0;i&lt;X.<a class="hidden" href="um_3_7_2_3.htm#light_ref4" title="Функция Size класса массива">Size</a>();i++) // Цикл по всем элементам
    { if(i) // Если не первый элемент, добавляем запятую
        str+=", ";
      if(X[i]==<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a>) // Признак ошибки
        str+="?";
      else
        { // Формируем текст в массиве buf
          sprintf(buf,"%.*lf",(int)Dec,(double)X[i]);
          str+=buf; // Дописываем buf к str
        }
    }
  str+=")"; // Закрывающая скобка списка</pre>

<p><span id="ref5">В</span>
<span id="ref6">этом</span>
<span id="ref7">фрагменте</span>
программы для преобразования вещественного числа в текст с заданной точностью используется
стандартная библиотечная функция <span class="cpp" id="light_ref6">sprintf</span>, описанная в файле
&laquo;<span class="file"><span id="light_ref7">stdio.h</span></span>&raquo;. Этот файл не включается в формируемый
модулем автокомпиляции текст программы по умолчанию, поэтому
<span id="light_ref5">директиву его включения</span> необходимо записать вручную в раздел глобальных описаний.
Для этого в редакторе модели необходимо выполнить следующие действия:</p>

<ul>
  <li>на дополнительной левой панели редактора выбрать
  <a href="um_3_6_4.htm" title="&sect;3.6.4. Описания программы и реакции блока на события">вкладку &laquo;<span class="menu">события</span>&raquo;</a>;</li>

  <li>на этой вкладке раскрыть раздел &laquo;<span class="menu">описания</span>&raquo; (это самый первый раздел в списке), щелкнув
  левой кнопкой мыши на значке &laquo;<span class="menu">+</span>&raquo; слева от него;</li>

  <li>дважды щелкнуть на открывшемся подразделе &laquo;<span class="menu">глобальные описания</span>&raquo;, после чего в правой части
  окна редактора рядом с вкладкой &laquo;<span class="menu">модель</span>&raquo; появится новая вкладка &laquo;<span class="menu">описания</span>&raquo;.</li>
</ul>

<p>На открывшейся вкладке &laquo;<span class="menu">описания</span>&raquo; следует ввести следующий текст из одной строки:</p>

<pre class="cpp">  #include &lt;stdio.h&gt;</pre>

<p>Теперь, когда директива включения недостающего файла заголовков добавлена, рассмотрим приведенную выше
программу, введенную на вкладке &laquo;<span class="menu">модель</span>&raquo;. Эта программа будет выполняться при каждом
срабатывании связи, подключенной к любому из входов блока, то есть при изменении содержимого входного массива
<span class="cpp">X</span> или точности отображения его элементов <span class="cpp">Dec</span>.</p>

<p>В самом начале программы описывается вспомогательный массив <span class="cpp">buf</span> из ста символов.
Он будет использоваться для преобразования числа в строку &ndash; девяносто девяти символов (с учетом
завершающего строку нулевого байта) хватит для вывода числа типа <span class="cpp">double</span> с любой
разумной точностью. Поскольку текст реакции на любое событие, вводимый в редакторе модели, вставляется внутрь
сформированных модулем автокомпиляции функций, массив <span class="cpp">buf</span> будет локальным для
функции реакции на такт расчета.</p>

<p>Далее, если во входном массиве <span class="cpp">X</span> нет ни одного элемента
(<span class="cpp">X.<a href="um_3_7_2_3.htm#light_ref2" title="Функция IsEmpty класса массива">IsEmpty</a>()</span> вернет <span class="cpp">TRUE</span>),
переменной <span class="cpp">str</span> присваивается пустая строка и выполнение реакции завершается оператором
<span class="cpp">return</span> &ndash; массив пуст, и отображать нечего. В противном случае значение числа
символов после десятичной точки <span class="cpp">Dec</span> ограничивается значением 10: если значение переменной
<span class="cpp">Dec</span> больше 10, ей принудительно присваивается 10. Это ограничение сделано для того,
чтобы строки, в которые преобразуются значения каждого элемента массива <span class="cpp">X</span>, гарантированно
не превысили размеров массива <span class="cpp">buf</span>. Можно было бы написать программу так, чтобы такое
ограничение не потребовалось (например, с использованием сервисной функции
RDS <span class="cpp"><a href="rdsDtoA.htm" title="А.5.4.5. rdsDtoA &ndash; преобразование вещественного числа в строку">rdsDtoA</a></span>), но мы не будем усложнять этот пример. Можно заметить, что мы
присваиваем значение переменной, являющейся входом блока &ndash; это вполне допустимо, присвоенное значение
останется в переменной <span class="cpp">Dec</span> до следующего срабатывания подключенной к ней связи.</p>

<p>Далее мы присваиваем переменной <span class="cpp">str</span> открывающую круглую скобку, а затем, в
цикле по всем элементам массива <span class="cpp">X</span>
(см. <a href="um_3_7_2_3.htm" title="&sect;3.7.2.3. Модели с массивами">&sect;3.7.2.3</a>), добавляем в конец этой строки при помощи оператора
&laquo;<span class="cpp">+=</span>&raquo; текст для каждого элемента. Внутри этого цикла мы для каждого элемента, кроме первого
(то есть при значении счетчика цикла <span class="cpp">i</span>, не равном нулю), добавляем к строке запятую
и пробел, отделяющий элементы друг от друга, и, если <span class="cpp">X[i]</span> не равно значению ошибки
<span class="cpp"><a href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a></span>, формируем в массиве <span class="cpp">buf</span> текстовое представление
вещественного числа с заданной точностью и добавляем этот текст к <span class="cpp">str</span> (для значения
ошибки вместо значения элемента добавляется вопросительный знак). После цикла к <span class="cpp">str</span>
добавляется закрывающая круглая скобка.</p>

<p>Вещественное число в цикле преобразуется в строку в массиве <span class="cpp">buf</span> при помощи функции
<span class="cpp">sprintf</span>:</p>

<pre class="cpp">  sprintf(buf,"%.*lf",(int)Dec,(double)X[i]);</pre>

<p>Строка формата &laquo;%.*lf&raquo; указывает на то, что выполняется преобразование вещественного числа
двойной точности (&laquo;lf&raquo;) с числом знаков после десятичной точки, указанным в параметре функции перед
самим числом (&laquo;.*&raquo;). В третьем и четвертом параметрах <span class="cpp">sprintf</span> передаются
точность представления числа <span class="cpp">Dec</span> и само число <span class="cpp">X[i]</span>.
Поскольку <span class="cpp">sprintf</span> &ndash; функция с переменным числом параметров, тип которых явно
не указан в ее описании, компилятор не сможет самостоятельно преобразовать типы объектов, созданных модулем
автокомпиляции для переменных блока (напомним, что, например, <span class="cpp">Dec</span> &ndash; это
именно объект некоторого специально сформированного класса, а не переменная типа <span class="cpp">int</span>).
Чтобы избежать разночтений, для <span class="cpp">Dec</span> и <span class="cpp">X[i]</span> явно вызываются
операторы преобразования к типам <span class="cpp">int</span> и <span class="cpp">double</span> соответственно
(см. также <a href="um_3_7_1.htm" title="&sect;3.7.1. Устройство формируемой модулем программы">&sect;3.7.1</a>).</p>

<p>Мы создали модель блока, преобразующую массив вещественных чисел в строку со значениями всех его элементов,
но сам блок пока ничего отображать не может &ndash; он выглядит как пустой белый квадрат. Чтобы строка
появлялась на изображении блока, необходимо
<a href="um_index.htm#light_htm:um_2_10" title="&sect;2.10. Редактирование векторной картинки блока">задать для него векторную картинку</a>. Создадим картинку, состоящую из
прямоугольника и размещенного внутри него блока текста, связанного с переменной блока <span class="cpp">str</span>
(<a href="#pic1" title="Внешний вид блока в редакторе картинки">рис.&nbsp;376</a>).
Картинку можно ввести из редактора модели через команду
<a href="um_3_6_8.htm" title="&sect;3.6.8. Установка параметров блоков с автокомпилируемой моделью">установки параметров блоков</a> или в
<a href="um_2_9_1.htm#pic5" title="Вкладка внешний вид окна параметров простого блока при выбранном изображении картинкой (картинка отсутствует)">окне параметров</a>
созданного нами блока. В последнем случае необходимо выполнить следующие шаги:</p>

<div class="picright"><div class="container" id="pic1">
<img src="../img/AC_string_testpic.png" width="216" height="102" alt="Внешний вид блока в редакторе картинки" />
<p id="light_pic1">Рис.&nbsp;376. Внешний вид блока<br />в редакторе картинки</p>
</div></div>


<ul>
  <li>в <a href="um_1_3.htm#ref1" title="Режим редактирования">режиме редактирования</a>
  нажать на изображении блока правую кнопку мыши и выбрать в контекстном меню пункт
  &laquo;<span class="menu">параметры</span>&raquo; &ndash; откроется <a href="um_2_9_1.htm" title="&sect;2.9.1. Создание простого блока и окно его параметров">окно параметров блока</a>;</li>

  <li>на вкладке окна <a href="um_2_9_1.htm#pic5" title="Вкладка внешний вид окна параметров простого блока при выбранном изображении картинкой (картинка отсутствует)">&laquo;<span class="menu">внешний вид</span>&raquo;</a> установить
  флажок &laquo;<span class="menu">определяется картинкой</span>&raquo; и нажать кнопку &laquo;<span class="menu">изменить</span>&raquo; на панели
  &laquo;<span class="menu">картинка</span>&raquo; в левой нижней части вкладки &ndash; откроется
  <a href="um_2_10_1.htm" title="&sect;2.10.1. Общие сведения о редакторе картинки">редактор картинки</a>;</li>

  <li>в редакторе картинки создать
  <a href="um_2_10_2.htm" title="&sect;2.10.2. Рисование прямоугольников и эллипсов">прямоугольник</a> и
  <a href="um_2_10_5.htm" title="&sect;2.10.5. Создание строк и блоков текста">блок текста</a>, расположить блок текста поверх и внутри прямоугольника,
  как на <a href="#pic1" title="Внешний вид блока в редакторе картинки">рис.&nbsp;376</a>;</li>

  <li>дважды щелкнуть левой кнопкой мыши на блоке текста, выбрать в открывшемся окне его параметров
  <a href="um_2_10_5.htm#pic5_1" title="Окно параметров текстового блока: вкладки внешний вид (а) и связи (б)">вкладку &laquo;<span class="menu">связи</span>&raquo;</a>
  и выбрать в выпадающем списке на этой вкладке переменную &laquo;<span class="rdsvar">str</span>&raquo; (если это имя в выпадающем
  списке будет отсутствовать, а это возможно, если мы еще не компилировали модель, имя можно ввести вручную);</li>

  <li>закрыть окно параметров текста кнопкой &laquo;<span class="menu">OK</span>&raquo;;</li>

  <li>закрыть окно редактора (как обычно в Windows, кнопкой с крестиком в правой верхней части окна);</li>

  <li>закрыть окно параметров блока кнопкой &laquo;<span class="menu">OK</span>&raquo;.</li>
</ul>

<p class="noindent">Теперь наш блок в режимах
<a href="um_1_3.htm#ref2" title="Режим моделирования">моделирования</a> и
<a href="um_1_3.htm#ref3" title="Режим расчета">расчета</a> будет отображать значение переменной &laquo;<span class="rdsvar">str</span>&raquo;.
Для тестирования созданной нами модели можно собрать схему, изображенную
на <a href="#pic2" title="Тестирование модели преобразования массива в строку">рис.&nbsp;377</a>.
В ней к входному массиву блока &laquo;<span class="rdsvar">X</span>&raquo; подключен стандартный блок ввода матриц (в
RDS матрицы можно соединять с массивами), а к целому входу &laquo;<span class="rdsvar">Dec</span>&raquo; &ndash; обычное поле
ввода. Задав на входе &laquo;<span class="rdsvar">X</span>&raquo; какую-нибудь матрицу-строку и запустив расчет, на изображении блока
можно будет увидеть текст из строки &laquo;<span class="rdsvar">str</span>&raquo;, то есть элементы этой матрицы, перечисленные через
запятую. Если размеров блока недостаточно для отображения строки, она будет обрезана по границам блока текста,
заданного в редакторе картинки &ndash; в этом случае можно снова открыть редактор картинки блока и изменить
размеры ее элементов.</p>

<div class="pic"><div class="container" id="pic2">
<img src="../img/AC_string_test.png" width="339" height="222" alt="Тестирование модели преобразования массива в строку" />
<p id="light_pic2">Рис.&nbsp;377. Тестирование модели преобразования массива в строку</p>
</div></div>


<p><span id="ref8">Следует</span> иметь в виду, что строка в RDS &ndash; это всегда
последовательность символов в кодировке Windows <span id="light_ref8">CP1251</span>, завершающаяся нулевым
байтом. Многобайтовые символы Unicode в RDS не поддерживаются.</p>


</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_7_2_4.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_2_6.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_2_5">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
