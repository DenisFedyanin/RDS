<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.7.2.6. Использование сигналов</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7_2">&sect;3.7.2. Работа со статическими переменными блока</a></p>
<div class="level"><p>&sect;3.7.2.6. Использование сигналов</p>
</div>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_7_2_5.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_2_7.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_2_6">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</h3>
<h4 class="off">&sect;3.7.2. Работа со статическими переменными блока</h4>
<h5>&sect;3.7.2.6. Использование сигналов</h5>
<p class="abstract">Рассматривается работа с переменными сигнального типа, используемыми для передачи информации о факте наступления какого-либо события. Описываются особенности использования сигнала запуска Start и сигнала готовности Ready, которые есть у каждого простого блока.</p>


<p><a href="um_1_4.htm#light_ref2" title="тип переменной: сигнал">Сигнальные переменные</a>
используются в RDS для передачи блокам информации о наступлении какого-либо события
&ndash; нажатия кнопки, срабатывания устройства, обнаружения какого-либо специфического состояния схемы и т.п.
Они очень похожи на логические &ndash; как и логические, сигнальные переменные могут принимать только значения 0 и
1 &ndash; но отличаются способом передачи значений по
<a href="um_2_7_1.htm" title="&sect;2.7.1. Общие принципы создания связей">связям</a>
(подробнее см. в <a href="pm_2_5_2.htm" title="&sect;2.5.2. Особенности использования сигналов">&sect;2.5.2 руководства программиста</a>). Этих отличий два:</p>
<ul>
  <li>по связи передается только единичное значение сигнала-выхода, нулевое значение на входы соединенных блоков не
  передается;</li>
  <li>после передачи единичного значения сигнала-выхода оно автоматически сбрасывается в ноль (на соединенных
  с этим выходом входах остается единица).</li>
</ul>

<p>Из-за такого поведения сигналов работа с сигнальными входами блоков отличается от работы с входами других
типов: модель блока с сигнальным входом, обнаружив на этом входе единицу, должна, выполнив все необходимые
действия, самостоятельно присвоить этому входу нулевое значение, подготовив его тем самым к приему следующей
единицы. Действительно, нулевое значение сигнала по связи не передается, поэтому единица, поступившая на сигнальный
вход, останется там навсегда, если блок-владелец этого входа принудительно не сбросит ее.</p>

<p>Задачи, решаемые с помощью сигналов, можно решать и при помощи логических переменных, но модели блоков при
этом получаются несколько сложнее. В <a href="pm_2_5_2.htm" title="&sect;2.5.2. Особенности использования сигналов">&sect;2.5.2 руководства программиста</a>
рассмотрена задача подсчета числа нажатий пользователем кнопки, моделируемой блоком, и сложности, возникающие при
создании блока-кнопки и блока-счетчика с использованием только логических переменных. Коротко повторим
приведенные там рассуждения.</p>

<p>Если сделать выход блока-кнопки логическим и присваивать ему единицу при нажатии кнопки и ноль при отпускании,
в блоке-счетчике необходимо будет увеличивать выход на единицу только при изменении значения логического входа
с ноля на единицу. Просто увеличивать выход при единичном значении входа нельзя: если кнопка будет нажата
в течение нескольких
<a href="um_1_3.htm#ref4" title="Такт расчета">тактов расчета</a>
(а это весьма вероятно &ndash; такты следуют друг за другом очень
быстро), на протяжении всех этих тактов на входе блока-счетчика будет единица, и в каждом такте его выход
будет увеличиваться, хотя пользователь нажал на кнопку всего один раз. Таким образом, в блоке-счетчике
необходимо отслеживать не само значение логического входа, а его изменение с нуля на единицу, для чего
придется ввести дополнительную переменную для хранения значения входа на прошлом такте расчета: если в
прошлом такте вход был нулем, а в текущем стал единицей, значит, кнопка была нажата, и выход нужно
увеличивать. Таким образом, при решении задачи с помощью логических переменных модели получаются такими:</p>

<ul>
  <li>в блоке-кнопке должно быть две реакции на события: при
  <a href="ac_RDS_BFM_MOUSEDOWN.htm" title="&sect;3.8.4.1. Нажатие кнопки мыши">нажатии кнопки мыши</a>
  логическому выходу нужно присваивать единицу, при
  <a href="ac_RDS_BFM_MOUSEUP.htm" title="&sect;3.8.4.2. Отпускание кнопки мыши">отпускании</a> &ndash; ноль;</li>

  <li>в блоке-счетчике необходимо ввести вспомогательную логическую переменную, в которую в конце реакции на
  такт расчета следует копировать текущее значение входа (то есть запоминать прошлое состояние входа), а в
  начале этой же реакции сравнивать значение входа с этой переменной и увеличивать выход, только если в переменной
  &ndash; ноль, а на входе &ndash; единица.</li>
</ul>

<p>Теперь решим ту же задачу с помощью сигналов. В блоке-кнопке сделаем сигнальный выход, в который будем записывать
единицу при нажатии кнопки (реакция на отпускание не понадобится). В блоке-счетчике сделаем сигнальный вход,
при обнаружении единицы на котором будем увеличивать выход и сбрасывать вход снова на ноль. Никакой дополнительной
переменной для хранения прошлого значения входа не понадобится. Действительно, когда блок-кнопка установит
единичное значение выхода при нажатии, после передачи этого значения на вход счетчика выход автоматически сбросится
в ноль, и останется нулем, сколько бы пользователь ни держал кнопку нажатой. Счетчик, отреагировав на единицу на
входе, увеличит выход и сбросит свой вход, на котором, таким образом, тоже останется ноль до следующего нажатия
кнопки. Модели с использованием сигналов будут такими:</p>

<ul>
  <li>в блоке-кнопке будет только реакция на нажатие кнопки мыши, в которой сигнальному выходу
  присваивается единица;</li>
  <li>в блоке-счетчике в реакции на такт расчета при обнаружении единицы на сигнальном входе без каких-либо
  проверок вход сбрасывается на ноль, а выход увеличивается.</li>
</ul>

<p>Можно видеть, что во втором случае модели получаются проще, поскольку при использовании сигналов RDS,
фактически, берет на себя работу по отслеживанию изменения состояния переменной: можно сказать, что по
связи передается только передний фронт сигнала. При присвоении выходу единицы эта единица уходит на соединенные
входы, автоматически сбрасывается, и передача на этом заканчивается &ndash; выход готов к приему следующей
единицы. Платой за упрощение моделей является необходимость принудительно сбрасывать сигнальные входы в
ноль после их обработки.</p>

<p>Создадим модель блока-счетчика, похожую на описанную выше (кнопку с сигнальным выходом возьмем из
стандартных библиотечных блоков). Наш блок по входному сигналу &laquo;<span class="rdsvar">Clk</span>&raquo; будет изменять свой целый
выход &laquo;<span class="rdsvar">Count</span>&raquo; с 0 до 9, а при поступлении следующего сигнала сбросит &laquo;<span class="rdsvar">Count</span>&raquo;
в ноль, выдаст на выход &laquo;<span class="rdsvar">Carry</span>&raquo; сигнал переноса и продолжит счет с нуля. Кроме того, у блока
будет сигнальный вход &laquo;<span class="rdsvar">Reset</span>&raquo;, сбрасывающий счетчик (устанавливающий
&laquo;<span class="rdsvar">Count</span>&raquo; в ноль). Такая же модель, только без использования модуля автокомпиляции, подробно
рассматривается <a href="pm_2_5_2.htm" title="&sect;2.5.2. Особенности использования сигналов">&sect;2.5.2 руководства программиста</a>.</p>

<p>Блок будет иметь следующую структуру переменных:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td>Start</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">1</td>
  </tr>

  <tr>
    <td>Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>Reset</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>Clk</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>Count</td>
    <td class="center">int</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>Carry</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>
</table>
</div></div>

<p><a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">Создадим</a> новый блок с автокомпилируемой моделью, зададим для него запуск
по сигналу и введем в его модель эту структуру переменных. На
<a href="um_3_3.htm#pic8" title="Окно редактора пустой модели">вкладке &laquo;<span class="menu">модель</span>&raquo;</a>
в правой части окна редактора введем следующий текст:</p>

<pre class="cpp">  if(Reset)    // Поступил сигнал Reset
    { Reset=0; // Сброс этого сигнала
      Clk=0;   // Сброс сигнала Clk
      Count=0; // Обнуление счетчика
      Carry=0; // Сброс сигнала переноса
    }
  else if(Clk) // Поступил сигнал Clk
    { Clk=0;   // Сброс этого сигнала
      Count++; // Увеличение счетчика
      if(Count>=10) // Досчитали до 10
        { Count=0;  // Обнуление счетчика
          Carry=1;  // Выдача сигнала переноса
        }
    }</pre>

<p>В этой модели мы сначала проверяем поступление сигнала <span class="cpp">Reset</span>. Если
<span class="cpp">Reset</span> &ndash; не ноль (то есть сигнал поступил), мы сбрасываем его вручную,
чтобы подготовится к следующему приему сигнала, и вместе с ним обнуляем целый выход <span class="cpp">Count</span>
и все остальные сигнальные входы и выходы &ndash; сигнал
<span class="cpp">Reset</span> возвращает наш блок в исходное состояние. Если же <span class="cpp">Reset</span>
равен нулю, то есть сигнала сброса не было, мы проверяем поступление <span class="cpp">Clk</span>. Если
<span class="cpp">Clk</span> &ndash; не ноль (поступил сигнал увеличения счетчика), мы сбрасываем его в ноль,
подготавливаясь к поступлению и обработке следующего сигнала, и увеличиваем <span class="cpp">Count</span>
на единицу. Затем, если значение <span class="cpp">Count</span> достигло десяти, мы сбрасываем его в ноль и
присваиваем единицу сигналу переноса <span class="cpp">Carry</span>.</p>

<p>Для тестирования этой модели можно собрать схему, изображенную
на <a href="#pic1" title="Тестирование модели счетчика сигналов">рис.&nbsp;378</a>.
В ней &ndash; два блока с нашей моделью (Block10 и Block11), соединенных последовательно: выход переноса
&laquo;<span class="rdsvar">Carry</span>&raquo; блока Block10 соединен с входом счета &laquo;<span class="rdsvar">Clk</span>&raquo; блока Block11. Когда
Block10 досчитает до десяти и выдаст сигнал переноса, Block11 увеличит свой выход на единицу. При таком соединении
выходы первого и второго блоков можно считать двумя разрядами двузначного десятичного числа &ndash; таким образом,
вместе они могут досчитать до ста. Размножить созданный блок-счетчик можно скопировав его в буфер обмена нажатием
<span class="keys">Ctrl</span>&nbsp;+&nbsp;<span class="keys">C</span>, а затем вставив его копию нажатием <span class="keys">Ctrl</span>&nbsp;+&nbsp;<span class="keys">V</span>, при этом на
<a href="um_3_5.htm#pic2" title="Запрос, выдающийся пользователю при вставке блока с автокомпилируемой моделью из буфера обмена">запрос модуля автокомпиляции</a>, нужно ли создавать копию модели
для вставляемого блока, следует ответить отрицательно (выбрать вариант
&laquo;<span class="menu">использовать тот же файл модели и для нового блока</span>&raquo;).</p>

<div class="pic"><div class="container" id="pic1">
<img src="../img/AC_counter_test.png" width="332" height="96" alt="Тестирование модели счетчика сигналов" />
<p id="light_pic1">Рис.&nbsp;378. Тестирование модели счетчика сигналов</p>
</div></div>


<p>Запустив расчет и щелкая по кнопке &laquo;<span class="menu">+1</span>&raquo; в приведенной выше схеме можно будет увидеть, как значение
на верхнем числовом индикаторе справа будет увеличиваться. Когда оно дойдет до девяти, следующий щелчок сбросит его
в ноль и увеличит значение на нижнем индикаторе. Щелчок не кнопке &laquo;<span class="menu">сброс</span>&raquo; установит оба индикатора в
ноль.</p>

<p><span id="light_ref1">Первые две переменных</span>
в каждом <a href="um_1_2.htm#light_ref9" title="Простой блок">простом блоке</a> всегда являются сигнальным входом и сигнальным выходом
&ndash; по умолчанию они называются &laquo;<span class="rdsvar">Start</span>&raquo; и &laquo;<span class="rdsvar">Ready</span>&raquo; соответственно, но их,
при желании, можно переименовать. В <a href="um_1_3.htm#ref3" title="Режим расчета">режиме расчета</a>
эти сигналы управляют работой блока и связей, подключенных к его выходам. Единица на входе &laquo;<span class="rdsvar">Start</span>&raquo;
запускает модель блока, если для блока не
<a href="um_2_9_1.htm#light_ref8" title="Установка режима запуска блока">установлен запуск каждый такт</a>
(в противном случае модель будет запускаться всегда, какое бы значение вход &laquo;<span class="rdsvar">Start</span>&raquo; ни имел).
Единица на выходе &laquo;<span class="rdsvar">Ready</span>&raquo; разрешает передачу данных выходов блока по связям. Модель может работать
с этими переменными как с обычными сигналами. Следует помнить, что перед вызовом реакции модели на такт расчета
RDS автоматически сбрасывает сигнал &laquo;<span class="rdsvar">Start</span>&raquo; и взводит сигнал &laquo;<span class="rdsvar">Ready</span>&raquo; (то есть
считается, что блок уже сработал, и данные его выходов должны быть переданы по связям после такта). Если модели
необходимо принудительно перезапустить себя в следующем такте независимо от срабатывания связей, присоединенных
к входам блока и его настроек, она может самостоятельно взвести свой собственный сигнал &laquo;<span class="rdsvar">Start</span>&raquo;.
Модель может также, при необходимости, запретить передачу данных своих выходов по связям, сбросив сигнал
&laquo;<span class="rdsvar">Ready</span>&raquo;. Поскольку &laquo;<span class="rdsvar">Ready</span>&raquo; автоматически взводится только при реакции на такт
расчета, во всех остальных реакциях модель должна самостоятельно взвести этот сигнал, чтобы передать свои
изменившиеся выходы по связям. Например, если блок изменяет свой выход по щелчку мыши, в реакции на щелчок
необходимо присвоить &laquo;<span class="rdsvar">Ready</span>&raquo; единицу, иначе новое значение выхода не будет передано
(пример такой модели рассматривается в <a href="um_3_7_10.htm" title="&sect;3.7.11. Реакция блока на мышь">&sect;3.7.11</a>).</p>

<p>С сигналом &laquo;<span class="rdsvar">Start</span>&raquo; мы уже сталкивались в предыдущих примерах: чтобы модели блоков
принудительно запускались в самом первом такте расчета и обрабатывали исходные значения входов, мы
давали этой переменной единичное значение по умолчанию. Однако, мы еще ни разу не подключали связи к
этому входу. Такое подключение позволяет запускать реакцию модели на такт расчета по сигналу от другого блока
&ndash; это позволяет либо организовать достаточно сложную логику работы схемы
(примеры приведены в <a href="um_1_4.htm" title="&sect;1.4. Статические переменные блоков">&sect;1.4</a>), либо просто ускоряет работу схемы (модель
не запускается, когда это не нужно) и, в некоторых случаях, упрощает программу модели. Рассмотрим сначала
использование сигнала запуска непосредственно для запуска модели блока.</p>

<p><span id="ref2">В</span>
<a href="um_3_3.htm" title="&sect;3.3. Создание нового блока с автокомпилируемой моделью">&sect;3.3</a> и <a href="um_3_7_2_1.htm" title="&sect;3.7.2.1. Модели с простыми статическими переменными">&sect;3.7.2.1</a> была рассмотрена
модель простого сумматора, выдающего на вещественный выход &laquo;<span class="rdsvar">y</span>&raquo; сумму вещественных входов
&laquo;<span class="rdsvar">x1</span>&raquo; и &laquo;<span class="rdsvar">x2</span>&raquo;.
<span id="light_ref2">Изменим немного эту модель</span> так, чтобы суммирование осуществлялось
только по команде от кнопки &ndash; то есть, по сигналу.
<a href="um_3_7_2_1.htm#pic2" title="Установка запуска по сигналу в окне параметров блока">Установим для сумматора запуск по сигналу</a>
на вкладке &laquo;<span class="menu">общие</span>&raquo; окна параметров блока и изменим структуру переменных модели следующим образом
(можно изменить ее в существующей модели, или создать копию модели с новой структурой переменных, скопировав блок
через буфер обмена клавишами <span class="keys">Ctrl</span>&nbsp;+&nbsp;<span class="keys">C</span> и <span class="keys">Ctrl</span>&nbsp;+&nbsp;<span class="keys">V</span> и ответив
&laquo;<span class="menu">создать копию модели</span>&raquo;
<a href="um_3_5.htm#pic2" title="Запрос, выдающийся пользователю при вставке блока с автокомпилируемой моделью из буфера обмена">запрос модуля автокомпиляции</a>):</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td>Start</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center"><span class="changes">&nbsp;0&nbsp;</span></td>
  </tr>

  <tr>
    <td>Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>x1</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td class="center"><span class="changes">&nbsp;&nbsp;&nbsp;</span></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>x2</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td class="center"><span class="changes">&nbsp;&nbsp;&nbsp;</span></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>y</td>
    <td class="center">double</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

</table>
</div></div>

<p>По сравнению с моделью
из <a href="um_3_7_2_1.htm" title="&sect;3.7.2.1. Модели с простыми статическими переменными">&sect;3.7.2.1</a>, в эту структуру внесено два изменения. Во-первых,
значение по умолчанию сигнала запуска &laquo;<span class="rdsvar">Start</span>&raquo; изменено на ноль &ndash; нам не нужно, чтобы
модель запускалась без команды в самом первом такте расчета. Во-вторых, флажки &laquo;<span class="menu">пуск</span>&raquo; у входов
&laquo;<span class="rdsvar">x1</span>&raquo; и &laquo;<span class="rdsvar">x2</span>&raquo; выключены &ndash; автоматический запуск модели при срабатывании
связей, подключенных к этим входам, нам тоже не нужен. Программа модели блока останется прежней –
&laquo;<span class="cpp">y=x1+x2;</span>&raquo;.</p>

<div class="picright"><div class="container" id="pic2">
<img src="../img/AC_sum2_test.png" width="181" height="91" alt="Сумматор, складывающий по сигналу" />
<p id="light_pic2">Рис.&nbsp;379. Сумматор,<br />складывающий по сигналу</p>
</div></div>


<p>Соберем с новым блоком схему, изображенную
на <a href="#pic2" title="Сумматор, складывающий по сигналу">рис.&nbsp;379</a>.
Входы сумматора &laquo;<span class="rdsvar">x1</span>&raquo; и &laquo;<span class="rdsvar">x2</span>&raquo; подключены к полям ввода, выход
&laquo;<span class="rdsvar">y</span>&raquo; &ndash; к индикатору, а сигнальный вход &laquo;<span class="rdsvar">Start</span>&raquo; &ndash; к сигнальному выходу
&laquo;<span class="rdsvar">Click</span>&raquo; стандартной библиотечной кнопки. Запустив расчет, можно будет увидеть, что при
изменении значений в полях ввода выход нового блока, в отличие от блока из <a href="um_3_7_2_1.htm" title="&sect;3.7.2.1. Модели с простыми статическими переменными">&sect;3.7.2.1</a>,
не изменяется &ndash; модель блока не запускается. Сумма входов появится на выходе только после нажатия кнопки,
то есть после поступления единицы на вход &laquo;<span class="rdsvar">Start</span>&raquo;. Разумеется, сигнал запуска может подаваться не
только с кнопки, его источником может быть выход любого другого блока. Так в схемах одни блоки могут управлять запуском
других.</p>

<p>Рассмотрим теперь другое использование сигнала запуска, иногда позволяющее несколько упростить программу
модели. Выше была рассмотрена модель блока-счетчика с переносом, которая запускалась по сигналам счета
&laquo;<span class="rdsvar">Clk</span>&raquo; (увеличить значение) и сброса &laquo;<span class="rdsvar">Reset</span>&raquo; (обнулить счетчик). Можно переписать
эту модель так, чтобы в качестве сигнала счета выступал сигнал запуска &laquo;<span class="rdsvar">Start</span>&raquo;. Мы переименуем его
в &laquo;Clk&raquo;, и в программе модели будем проверять значение &laquo;<span class="rdsvar">Reset</span>&raquo;: если
<span class="cpp">Reset==1</span>, значит, модель запустилась из-за сигнала сброса, а если
<span class="cpp">Reset==0</span>, то она запустилась по какой-то другой причине &ndash; а другой причиной
запуска может быть только поступление единицы на сигнал запуска блока. Новый блок будет иметь следующую структуру
переменных:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td>Clk</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>Reset</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>Count</td>
    <td class="center">int</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>Carry</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>
</table>
</div></div>

<p>Первый сигнальный вход блока, ранее называвшийся &laquo;<span class="rdsvar">Start</span>&raquo;, теперь переименован в
&laquo;<span class="rdsvar">Clk</span>&raquo;, а старый сигнал &laquo;<span class="rdsvar">Clk</span>&raquo; удален из структуры переменных. В новом блоке
обязательно нужно
<a href="um_3_7_2_1.htm#pic2" title="Установка запуска по сигналу в окне параметров блока">задать запуск по сигналу</a>,
причины этого будут объяснены ниже. Новая модель блока будет выглядеть
следующим образом:</p>

<pre class="cpp">  if(Reset)    // Поступил сигнал Reset
    { Reset=0; // Сброс этого сигнала
      // Сброс сигнала Clk здесь не нужен – сигнал запуска блока сбрасывается автоматически
      Count=0; // Обнуление счетчика
      Carry=0; // Сброс сигнала переноса
      return;
    }
  // Сигнал Reset не поступал, но модель запустилась - значит, поступил Clk.
  // Сбрасывать Clk не нужно - сигнал запуска блока сбрасывается автоматически
  Count++; // Увеличение счетчика
  if(Count>=10) // Досчитали до 10
    { Count=0;  // Обнуление счетчика
      Carry=1;  // Выдача сигнала переноса
    }</pre>

<p>Новая модель, за исключением комментариев, получилась короче. Если собрать из новых блоков схему, изображенную
на <a href="#pic1" title="Тестирование модели счетчика сигналов">рис.&nbsp;378</a>,
она будет работать точно так же, как и схема со старыми блоками.</p>

<p>В новой модели счетчика следует обратить внимание на три важных момента. Во-первых, начальное значение сигнала
запуска, то есть первой сигнальной переменной блока, теперь не единица, как в старой модели, а ноль. Мы теперь
используем этот сигнал в качестве сигнала счета, поэтому единицу по умолчанию ему давать нельзя &ndash; в этом
случае при первом запуске расчета счетчик увеличит свой выход лишний раз. Если бы нам необходимо было при
первом запуске расчета обработать начальные значения входов блока, использовать сигнал запуска так, как мы это
сделали, было бы нельзя &ndash; он должен был бы остаться выделенным сигналом, ответственным только за запуск
модели в режиме расчета, чтобы мы могли дать ему единичное начальное значение.</p>

<p>Во-вторых, нигде в новой модели нет ни проверки, ни обнуления сигнала <span class="cpp">Clk</span>. Проверять
его значение бессмысленно, поскольку перед запуском модели сигнал запуска блока автоматически обнуляется.
Сам запуск модели свидетельствует о том, что сигнал пришел либо на <span class="cpp">Clk</span>, либо на
<span class="cpp">Reset</span> (у входа <span class="cpp">Reset</span> установлен флажок в колонке
&laquo;<span class="menu">пуск</span>&raquo;). <span class="cpp">Reset</span> автоматически не сбрасывается, поэтому, если модель
запустилась из-за него, в нем останется единица (мы проверяем это в самом начале программы). Обнулять
<span class="cpp">Clk</span> не нужно по этой же причине &ndash; на момент вызова нашей реакции он уже
обнулен.</p>

<p>В-третьих, в отличие от старой модели счетчика, новая будет работать только в том случае, если в
параметрах блока установлен флажок &laquo;<span class="menu">запуск по сигналу</span>&raquo;. Если установить флажок
&laquo;<span class="menu">запуск каждый такт</span>&raquo;, в каждом такте расчета модель будет запускаться, и, поскольку счетчик
теперь увеличивает свой выход при каждом запуске, он будет считать непрерывно, независимо от поступления
сигнала на вход <span class="cpp">Clk</span>. В старой модели <span class="cpp">Clk</span> был отдельным
входом, значение которого проверялось в программе, а сам факт запуска модели ничего не значил, поэтому старая
модель работала при любом способе запуска.</p>

<p>Теперь приведем пример использования выхода &laquo;<span class="rdsvar">Ready</span>&raquo; для запрещения срабатывания связей,
подключенных к выходу блока. Создадим модель блока, вставив который в разрыв связи, передающей вещественное
значение, можно будет разрешать или запрещать передачу данных по этой связи. Такой блок есть в стандартной
библиотеке RDS, но мы, в качестве примера, создадим его вручную.</p>

<p>Блок будет иметь вещественный вход &laquo;<span class="rdsvar">x</span>&raquo;, который будет копироваться в вещественный выход
&laquo;<span class="rdsvar">y</span>&raquo;, если логический вход &laquo;<span class="rdsvar">Enable</span>&raquo; не равен нулю, причем при
<span class="cpp">Enable==0</span> значение выхода блока, оставшееся там с прошлых срабатываний, не должно
передаваться по связи.</p>

<p>Структура переменных блока будет следующей:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td>Start</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">1</td>
  </tr>

  <tr>
    <td>Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>x</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>Enable</td>
    <td class="center">Логический</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td>y</td>
    <td class="center">double</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>
</table>
</div></div>

<p><a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">Создадим</a> новый блок с автокомпилируемой моделью, зададим для него запуск
по сигналу и введем в его модель указанную структуру переменных. На
<a href="um_3_3.htm#pic8" title="Окно редактора пустой модели">вкладке &laquo;<span class="menu">модель</span>&raquo;</a>
в правой части окна редактора введем следующий текст:</p>

<pre class="cpp">  if(Enable) // Передача разрешена
    y=x;
  else       // Передача запрещена
    Ready=0;</pre>

<p>В этой программе при ненулевом <span class="cpp">Enable</span> мы копируем <span class="cpp">x</span> в
<span class="cpp">y</span>, а при нулевом запрещаем работу всех выходных связей, записав 0 в
<span class="cpp">Ready</span>. При запуске модели блока для реакции на такт расчета второму сигнальному выходу
блока, то есть <span class="cpp">Ready</span>, автоматически присваивается единица, поэтому передача данных выходов
блока по связям по умолчанию разрешена, и при <span class="cpp">Enable!=0</span> нам не нужно предпринимать никаких
действий для ее разрешения, как и во всех рассмотренных ранее моделях.</p>

<div class="picright"><div class="container" id="pic3">
<img src="../img/AC_connctrl_test.png" width="190" height="188" alt="Проверка блока управления связью" />
<p id="light_pic3">Рис.&nbsp;380. Проверка блока<br />управления связью</p>
</div></div>


<p>Для проверки созданной модели можно собрать схему, изображенную
на <a href="#pic3" title="Проверка блока управления связью">рис.&nbsp;380</a>.
Здесь &laquo;<span class="rdsvar">Block12</span>&raquo; и &laquo;<span class="rdsvar">Block13</span>&raquo; &ndash; два одинаковых блока управления связью с
нашей моделью, их входы &laquo;<span class="rdsvar">x</span>&raquo; подключены к полям ввода, а выходы &laquo;<span class="rdsvar">y</span>&raquo; &ndash; к
одному и тому же числовому индикатору (обе связи соединены с его входом &laquo;<span class="rdsvar">v</span>&raquo;). Входы
&laquo;<span class="rdsvar">Enable</span>&raquo; наших блоков соединены с выходами &laquo;<span class="rdsvar">Down</span>&raquo; двух стандартных библиотечных
кнопок, в настройках которых установлены флажки &laquo;<span class="menu">переключающаяся кнопка</span>&raquo;. В этом режиме по
первому щелчку мыши кнопка нажимается и остается нажатой, и ее выход &laquo;<span class="rdsvar">Down</span>&raquo; получает значение 1,
а по второму &ndash; снова переходит в отпущенное состояние, и выход &laquo;<span class="rdsvar">Down</span>&raquo; обнуляется. Если
запустить расчет, на индикаторе будет отображаться значение того поля ввода, для которого нажата соответствующая
ему кнопка. Если изменять значение в поле ввода, подключенном к блоку, кнопка для которого не нажата
(на рисунке – &laquo;<span class="rdsvar">Block13</span>&raquo;), модель этого блока будет запускаться, поскольку у переменной
&laquo;<span class="rdsvar">x</span>&raquo; установлен флажок &laquo;<span class="menu">пуск</span>&raquo;, но, из-за того, что внутри модели в этом случае
&laquo;<span class="rdsvar">Ready</span>&raquo; обнуляется, выход &laquo;<span class="rdsvar">y</span>&raquo; не передается по связи, и индикатор получает значение
с другого соединенного с ним блока, выход &laquo;<span class="rdsvar">Ready</span>&raquo; которого остался равным единице и, поэтому,
связь сработала. Если нажать обе кнопки, будут срабатывать обе выходных связи, и какое именно значение будет
отображаться на индикаторе, предсказать сложно.</p>

<p>В приведенных примерах мы никогда ни к чему не присоединяли выход &laquo;<span class="rdsvar">Ready</span>&raquo;. Его можно использовать
не только для разрешения работы выходных связей, но и как признак того, что блок сработал &ndash; например,
соединить его со входом &laquo;<span class="rdsvar">Start</span>&raquo; следующего блока и, таким образом, задать последовательность
работы блоков, если это необходимо. Пример подобной схемы приведен
на <a href="um_1_4.htm#pic5" title="Две ветви алгебраических блоков с сигналом управления">рис.&nbsp;11</a>
в <a href="um_1_4.htm" title="&sect;1.4. Статические переменные блоков">&sect;1.4</a>, здесь мы его рассматривать не будем, поскольку он не
требует каких-либо специальных действий в программе модели &ndash; это стандартное для
RDS поведение блоков.</p>


</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_7_2_5.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_2_7.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_2_6">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
