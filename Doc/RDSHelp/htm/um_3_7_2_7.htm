<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.7.2.7. Использование входов со связанными сигналами</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7_2">&sect;3.7.2. Работа со статическими переменными блока</a></p>
<div class="level"><p>&sect;3.7.2.7. Использование входов со связанными сигналами</p>
</div>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_7_2_6.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_2_8.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_2_7">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</h3>
<h4 class="off">&sect;3.7.2. Работа со статическими переменными блока</h4>
<h5>&sect;3.7.2.7. Использование входов со связанными сигналами</h5>
<p class="abstract">Описывается работа с входами блока, для которых заданы связанные сигналы &ndash; по этим сигналам можно понять, какие из входов блока сработали в данном такте расчета.</p>


<p>В рассмотренных примерах моделей уже неоднократно использовался
<a href="um_2_9_2.htm#ref3" title="Флаг запуска модели в редакторе переменных блока">флажок &laquo;<span class="menu">пуск</span>&raquo;</a>,
установка которого для входа блока позволяла автоматически запустить модель этого блока в следующем
<a href="um_1_3.htm#ref4" title="Такт расчета">такте расчета</a>, если сработает
<a href="um_2_7_1.htm" title="&sect;2.7.1. Общие принципы создания связей">связь</a>, подключенная к этому входу.
<a href="um_3_7_2_1.htm#pic2" title="Установка запуска по сигналу в окне параметров блока">Отключив для модели блока запуск каждый такт</a>
и установив такие флажки для всех его входов, можно существенно снизить нагрузку на систему: модели будут
запускаться только при срабатывании входных связей, то есть тогда, когда значения входов блоков изменились.</p>

<p>Однако, включение флажка &laquo;<span class="menu">пуск</span>&raquo; не позволяет модели узнать, какие именно из входных связей
сработали. Если блок выполняет сложные и длительные вычисления с несколькими входами, было бы логично
выполнять эти вычисления только для изменившихся значений. Можно, конечно, запоминать прежнее значение каждого входа
и сравнивать его с текущим, выполняя вычисления только для тех входов, для которых эти значения не совпадают.
Однако, этот способ годится только для входов простых типов. Если, например, входами блока являются несколько
<a href="um_3_7_2_3.htm" title="&sect;3.7.2.3. Модели с массивами">матриц</a>, то для хранения их предыдущих значений может потребоваться
много памяти (размер матрицы в RDS ограничен только свободной памятью), да и поэлементное сравнение
сохраненной старой матрицы с новой может потребовать не меньше времени, чем сами вычисления с этой матрицей.</p>

<p>Для решения этой задачи в RDS встроен механизм, позволяющий модели блока узнать, какие именно
входы получили по связям новые значения в конце предыдущего такта расчета. Для этого в редакторе
переменных необходимо связать вход блока с переменной
<a href="um_1_4.htm#light_ref2" title="тип переменной: сигнал">сигнального</a> типа (она может быть входом, выходом или внутренней), задав для
этого входа вместо роли &laquo;вход&raquo; роль &laquo;вход/сигнал&raquo; и указав имя связанной
сигнальной переменной. При срабатывании связи, подключенной к этому входу, в связанную с ним сигнальную
переменную автоматически запишется единица. Разумеется, если необходимо запустить модель при срабатывании связи,
флажок &laquo;<span class="menu">пуск</span>&raquo; у этого входа тоже должен быть установлен. Таким образом, модель блока может
проверить значения связанных с входами сигналов и, обнаружив в некоторых из них единицы, понять, какие именно
входы получили значения по связям в прошлом такте расчета. Выполнив действия, связанные с изменившимися входами,
модель должна обнулить все связанные сигналы, подготовив их к следующему срабатыванию связей. Как и любые
сигнальные переменные, связанные сигналы не могут получить нулевое значение при срабатывании связей &ndash;
получив значение 1, сигнал  сохраняет его до тех пор, пока модель блока самостоятельно не обнулит переменную
(см. <a href="um_3_7_2_6.htm" title="&sect;3.7.2.6. Использование сигналов">&sect;3.7.2.6</a>). На самом деле, единица в связанной сигнальной
переменной указывает не на изменение значения входа, а на то, что сработала связь, подключенная к этому входу:
если по этой связи придет то же самое значение, связанный сигнал все равно взведется. Однако, поскольку модели
блоков чаще всего пишут так, чтобы они срабатывали и активировали свои выходные связи только при необходимости
передать новые значения, срабатывание присоединенной ко входу связи с большой вероятностью говорит о том, что
что-то изменилось. В любом случае, обработка значения входа при срабатывании именно присоединенной к нему
связи меньше нагружает систему, чем та же самая обработка при срабатывании любой связи, присоединенной к блоку.
Несколько входов можно, при желании, связать с одним сигналом, если модель блока должна выполнять одинаковые
действия при изменении любого из этих входов.</p>

<p>В качестве примера использования связанных сигналов создадим модель блока, входами которого будут
вещественные матрицы &laquo;<span class="rdsvar">M1</span>&raquo; и &laquo;<span class="rdsvar">M2</span>&raquo;, а выходом &laquo;<span class="rdsvar">y</span>&raquo; &ndash;
произведение минимального элемента матрицы &laquo;<span class="rdsvar">M1</span>&raquo; и максимального элемента матрицы
&laquo;<span class="rdsvar">M2</span>&raquo; (именно эта модель приводится в примере в
<a href="pm_2_5_7.htm" title="&sect;2.5.7. Использование входов со связанными сигналами">&sect;2.5.7 руководства программиста</a>).
Определение максимального и минимального элемента матриц требует перебора всех их значений, поэтому мы
будем запоминать эти значения во вспомогательных переменных &laquo;<span class="rdsvar">M1min</span>&raquo; и &laquo;<span class="rdsvar">M2max</span>&raquo;,
вычисляя их только при срабатывании связей, соединенных с входами &laquo;<span class="rdsvar">M1</span>&raquo; и
&laquo;<span class="rdsvar">M2</span>&raquo; соответственно. Вход &laquo;<span class="rdsvar">M1</span>&raquo; мы свяжем с сигналом &laquo;<span class="rdsvar">s1</span>&raquo;, вход
&laquo;<span class="rdsvar">M2</span>&raquo; &ndash; с сигналом &laquo;<span class="rdsvar">s2</span>&raquo;, по появлению единиц в этих сигналах мы будем
узнавать о срабатывании соответствующих входных связей.</p>

<p>Таким образом, наш блок будет иметь следующую структуру переменных:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td class="vcenter">Start</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">1</td>
  </tr>

  <tr>
    <td class="vcenter">Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">s1</td>
    <td class="center">Сигнал</td>
    <td class="center">Внутренняя</td>
    <td></td>
    <td class="center">1</td>
  </tr>

  <tr>
    <td>s2</td>
    <td class="center">Сигнал</td>
    <td class="center">Внутренняя</td>
    <td></td>
    <td class="center">1</td>
  </tr>

  <tr>
    <td class="vcenter">M1</td>
    <td class="center">Матрица double</td>
    <td class="center">Вход/сигнал<br />&laquo;s1&raquo;</td>
    <td class="center">&checkmark;</td>
    <td class="center">[&nbsp;]&nbsp;0</td>
  </tr>

  <tr>
    <td class="vcenter">M2</td>
    <td class="center">Матрица double</td>
    <td class="center">Вход/сигнал<br />&laquo;s2&raquo;</td>
    <td class="center">&checkmark;</td>
    <td class="center">[&nbsp;]&nbsp;0</td>
  </tr>

  <tr>
    <td class="vcenter">M1min</td>
    <td class="center">double</td>
    <td class="center">Внутренняя</td>
    <td></td>
    <td class="center">?</td>
  </tr>

  <tr>
    <td class="vcenter">M2max</td>
    <td class="center">double</td>
    <td class="center">Внутренняя</td>
    <td></td>
    <td class="center">?</td>
  </tr>

  <tr>
    <td class="vcenter">y</td>
    <td class="center">double</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">?</td>
  </tr>

</table>
</div></div>

<p>Следует обратить внимание на то, что в качестве начальных значений переменных
&laquo;<span class="rdsvar">M1min</span>&raquo;, &laquo;<span class="rdsvar">M2max</span>&raquo; и &laquo;<span class="rdsvar">y</span>&raquo; указан вопросительный знак, то есть
специальное значение, используемое в качестве индикатора ошибки вычисления (в модели его можно получить из
глобальной переменной <span class="cpp"><a href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a></span>). Действительно, пока максимальный элемент
&laquo;<span class="rdsvar">M2</span>&raquo; и минимальный элемент &laquo;<span class="rdsvar">M1</span>&raquo; не вычислены, мы ничего не можем присвоить ни
внутренним переменным &laquo;<span class="rdsvar">M1min</span>&raquo; и &laquo;<span class="rdsvar">M2max</span>&raquo;, ни их произведению
&laquo;<span class="rdsvar">y</span>&raquo;.</p>

<p>В этой структуре переменных сигналы &laquo;<span class="rdsvar">s1</span>&raquo; и &laquo;<span class="rdsvar">s2</span>&raquo; расположены до входов
&laquo;<span class="rdsvar">M1</span>&raquo; и &laquo;<span class="rdsvar">M2</span>&raquo;, с которыми они связаны. Это не обязательно, но так
удобнее редактировать переменные: при указании в редакторе для входа роли &laquo;вход/сигнал&raquo;,
имя связанного сигнала выбирается из выпадающего списка, в который включаются уже введенные на данный момент
переменные сигнального типа, поэтому лучше, чтобы на момент ввода входа сигнал, который с ним будет связан, уже
был введен в редактор переменных. Если, по каким-либо причинам, необходимо поместить связанные сигналы после входов,
с которыми они связываются (например, если эти связанные сигналы &ndash; тоже входы блока, и разработчик хочет,
чтобы в <a href="um_2_7_1.htm#ref3" title="Меню создания связи">меню присоединения связей</a> они были в конце), можно сначала ввести в
редакторе переменных сигналы, а потом вставить входы в нужное место списка
(см. <a href="um_2_9_2.htm" title="&sect;2.9.2. Редактирование списка переменных блока">&sect;2.9.2</a>).</p>

<p>Сигналам &laquo;<span class="rdsvar">s1</span>&raquo; и &laquo;<span class="rdsvar">s2</span>&raquo; даны единичные начальные значения, чтобы при самом
первом запуске расчета модель блока обработала исходные значения матриц-входов &laquo;<span class="rdsvar">M1</span>&raquo; и
&laquo;<span class="rdsvar">M2</span>&raquo;, как будто связи, подключенные к ним, сработали перед запуском.</p>

<p><a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">Создадим</a> новый блок с автокомпилируемой моделью, зададим для него запуск
по сигналу и введем в его модель указанную выше структуру переменных. На
<a href="um_3_3.htm#pic8" title="Окно редактора пустой модели">вкладке &laquo;<span class="menu">модель</span>&raquo;</a>
в правой части окна редактора введем следующий текст:</p>

<pre class="cpp">  if(s1) // Сработала связь к M1
    { s1=0; // Обнуление сигнала
      // Ищем минимальный элемент в M1 и записываем в M1min
      M1min=<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a>;
      for(int r=0;r&lt;M1.<a class="hidden" href="um_3_7_2_2.htm#light_ref5" title="Функция Rows класса матрицы">Rows</a>();r++)
        for(int c=0;c&lt;M1.<a class="hidden" href="um_3_7_2_2.htm#light_ref4" title="Функция Cols класса матрицы">Cols</a>();c++)
          if(M1min==<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a> || M1min&gt;M1[r][c])
            M1min=M1[r][c];
    }
  if(s2) // Сработала связь к M2
    { s2=0; // Обнуление сигнала
      // Ищем максимальный элемент в M2 и записываем в M2max
      M2max=<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a>;
      for(int r=0;r&lt;M2.<a class="hidden" href="um_3_7_2_2.htm#light_ref5" title="Функция Rows класса матрицы">Rows</a>();r++)
        for(int c=0;c&lt;M2.<a class="hidden" href="um_3_7_2_2.htm#light_ref4" title="Функция Cols класса матрицы">Cols</a>();c++)
          if(M2max==<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a> || M2max&lt;M2[r][c])
            M2max=M2[r][c];
    }
  // Перемножаем максимальный и минимальный элементы матриц
  if(M1min!=<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a> &amp;&amp; M2max!=<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a>)
    y=M1min*M2max;
  else
    y=<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a>;</pre>

<p>Эта программа состоит из трех частей. Сначала мы проверяем переменную <span class="cpp">s1</span> &ndash;
если ее значение не нулевое, значит, сработала связь, подключенная ко входу <span class="cpp">M1</span>, и мы
перебираем все элементы матрицы <span class="cpp">M1</span> (работа с матрицами описана
в <a href="um_3_7_2_2.htm" title="&sect;3.7.2.2. Модели с матрицами">&sect;3.7.2.2</a>), ищем среди них минимальный и записываем во внутреннюю
переменную <span class="cpp">M1min</span>. Значение <span class="cpp">s1</span> мы при этом обнуляем
&ndash; кроме модели блока, это сделать некому. Затем, точно так же, при ненулевом значении <span class="cpp">s2</span>
мы находим максимальное значение <span class="cpp">M2</span> и записываем его в <span class="cpp">M2max</span>.
Если какая-либо из входных матриц останется пустой, в соответствующей ей внутренней переменной останется значение
<span class="cpp">rdsbcppHugeDouble</span>, присвоенное ей перед циклом: для пустой матрицы значение максимального
или минимального элемента не может быть определено, поэтому мы пишем в переменную значение-индикатор ошибки. В
конце программы мы перемножаем <span class="cpp">M1min</span> и <span class="cpp">M2max</span>, если обе они
не равны <span class="cpp">rdsbcppHugeDouble</span>, то есть если определен и минимальный элемент первой матрицы,
и максимальный элемент второй. В противном случае мы выдаем на выход значение-индикатор ошибки
<span class="cpp">rdsbcppHugeDouble</span>.</p>

<p>Таким образом, единственная операция, всегда выполняющаяся в такте расчета &ndash; это перемножение
<span class="cpp">M1min</span> и <span class="cpp">M2max</span>. Поиск минимального элемента в
<span class="cpp">M1</span> выполняется только при срабатывании подключенной к ней связи, так же как и
поиск максимального элемента <span class="cpp">M2</span>. Если значение на одном из входов меняется редко,
перебор значений этой матрицы тоже будет выполняться редко, что увеличит производительность системы. В данном
случае выигрыш будет незначительным, однако, если бы вычисления с матрицей были сложнее (например,
необходимо было бы вычислять ее определитель или обратную ей матрицу), прирост быстродействия был
бы ощутимым.</p>

<p>Для тестирования созданной модели можно собрать схему, изображенную
на <a href="#pic1" title="Тестирование модели, вычисляющей произведение минимального элемента одной матрицы и максимального элемента другой">рис.&nbsp;381</a>.
В ней к входам нашего блока присоединены стандартные блоки ввода матриц, а к выходу &ndash; числовой индикатор.
Запустив расчет и изменяя значения в матрицах, можно наблюдать изменения на индикаторе.</p>

<div class="pic"><div class="container" id="pic1">
<img src="../img/AC_matrminmax_test.png" width="469" height="327" alt="Тестирование модели, вычисляющей произведение минимального элемента одной матрицы и максимального элемента другой" />
<p id="light_pic1">Рис.&nbsp;381. Тестирование модели, вычисляющей произведение минимального<br />элемента одной матрицы и максимального элемента другой</p>
</div></div>


</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_7_2_6.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_2_8.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_2_7">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
