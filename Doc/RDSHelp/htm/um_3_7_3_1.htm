<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.7.3.1. Подключение к динамической переменной</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7_3">&sect;3.7.3. Работа с динамическими переменными</a></p>
<div class="level"><p>&sect;3.7.3.1. Подключение к динамической переменной</p>
</div>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_7_2_8.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_3_2.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_3_1">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</h3>
<h4>&sect;3.7.3. Работа с динамическими переменными</h4>
<p class="abstract">Описывается работа с динамическими переменными, то есть с переменными, которые модели блоков создают и уничтожают в процессе работы. Модели могут создавать такие переменные в корневой или родительской подсистеме блока, поэтому несколько блоков могут получить доступ к одной и той же динамической переменной и использовать ее для связи.</p>
<h5>&sect;3.7.3.1. Подключение к динамической переменной</h5>
<p class="abstract">Описывается получение данных из динамической переменной, созданной каким-либо другим блоком.</p>


<p>Принцип действия динамических переменных подробно рассматривается в
<a href="um_1_5.htm" title="&sect;1.5. Динамические переменные">&sect;1.5 описания пользователя</a> и еще подробнее &ndash;
в <a href="pm_index.htm#light_htm:pm_2_6" title="&sect;2.6. Динамические переменные">&sect;2.6 руководства программиста</a>. Коротко напомним: динамическая переменная
&ndash; это скрытая от пользователя переменная, общая для нескольких блоков, через которую они могут
обмениваться информацией без использования
<a href="um_2_7_1.htm" title="&sect;2.7.1. Общие принципы создания связей">связей</a>. Какой-то один блок создает такую переменную,
после чего он сам и другие блоки, зная имя этой переменной и ее
<a href="um_1_4.htm#ref1" title="Типы переменных блока">тип</a>, могут записывать и считывать ее значения. Блок, записавший в динамическую
переменную новое значение, обычно информирует об этом остальные блоки, использующие эту переменную.
При этом RDS вызывает у моделей этих блоков реакцию на специальное событие
&laquo;изменение динамической переменной&raquo;
(<span class="cpp"><a href="ac_RDS_BFM_DYNVARCHANGE.htm" title="&sect;3.8.3.7. Изменение динамической переменной">RDS_BFM_DYNVARCHANGE</a></span>), в которой они
считывают новое значение и используют его в расчете. Динамическая переменная обычно создается внутри
<a href="um_1_2.htm#ref11" title="Корневая подсистема">корневой подсистемы</a>
схемы или
<a href="um_1_2.htm#ref13" title="Родительская подсистема">родительской подсистемы</a>
создавшего ее блока (блок может создать динамическую переменную
и внутри самого себя, но этот вариант используется крайне редко), при этом она доступна всем блокам,
находящимся в одной с ней подсистеме или в подсистемах, вложенных в эту подсистему на любом уровне.
<span id="ref1">Получение</span>
блоком доступа к динамической переменной называется в RDS
<span class="term" id="light_ref1">подпиской</span> на переменную: модель блока сообщает имя
переменной, ее тип и подсистему, в которой ее нужно искать, а RDS связывает блок с этой переменной,
если она существует. Если переменная не найдена, RDS запомнит факт подписки и предоставит блоку доступ
к переменной, как только она появится. Таким образом, не важно, какое событие произойдет в схеме первым:
создание динамической переменной одним блоком или подписка на нее другим: в конце концов связь блока с
переменной будет установлена. Чаще всего блоки используют подписку с поиском по иерархии: при этом
переменная с заданными именем и типом сначала ищется в родительской подсистеме подписывающегося блока,
затем &ndash; в родительской подсистеме этой подсистемы и т.д. вплоть до корневой подсистемы. Этот механизм
позволяет разместить блок, использующий переменную, в любой подсистеме, вложенной в ту, в которой находится
блок-создатель этой переменной. При этом в разных подсистемах схемы могут находиться динамические переменные с
одинаковыми именами, и блоки в этих подсистемах и подсистемах, вложенных в них, будут видеть ближайшую к
ним переменную.</p>

<p><span id="ref2">Среди</span>
<span id="ref3">стандартных</span> блоков, работающих с динамическими переменными, самую важную роль играет
<span id="light_ref2">блок-планировщик</span> динамического расчета. Он создает в своей подсистеме
вещественную (double) переменную &laquo;<span class="rdsvar"><span id="light_ref3">DynTime</span></span>&raquo;,
в которую постоянно записывает значение условного системного времени (подробнее моделирование длящихся во
времени процессов с использованием этой переменной описывается
в <a href="um_index.htm#light_htm:um_3_7_4" title="&sect;3.7.4. Моделирование длящихся во времени процессов">&sect;3.7.4</a>). Планировщик изменяет это значение с шагом и
скоростью, заданными в его настройках
(<a href="#pic1" title="Блок-планировщик и его самые важные параметры">рис.&nbsp;385</a>) &ndash; таким образом, можно настраивать дискретность изменения
времени в системе и соотношение этого времени с реальным.</p>

<div class="pic"><div class="container" id="pic1">
<img src="../img/AC_RTP.png" width="723" height="334" alt="Блок-планировщик и его самые важные параметры" />
<p id="light_pic1">Рис.&nbsp;385. Блок-планировщик и его самые важные параметры</p>
</div></div>


<p>Параметр &laquo;<span class="menu">значение шага расчета</span>&raquo; задает дискретность изменения системного времени, то есть
размер интервала между соседними его отсчетами. Если, например, задать шаг расчета равным 0.1, динамическая
переменная &laquo;<span class="rdsvar">DynTime</span>&raquo; будет принимать значения 0, 0.1, 0.2, 0.3 и т.д. Увеличение значения
времени на шаг расчета будет происходить не в каждом <a href="um_1_3.htm#ref4" title="Такт расчета">такте расчета</a>, даже если
включен флажок
&laquo;<span class="menu">новый шаг &ndash; каждый такт расчета</span>&raquo; (использование флажка
&laquo;<span class="menu">по сигналу готовности</span>&raquo; требует дополнительных соединений и здесь не рассматривается). Во-первых,
если включен флажок &laquo;<span class="menu">дополнительные такты</span>&raquo;, между изменениями &laquo;<span class="rdsvar">DynTime</span>&raquo; будет
выполняться по крайней мере указанное количество тактов расчета &ndash; это нужно для того, чтобы
вычисленные после очередного изменения времени значения распространились по длинным цепочкам соединенных блоков.
Во-вторых, если включен флажок &laquo;<span class="menu">синхронизация с реальным временем</span>&raquo;, планировщик будет
согласовывать изменение &laquo;<span class="rdsvar">DynTime</span>&raquo; с системными часами и введенным в настройках
множителем задержки. При множителе задержки, равном единице, системное время будет примерно совпадать с
реальным: увеличив &laquo;<span class="rdsvar">DynTime</span>&raquo; на заданное значение шага, планировщик будет ждать,
когда по системным часам пройдет это же самое время. При множителе задержки, меньшем единицы, время в системе
будет идти быстрее реального (при множителе 0.1 системное время идет в 10 раз быстрее), при множителе,
большем единицы &ndash; медленнее (множитель 10 заставляет схему считать в 10 раз медленнее реального
времени). Если флажок &laquo;<span class="menu">синхронизация с реальным временем</span>&raquo; выключен, схема будет считать
с максимально возможной скоростью &ndash; это удобно, если нужно не наблюдать за протекающими в схеме
процессами, а получить их графики или конечные значения как можно быстрее.</p>

<p>Флажок &laquo;<span class="menu">завершить расчет по времени</span>&raquo; позволяет автоматически остановить расчет при
достижении переменной &laquo;<span class="rdsvar">DynTime</span>&raquo;, то есть системным временем, заданного значения.
При этом, если включен дополнительный флажок &laquo;<span class="menu">остановить процесс моделирования</span>&raquo;, RDS выйдет из
<a href="um_1_3.htm#ref3" title="Режим расчета">режима расчета</a>
и вернется в
<a href="um_1_3.htm#ref2" title="Режим моделирования">режим моделирования</a>. За редкими исключениями, связанными с проведением итеративных
расчетов (например, с использованием стандартных блоков оптимизации), этот дополнительный флажок следует
оставлять включенным.</p>

<p>Многие библиотечные блоки в RDS (графики, генераторы, динамические блоки) полагаются на наличие в
схеме блока-планировщика. Точнее, им необходимо наличие динамической переменной &laquo;<span class="rdsvar">DynTime</span>&raquo;,
из которой они берут текущее значение системного времени. Какой именно блок будет обеспечивать создание
этой переменной и увеличение ее с некоторым шагом, этим блокам не важно. При желании, разработчик может
написать собственную модель планировщика и использовать ее в схемах со стандартными блоками. При создании
собственных моделей блоков, которым требуется значение системного времени, следует брать значение времени
именно из переменной &laquo;<span class="rdsvar">DynTime</span>&raquo; &ndash; так эти блоки смогут работать в одной схеме
со стандартными динамическими и с блоком-планировщиком. В интерфейсе редактора модели можно достаточно просто
<a href="um_3_6_3.htm" title="&sect;3.6.3. Динамические переменные блока">добавлять связи блока с динамическими переменными</a>.
После создания такой связи в программе модели для этой переменной будет создаваться объект специального
класса с переопределенными операторами присваивания и приведения типов. Таким образом, во вводимых в
редакторе модели реакциях блока на события можно обращаться к динамической переменной по имени, получая ее
значение и присваивая ей новое, а также вызывая функцию-член ее класса
<span class="cpp"><a href="um_3_7_3_2.htm#ref1" title="Функция NotifySubscribers класса динамической переменной">NotifySubscribers</a></span>,
уведомляющий все использующие ее блоки об изменении значения этой переменной
(см. пример в <a href="um_3_7_3_2.htm" title="&sect;3.7.3.2. Создание динамических переменных">&sect;3.7.3.2</a>).</p>

<p>В качестве простейшего примера блока, использующего значение системного времени, создадим модель
генератора, выдающую на выход синусоиду по формуле <i>A&nbsp;sin(w&nbsp;t)</i>, где <i>t</i> &ndash;
системное время. У нашего блока будет два входа &laquo;<span class="rdsvar">A</span>&raquo; и &laquo;<span class="rdsvar">w</span>&raquo; (амплитуда и
частота сигнала соответственно) и выход &laquo;<span class="rdsvar">y</span>&raquo;. Время мы будем брать из динамической переменной
&laquo;<span class="rdsvar">DynTime</span>&raquo;, поэтому в структуре статических переменных блока переменная для времени не
нужна. Структура переменных нашего блока будет такой:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td class="vcenter">Start</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">A</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">w</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">y</td>
    <td class="center">double</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>
</table>
</div></div>

<p>Здесь мы не устанавливаем флажки &laquo;<span class="menu">пуск</span>&raquo; у добавленных входов блока, поскольку он должен
запускаться при изменении времени, а не при изменении входов (флажок у входа запуска блока &laquo;<span class="rdsvar">Start</span>&raquo;
всегда включен, убрать его нельзя).</p>

<p><a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">Создадим</a> новый блок с автокомпилируемой моделью, зададим для него запуск
по сигналу и введем в его модель указанную выше структуру переменных.
<span id="light_ref4">Для того, чтобы связать блок с переменной времени &laquo;<span class="rdsvar">DynTime</span>&raquo;,
следует выполнить следующие шаги:</span></p>

<ul>
  <li>на вкладке &laquo;<span class="menu">переменные</span>&raquo;
 <a href="um_3_6_1.htm#pic1" title="Элементы окна редактора модели">левой панели редактора модели</a> в нижней ее части
 (см. <a href="um_3_6_3.htm#pic1" title="Список динамических переменных">рис.&nbsp;334</a>)
 нажать кнопку со знаком &laquo;<span class="menu">+</span>&raquo;;</li>

 <li>в открывшемся окне добавления динамической переменной
 (<a href="#pic2" title="Добавление переменной DynTime в блок">рис.&nbsp;386</a>)
 установить флажок &laquo;<span class="menu">стандартная переменная</span>&raquo; и выбрать в выпадающем списке справа от него пункт
 &laquo;динамический расчет &ndash; время&raquo;;</li>

 <li>закрыть окно добавления переменной кнопкой &laquo;<span class="menu">OK</span>&raquo;.</li>
</ul>

<div class="pic"><div class="container" id="pic2">
<img src="../img/AC_AddDynTime.png" width="630" height="364" alt="Добавление переменной DynTime в блок" />
<p id="light_pic2">Рис.&nbsp;386. Добавление переменной &laquo;<span class="rdsvar">DynTime</span>&raquo; в блок</p>
</div></div>


<p>На
<a href="um_3_3.htm#pic8" title="Окно редактора пустой модели">вкладке &laquo;<span class="menu">модель</span>&raquo;</a>
в правой части окна редактора введем следующий текст:</p>

<pre class="cpp">  y=A*sin(w*DynTime);</pre>

<p>Здесь мы в качестве значения времени подставили имя переменной <span class="cpp">DynTime</span>. После
всех этих действий, если все выполнено правильно, окно редактора модели должно иметь вид, изображенный
на <a href="#pic3" title="Окно редактора модели генератора синусоиды">рис.&nbsp;387</a>.</p>

<div class="pic"><div class="container" id="pic3">
<img src="../img/AC_AsinWt_editor.png" width="643" height="423" alt="Окно редактора модели генератора синусоиды" />
<p id="light_pic3">Рис.&nbsp;387. Окно редактора модели генератора синусоиды</p>
</div></div>


<p>Прежде чем проверять работу созданной модели, следует обратить внимание на два важных момента. Во-первых,
что будет, если в схеме, в которой находится наш блок, будет отсутствовать блок-планировщик, а, следовательно,
и переменная &laquo;<span class="rdsvar">DynTime</span>&raquo;? Во-вторых, для нашего блока
<a href="um_3_7_2_1.htm#pic2" title="Установка запуска по сигналу в окне параметров блока">задан запуск по сигналу</a>, а не каждый такт,
значит, реакция на такт расчета будет вызываться только при поступлении сигнала на вход &laquo;<span class="rdsvar">Start</span>&raquo;
&ndash; как же модель запустится при изменении &laquo;<span class="rdsvar">DynTime</span>&raquo;?</p>

<p>Любая модель блока, работающая с динамическими переменными, должна в обязательном порядке проверять
существование этих переменных перед обращение к ним &ndash; таковы правила создания моделей в RDS.
Кроме того, крайне желательно, чтобы модель реагировала на событие
<span class="cpp"><a href="ac_RDS_BFM_DYNVARCHANGE.htm" title="&sect;3.8.3.7. Изменение динамической переменной">RDS_BFM_DYNVARCHANGE</a></span>, наступающее
при изменении любой динамической переменной, на которую подписан блок. Мы не включили в модель
ни проверку существования &laquo;<span class="rdsvar">DynTime</span>&raquo;, ни реакцию на указанное событие, поскольку при
параметрах модели по умолчанию (а мы их не меняли) блок автокомпиляции сделает это за нас. Вызовем из
редактора
<a href="um_3_6_7.htm" title="&sect;3.6.7. Параметры модели">окно параметров модели</a>
пунктом меню &laquo;<span class="menu">модель | параметры модели</span>&raquo; и рассмотрим те из них, которые связаны с
динамическими переменными
(<a href="#pic4" title="Параметры, обеспечивающие работу модели с динамическими переменными">рис.&nbsp;388</a>).</p>

<div class="pic"><div class="container" id="pic4">
<img src="../img/AC_AsinWt_params.png" width="472" height="365" alt="Параметры, обеспечивающие работу модели с динамическими переменными" />
<p id="light_pic4">Рис.&nbsp;388. Параметры, обеспечивающие работу модели<br />с динамическими переменными</p>
</div></div>


<p><span id="ref5">По</span>
умолчанию в модели установлен флажок &laquo;<span class="menu">не реагировать на события без динамических переменных</span>&raquo;,
поэтому введенная нами реакция на такт расчета выполнится только в том случае, если переменная
&laquo;<span class="rdsvar">DynTime</span>&raquo; будет существовать. Именно этот флажок позволяет нам не вставлять в
программу проверку существования &laquo;<span class="rdsvar">DynTime</span>&raquo;, которая выглядела бы так:</p>

<pre class="cpp">  if(DynTime.<span id="light_ref5">Exists</span>())
    y=A*sin(w*DynTime);</pre>

<p>Включение этого флажка позволяет не заботиться о таких проверках, и это сильно облегчает написание
моделей. Тем не менее, это не всегда хорошо: в некоторых случаях при отсутствии переменной имеет
смысл привлечь к этому факту внимание пользователя. Например, стандартный график, отображающий зависимость
какого-либо значения от времени, при отсутствии в схеме переменной &laquo;<span class="rdsvar">DynTime</span>&raquo;
<a href="um_3_7_9.htm" title="&sect;3.7.10. Пометки на блоках">рисует поверх себя</a>
иконку с восклицательным знаком и выводит сообщение об ошибке во
<a href="um_3_7_8.htm" title="&sect;3.7.9. Всплывающие подсказки">всплывающей подсказке</a>.
Без этого пользователь не сразу смог бы догадаться, почему после запуска расчета график не
строится. Чтобы нарисовать что-нибудь поверх изображения блока, модели необходимо реагировать на
событие дополнительного рисования, а для этого нужно отключить указанный флажок, поскольку он
блокирует реакции на все события, кроме
<a href="ac_RDS_BFM_INIT.htm" title="&sect;3.8.2.1. Инициализация блока">инициализации</a> и
<a href="ac_RDS_BFM_CLEANUP.htm" title="&sect;3.8.2.2. Очистка данных блока">очистки</a>.
Разумеется, при этом все проверки в программах реакций придется выполнять вручную.</p>

<p>Флажок &laquo;<span class="menu">автозапуск при изменении динамических переменных</span>&raquo;, тоже включенный по умолчанию,
автоматически добавляет в модель реакцию на
<a href="ac_RDS_BFM_DYNVARCHANGE.htm" title="&sect;3.8.3.7. Изменение динамической переменной">событие изменения динамической переменной</a>, в которой сигналу
запуска блока &laquo;<span class="rdsvar">Start</span>&raquo; присваивается единица. Эта реакция не отображается в редакторе
модели, но, при желании, ее можно увидеть, просмотрев полный текст формируемой программы пунктом меню
&laquo;<span class="menu">модель | показать текст C++</span>&raquo; и найдя в нем метку
&laquo;<span class="cpp">case RDS_BFM_DYNVARCHANGE</span>&raquo;. Таким образом, при изменении любой динамической переменной,
на которую подписан блок, взведется его сигнал запуска, и в ближайшем такте расчета запустится его модель
(в нашем случае выполнится оператор вычисления значения выхода блока &laquo;<span class="rdsvar">y</span>&raquo;). Отключать этот
флажок и вручную вводить в модель реакцию на событие <span class="cpp">RDS_BFM_DYNVARCHANGE</span> имеет
смысл либо если блок подписан на несколько переменных и необходимо знать, какая из них изменилась, либо
при отсутствии у блока реакции на такт расчета, когда все действия выполняются в реакции на изменение
динамической переменной. Пример использования этой реакции будет приведен в конце этого параграфа.</p>

<p>Вернемся к нашему блоку, в параметрах модели которого оба описанных выше флажка остались установленными
по умолчанию. Для проверки его работы соберем схему, изображенную
на <a href="#pic5" title="Тестирование генератора синусоиды">рис.&nbsp;389</a>.</p>

<div class="pic"><div class="container" id="pic5">
<img src="../img/AC_AsinWt_test.png" width="474" height="200" alt="Тестирование генератора синусоиды" />
<p id="light_pic5">Рис.&nbsp;389. Тестирование генератора синусоиды</p>
</div></div>


<p>В этой схеме к входам &laquo;<span class="rdsvar">A</span>&raquo; и &laquo;<span class="rdsvar">w</span>&raquo; нашего блока подключены поля ввода, а к
выходу &laquo;<span class="rdsvar">y</span>&raquo; &ndash; стандартный график зависимости значения от времени. Рядом с блоком
расположен блок-планировщик (квадрат с изображением изогнутой стрелки). Он не соединен связями с
другими блоками схемы, но без него ни созданный нами блок, ни график работать не будут. Планировщик
можно разместить в любом месте схемы или в любой подсистеме выше по иерархии &ndash; например, в
корневой, если мы собрали нашу схему не в ней. Следует только иметь в виду, что планировщик в
подсистеме может быть только один &ndash; две динамических переменных с именем &laquo;<span class="rdsvar">DynTime</span>&raquo;
в одной подсистеме создать невозможно, и один из планировщиков, если их будет два, не сможет работать.</p>

<p>Дважды щелкнув на планировщике, задав в его параметрах шаг расчета 0.1 и время остановки 10 секунд
(синхронизацию с реальным временем можно включить или выключить по желанию) и запустив расчет,
можно будет увидеть на графике изображение синусоиды с заданными в полях ввода амплитудой и частотой.</p>

<p><span id="light_ref6">Модель нашего блока можно было бы построить и по-другому</span>,
выполняя все
вычисления не в реакции на такт расчета, а в реакции на изменение динамической переменной. Сделаем это,
и введем в модель ручную проверку существования переменной &laquo;<span class="rdsvar">DynTime</span>&raquo;, как было описано выше.
Для этого выполним следующие действия:</p>
<ul>
  <li>сотрем в редакторе модели весь текст, введенный на вкладке &laquo;<span class="menu">модель</span>&raquo;;</li>
  <li>на левой панели редактора выберем
  <a href="um_3_6_4.htm#pic1" title="Список фрагментов программы модели">вкладку &laquo;<span class="menu">события</span>&raquo;</a>,
  раскроем знаком &laquo;<span class="menu">+</span>&raquo; группу &laquo;<span class="menu">моделирование и режимы</span>&raquo; и дважды щелкнем на ее
  последнем подпункте &laquo;<span class="menu">изменение динамической переменной</span>&raquo; &ndash; в правой части редактора
  появится новая вкладка &laquo;<span class="menu">изменение динамической</span>&raquo;;</li>
  <li>на этой вкладке введем следующий текст программы:</li>
</ul>

<pre class="cpp">  if(DynTime.Exists()) // DynTime есть
    y=A*sin(w*DynTime);
  else                 // DynTime нет
    y=<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a>;
  Ready=1;             // Выходные связи должны сработать</pre>

<ul>
  <li>отключим в параметрах модели (пункт меню редактора &laquo;<span class="menu">модель | параметры модели</span>&raquo;) флажки
  &laquo;<span class="menu">не реагировать на события без динамических переменных</span>&raquo; и
  &laquo;<span class="menu">автозапуск при изменении динамических переменных</span>&raquo; &ndash;
  на <a href="#pic4" title="Параметры, обеспечивающие работу модели с динамическими переменными">рис.&nbsp;388</a> они выделены рамками.</li>
</ul>

<p>Теперь у нашей модели нет реакции на такт расчета. Вычисление значения выхода выполняется при изменении
значения динамической переменной во введенной нами новой реакции: если переменная <span class="cpp">DynTime</span>
существует, будет вычислен синус, если нет, на выход будет подано значение переменной
<span class="cpp"><a href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a></span>, указывающее на ошибку (это хуже, чем явное сообщение
пользователю, но лучше, чем ничего). Затем мы присваиваем единицу сигналу готовности блока
<span class="cpp">Ready</span>, чтобы сработали связи, присоединенные к его выходу. Перед вызовом реакции
на такт расчета RDS делает это автоматически, поэтому в предыдущем варианте модели мы не взводили
<span class="cpp">Ready</span>. Теперь мы работаем по изменению динамической переменной, и
<span class="cpp">Ready</span> автоматически не взводится &ndash; мы должны делать это вручную. Если
убрать из программы последний оператор, выход блока будет вычисляться правильно (это можно увидеть,
открыв окно его параметров и просмотрев
<a href="um_2_9_1.htm#pic8" title="Вкладка переменные окна параметров блока">текущие значения переменных</a>
после расчета), но на графике ничего не отобразится &ndash; вычисленное значение не
поступит на график по связи.</p>

<p>Запустив расчет в схеме с новой моделью, мы увидим точно такой же график, что и со старой.</p>

<p>В созданной нами реакции на изменение динамических переменных мы не проверяем, какая именно переменная
изменилась: наш блок подписан на единственную динамическую переменную &laquo;<span class="rdsvar">DynTime</span>&raquo;, поэтому
в такой проверке нет необходимости. Если бы блок одновременно работал с несколькими переменными и выполнял с
ними какие-либо сложные вычисления, имело бы смысл не выполнять действия, связанные с переменными, которые
не изменились &ndash; это сэкономило бы процессорное время. Это сделать достаточно просто: реакция на
изменение динамической переменной вызывается для каждой переменной, на которую подписан блок, при этом
в ее параметрах передается используемый в RDS идентификатор изменившейся переменной. Этот идентификатор
является параметром функции <span class="cpp">rdsbcppDynVarChange</span>, внутрь которой вставляется
введенный пользователем на вкладке &laquo;<span class="menu">изменение динамической</span>&raquo; текст программы. В верхней
части этой вкладки, непосредственно над областью ввода текста, можно увидеть заголовок этой функции,
выглядящий следующим образом:</p>

<pre class="cpp">  // Изменение динамической переменной
  void rdsbcppBlockClass::rdsbcppDynVarChange(<a class="hidden" href="RDS_DYNVARLINK.htm#ref2" title="Указатель на RDS_DYNVARLINK">RDS_PDYNVARLINK</a> Link)</pre>

<p>Параметр <span class="cpp">Link</span> типа <span class="cpp"><a href="RDS_DYNVARLINK.htm#ref2" title="Указатель на RDS_DYNVARLINK">RDS_PDYNVARLINK</a></span> &ndash; это
и есть тот самый идентификатор
переменной, из-за изменения которой вызвана реакция.
<span id="ref7">Идентификатор</span>
любой из динамических переменных блока
можно получить функцией-членом <span class="cpp" id="light_ref7">GetLink</span>, и, если сравнить результат этой
функции с <span class="cpp">Link</span>, можно узнать, не эта ли переменная изменилась. Оператор сравнения для
переменной <span class="cpp">DynTime</span> выглядел бы следующим образом:</p>

<pre class="cpp">  if(DynTime.GetLink()==Link)
    { // Действия при изменении DynTime
      &hellip;
    }</pre>

<p><span id="ref8">Можно</span>
также использовать логическую функцию-член <span class="cpp" id="light_ref8">CheckLink</span>,
которая возвращает истину, если переданный в ее параметре идентификатор совпадает с идентификатором ее
объекта:</p>

<pre class="cpp">  if(DynTime.CheckLink(Link))
    { // Действия при изменении DynTime
      &hellip;
    }</pre>

<p>Следует помнить, что параметр <span class="cpp">Link</span> передается только в реакцию на изменение
динамической переменной, поэтому в других реакциях (например, в реакции на такт расчета) приведенные выше
проверки использовать нельзя. Если вычисления выполняются в реакции на такт расчета, необходимо вводить
в переменные блока какие-либо дополнительные флаги, взводить их в реакции на изменение динамических переменных
и проверять значения этих флагов в такте расчета.</p>

<p>Помимо упомянутых выше функций-членов <span class="cpp">NotifySubscribers</span>,
<span class="cpp">Exists</span>, <span class="cpp">GetLink</span> и <span class="cpp">CheckLink</span>, у
каждого объекта, создаваемого модулем автокомпиляции для динамической переменной, есть функции для создания,
удаления, и получения доступа к переменной вручную. Они используются в тех случаях, когда нельзя жестко указать
имя переменной в самой модели, как в рассмотренном примере. Эти функции и пример их использования описаны
в <a href="um_3_7_7a.htm" title="&sect;3.7.8. Программное управление динамическими переменными">&sect;3.7.8</a>.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_7_2_8.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_3_2.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_3_1">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
