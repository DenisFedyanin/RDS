<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.7.4.1. Общие принципы численного моделирования непрерывных процессов</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7_4">&sect;3.7.4. Моделирование длящихся во времени процессов</a></p>
<div class="level"><p>&sect;3.7.4.1. Общие принципы численного моделирования непрерывных процессов</p>
</div>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_7_3_3.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_4_2.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_4_1">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</h3>
<h4>&sect;3.7.4. Моделирование длящихся во времени процессов</h4>
<p class="abstract">Рассматривается создание динамических блоков &ndash; блоков, моделирующих какие-либо процессы, протекающие во времени и описываемые дифференциальными или разностными уравнениями. Приводятся примеры решения конкретных задач, описывается решения проблем с устойчивостью счета.</p>
<h5>&sect;3.7.4.1. Общие принципы численного моделирования непрерывных процессов</h5>
<p class="abstract">Описываются общие принципы перехода от описания процесса дифференциальными уравнениями к разностным уравнениям, которые можно закладывать в модель блока.</p>


<p>Достаточно часто приходится моделировать процессы, в которых величины, описывающие их, изменяются во 
времени по каким-либо законам. Случаи, когда для каждой величины известна формула закона ее изменения от 
времени, встречаются редко &ndash; как правило, известны связи параметров и состояний процесса друг с другом 
(причем эти связи могут быть довольно сложными), в результате действия которых процесс идет тем или 
иным образом. К тому же, на процесс могут воздействовать различные внешние факторы, законы изменения которых 
не известны в принципе.</p>

<p>Рассмотрим простой пример: некоторый объект двигается по прямой с заданной скоростью. Требуется определить 
положение объекта в заданный момент времени. Из курса физики средней школы известно, что при постоянной 
скорости положение объекта в любой момент времени определяется формулой</p>

<p class="center"><img class="formula" src="../img/Form_ac_1.png" width="154" height="30" alt="x(t)=x0+vt" /></p>

<p class="noindent">где</p>

<div class="tableshift"><div class="tcont">
<table class="listcompact">
  <tr>
    <td class="term"><i>x</i><sub>0</sub></td>
    <td>&ndash; начальное положение объекта на прямой,</td>
  </tr>
  <tr>
    <td class="term"><i>v</i></td>
    <td>&ndash; скорость объекта,</td>
  </tr>
  <tr>
    <td class="term"><i>t</i></td>
    <td>&ndash; время.</td>
  </tr>
</table>
</div></div>

<p><span id="ref1">Если</span>
скорость не постоянна, эту формулу использовать нельзя. В этом случае приходится описывать движение 
объекта <span id="light_ref1">дифференциальным уравнением</span>, то есть уравнением с участием производных. 
Скорость объекта <i>v</i> &ndash; это производная его координаты <i>x</i> по времени <i>t</i> (то есть, фактически, 
&laquo;быстрота изменения координаты&raquo;). При нулевом значении времени объект находится в положении 
<i>x</i><sub>0</sub>. Значит, можно записать дифференциальное уравнение</p>

<p class="center"><img class="formula" src="../img/Form_ac_2.png" width="195" height="60" alt="dx/dt=v, x(0)=x0" /></p>

<p>Таким образом, для определения координаты <i>x</i> объекта в интересующий нас момент времени <i>t</i> 
необходимо вычислить следующий определенный интеграл:</p>

<p class="center"><img class="formula" src="../img/Form_ac_3.png" width="269" height="82" alt="x(t)=x0+Integral{tau=0...t}v(tau) dtau" /></p>

<p>Для некоторых зависимостей скорости от времени <i>v(t)</i> этот интеграл может быть вычислен аналитически. Но, 
к сожалению, значение скорости в каждый момент времени чаще всего само получается в результате решения некоторого 
набора уравнений. Или, что тоже возможно, оно поступает снаружи &ndash; например, в схеме расположен 
блок-рукоятка для задания скорости, и пользователь все время двигает ее, изменяя скорость так, как ему хочется. 
В этом случае приведенное выше дифференциальное уравнение приходится решать одним из известных методов 
численного интегрирования, переходя от непрерывно текущего времени к дискретному. Ниже мы рассмотрим 
примеры такого решения.</p>

<p><span id="ref2">Для</span>
<span id="ref3">численного</span>
решения дифференциальных уравнений мы заменяем непрерывное время дискретным, изменяющимся 
небольшими шагами. Чем меньше будут эти шаги, тем ближе будет дискретное время к непрерывному, и тем 
ближе численное решение уравнения будет к аналитическому. Шаги изменения дискретного времени могут быть как 
постоянными, так и изменяющимися. Для простоты будем считать их постоянными &ndash; тем более, что 
стандартный блок-планировщик, обеспечивающий схему текущим значением времени через динамическую переменную 
&laquo;<span class="rdsvar">DynTime</span>&raquo; (см. <a href="um_3_7_3_1.htm" title="&sect;3.7.3.1. Подключение к динамической переменной">&sect;3.7.3.1</a>), изменяет это время с заданным 
постоянным шагом. Перейдя к такому дискретному времени, мы заменяем дифференциальные уравнения 
<span id="light_ref2">разностными</span>, которые позволяют вычислить значение некоторой переменной на 
следующем шаге по значениям переменных (как данной, так и, возможно, нескольких других) на одном или 
нескольких предыдущих шагах. Существует множество различных методов численного интегрирования, то есть 
способов, позволяющих получить разностные уравнения из дифференциальных, но мы будем использовать самый простой 
из них &ndash; <span id="light_ref3">метод Эйлера</span>. 
Рассмотрим его на примере приведенной выше задачи определения координаты объекта, скорость 
движения которого задается извне.</p>

<p>Переходя к дискретному времени, мы заменяем непрерывное время <i>t</i> набором дискретных значений 
<i>t</i><sub>0</sub>, 
<i>t</i><sub>1</sub>, 
<i>t</i><sub>2</sub>, 
&hellip; 
<i>t</i><sub>k</sub>, 
<i>t</i><sub>k+1</sub>, &hellip; 
В каждый из уже прошедших моментов времени вплоть до текущего момента <i>t</i><sub>k</sub> нам должны быть 
известны значения скорости 
<i>v</i><sub>0</sub>&hellip;<i>v</i><sub>k</sub> 
&ndash; скорость задается 
снаружи исследуемой нами системы, мы можем запоминать всю историю ее изменения, если это необходимо, и всегда 
знаем текущее ее значение. Мы не можем его вычислить, мы можем только получить его откуда-нибудь &ndash; 
например, оно может приходить по связи на вход нашего блока от каких-либо других блоков, от рукоятки, которую 
двигает пользователь, от реального аппаратного датчика скорости и т.п. Наша задача &ndash; получить выражение 
координаты объекта <i>x</i><sub>k+1</sub> в следующий момент времени <i>t</i><sub>k+1</sub>, зная историю 
движения этого объекта, то есть, в общем случае, набор значений его координат 
<i>x</i><sub>0</sub>, 
<i>x</i><sub>1</sub>, &hellip; 
<i>x</i><sub>k</sub> и скоростей 
<i>v</i><sub>0</sub>, 
<i>v</i><sub>1</sub>, &hellip; 
<i>v</i><sub>k</sub> (мы увидим, что в простейшем случае достаточно иметь только предыдущие значения координаты 
и скорости, то есть <i>x</i><sub>k</sub> и <i>v</i><sub>k</sub>). Будем считать, что на интервале времени 
<i>t</i><sub>k</sub>&hellip;<i>t</i><sub>k+1</sub> скорость объекта не меняется и равна 
<i>v</i><sub>k</sub>. Скорость <i>v</i> &ndash; это производная координаты 
<i>x</i> по времени <i>t</i>. Поскольку на указанном интервале она постоянна, можно записать следующее 
выражение:</p>

<p class="center"><img class="formula" src="../img/Form_ac_4.png" width="360" height="77" alt="dx/dt{при t=t[k]...t[k+1]} = (x[k+1]-x[k])/(t[k+1]-t[k])=v[k]" /></p>

<p>Действительно, при постоянной скорости на интервале 
<i>t</i><sub>k</sub>&hellip;<i>t</i><sub>k+1</sub> эта скорость равна отношению изменения координаты 
к изменению времени. Отсюда можно получить необходимое нам выражение для вычисления <i>x</i><sub>k+1</sub>:</p>

<p class="center"><img class="formula" src="../img/Form_ac_5.png" width="264" height="30" alt="x[k+1]=x[k]+(t[k+1]-t[k])v[k]" /></p>

<p>Это и есть разностное уравнение, полученное по методу Эйлера. Для вычисления очередного значения координаты 
<i>x</i><sub>k+1</sub> в момент времени <i>t</i><sub>k+1</sub> нам нужно знать прошедший с 
последнего вычисленного отсчета интервал времени <i>t</i><sub>k+1</sub>&minus;<i>t</i><sub>k</sub>, прошлое значение 
координаты <i>x</i><sub>k</sub> и скорость ее изменения на момент начала интервала 
<i>v</i><sub>k</sub>. В общем виде, если у нас есть дифференциальное уравнение первого порядка (то есть с одной 
производной) вида</p>

<p class="center"><img class="formula" src="../img/Form_ac_6.png" width="393" height="60" alt="dy/dt = f(x,y,z, ... ,t), y(0)=y0" /></p>

<p>где <i>x</i>, <i>y</i>, <i>z</i> &ndash; некоторые переменные, <i>t</i> &ndash; время, а 
<i>f</i> &ndash; известная функция, то разностное уравнение, полученное по методу Эйлера для этого 
дифференциального, будет выглядеть так:</p>

<p class="center"><img class="formula" src="../img/Form_ac_7.png" width="478" height="30" alt="y[k+1]=y[k]+(t[k+1]-t[k])f(x[k],y[k],z[k],...,t[k])" /></p>

<p>При этом функция <i>f</i> может содержать внутри себя любые нелинейные функции или даже сложные алгоритмы 
вычисления. Нелинейность функции <i>f</i>, которая могла бы явиться препятствием для получения аналитического 
решения дифференциального уравнения, не помешает его численному решению. Нужно только правильно подобрать шаг 
расчета, то есть интервал между соседними отсчетами времени, чтобы моделирование процесса давало удовлетворительную 
точность (влияние шага расчета на численное решение показано в примере в 
<a href="um_3_7_4_3.htm" title="&sect;3.7.4.3. Важность правильного выбора шага расчета">&sect;3.7.4.3</a>).</p>

<p><span id="ref4">Если</span>
дифференциальное уравнение имеет больший порядок, надо заменить его на систему дифференциальных уравнений первого 
порядка любым известным способом, и привести эту систему в 
<span id="light_ref4">нормальную форму Коши</span>, то есть в форму, в которой в левой части каждого 
уравнения находится первая производная, а в правых частях производных нет. После этого для каждого уравнения 
получившейся системы методом Эйлера записывается разностное. Допустим, у нас есть система дифференциальных уравнений 
в форме Коши:</p>

<p class="center"><img class="formula" src="../img/Form_ac_8.png" width="571" height="293" alt="dy1/dt=f1(y1,...,yN,x1,...,xM,t) y1(0)=y10, ... dyN/dt=fN(y1,...,yN,x1,...,xM,t) y1(0)=yN0" /></p>

<p class="noindent">где</p>

<div class="tableshift"><div class="tcont">
<table class="listcompact">
  <tr>
    <td class="term"><i>y</i><sub>1</sub>&hellip;<i>y</i><sub>N</sub></td>
    <td>&ndash; вычисляемые переменные (выходы и внутренние),</td>
  </tr>
  <tr>
    <td class="term"><i>x</i><sub>1</sub>&hellip;<i>x</i><sub>M</sub></td>
    <td>&ndash; поступающие снаружи переменные (входы),</td>
  </tr>
  <tr>
    <td class="term"><i>f</i><sub>1</sub>&hellip;<i>f</i><sub>N</sub></td>
    <td>&ndash; известные функции,</td>
  </tr>
  <tr>
    <td class="term"><i>y</i><sup>0</sup><sub>1</sub>&hellip;<i>y</i><sup>0</sup><sub>N</sub></td>
    <td>&ndash; начальные значения вычисляемых переменных,</td>
  </tr>
  <tr>
    <td class="term"><i>t</i></td>
    <td>&ndash; время.</td>
  </tr>
</table>
</div></div>

<p class="noindent">При помощи метода Эйлера из нее можно получить следующую систему разностных уравнений:</p>

<p class="center"><img class="formula" src="../img/Form_ac_9.png" width="612" height="174" alt="y[i,k+1]=y[i,k]+(t[k+1]-t[k])fi(y[1,k],...,y[N,k],x[1,k],...,x[M,k],t[k])" /></p>

<p>Для удобства записи номер отсчета мы здесь перенесли в верхний индекс: 
<i>y</i><sup>k</sup><sub>1</sub> – это не &laquo;<i>y</i><sub>1</sub> в степени <i>k</i>&raquo;, это 
&laquo;<i>k</i>-й отсчет переменной <i>y</i><sub>1</sub>&raquo;.</p>

<p><span id="ref5">Вернемся</span>
к задаче вычисления координат объекта, движущегося с заданной скоростью, разностное уравнение для 
которой мы уже получили. Это разностное уравнение можно практически без изменений перенести в модель блока. 
Есть только одна сложность: в уравнении нам необходим интервал времени между прошлым отсчетом времени 
<i>t</i><sub>k</sub> и новым отсчетом <i>t</i><sub>k+1</sub>. Если новое значение времени 
<i>t</i><sub>k+1</sub> можно взять из динамической переменной &laquo;<span class="rdsvar"><span id="light_ref5">DynTime</span></span>&raquo;, в которую его постоянно 
записывает блок-планировщик (см., например, 
<a href="um_3_7_3_1.htm" title="&sect;3.7.3.1. Подключение к динамической переменной">&sect;3.7.3.1</a>), то прошлый отсчет <i>t</i><sub>k</sub> в явном виде нам взять 
неоткуда. Придется в модели постоянно запоминать текущее значение времени в какой-нибудь внутренней переменной 
блока: когда планировщик изменит &laquo;<span class="rdsvar">DynTime</span>&raquo; и наша модель запустится, в этой внутренней переменной 
окажется значение времени до последнего изменения, что нам и требуется.</p>

<p>Создадим блок, входом которого будет задаваемая скорость &laquo;<span class="rdsvar">v</span>&raquo;, а выходом &ndash; координата 
объекта &laquo;<span class="rdsvar">x</span>&raquo;. Прошлое значение времени для вычисления шага расчета 
<i>t</i><sub>k+1</sub>&minus;<i>t</i><sub>k</sub> будем хранить во внутренней вещественной переменной 
&laquo;<span class="rdsvar">t0</span>&raquo;. Переменную для начального значения координаты объекта создавать не будем: начальное 
значение можно записывать в значение по умолчанию переменной &laquo;<span class="rdsvar">x</span>&raquo; (далее в 
<a href="um_3_7_4_2.htm" title="&sect;3.7.4.2. Система дифференциальных уравнений и задание начальных условий">&sect;3.7.4.2</a> будет приведен пример модели, в которой начальные условия 
считываются из отдельных входов блока). Таким образом, структура переменных нашего блока будет такой:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td class="vcenter">Start</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">v</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">x</td>
    <td class="center">double</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>
  
  <tr>
    <td class="vcenter">t0</td>
    <td class="center">double</td>
    <td class="center">Внутренняя</td>
    <td></td>
    <td class="center">0</td>
  </tr>
</table>
</div></div>

<p>В отличие от многих моделей, описанных ранее, здесь мы не даем сигналу запуска блока &laquo;<span class="rdsvar">Start</span>&raquo; 
единичное начальное значение и не включаем флажок &laquo;<span class="menu">пуск</span>&raquo; у входа блока &laquo;<span class="rdsvar">v</span>&raquo;: наша 
модель работает при изменении времени, и запускать ее при изменении входов бессмысленно. Пока время не изменится, 
новое значение координаты вычислено не будет, поскольку при одинаковых <i>t</i><sub>k+1</sub> и 
<i>t</i><sub>k</sub> разностное уравнение вырождается в 
&laquo;<i>x</i><sub>k+1</sub>&nbsp;=&nbsp;<i>x</i><sub>k+1</sub>&raquo;, то есть координата объекта не изменяется 
&ndash; &laquo;лишний&raquo; запуск модели до приращения времени ничего не испортит, но и не даст ничего 
для расчета. Следует учитывать, что это верно для рассматриваемого здесь метода Эйлера, при использовании других 
методов численного интегрирования может оказаться важным не допускать запуска модели без изменения 
времени. В качестве начального значения переменной &laquo;<span class="rdsvar">x</span>&raquo; мы записали ноль &ndash; считаем, что 
объект движется из начала координат &ndash; но можно ввести любое другое начальное значение. Начальное значение 
переменной &laquo;<span class="rdsvar">t0</span>&raquo; обязательно должно быть нулем &ndash; на первом шаге предыдущее значение времени 
равно нулю.</p>

<p><a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">Создадим</a> новый блок с автокомпилируемой моделью, 
зададим для него <a href="um_3_7_2_1.htm#pic2" title="Установка запуска по сигналу в окне параметров блока">запуск по сигналу</a> 
и введем в редакторе модели указанную выше структуру переменных. 
<a href="um_3_7_3_1.htm#light_ref4" title="Добавление связи с переменной DynTime">Присоединим</a>
блок к динамической переменной 
&laquo;<span class="rdsvar">DynTime</span>&raquo;. Параметры модели, которые она получила по умолчанию, изменять не будем 
&ndash; в результате в нашу модель будет автоматически добавлена проверка существования переменной 
&laquo;<span class="rdsvar">DynTime</span>&raquo; и взведение сигнала запуска при ее изменении, что нам и нужно.</p>

<p>На вкладке &laquo;<span class="menu"><a href="um_3_3.htm#pic8" title="Окно редактора пустой модели">модель</a></span>&raquo; 
редактора необходимо ввести программу, соответствующую полученному нами разностному уравнению</p>

<p class="center"><img class="formula" src="../img/Form_ac_5.png" width="264" height="30" alt="x[k+1]=x[k]+(t[k+1]-t[k])v[k]" /></p>

<p class="noindent">С учетом того, что предыдущее значение времени мы решили хранить во внутренней переменной 
&laquo;<span class="rdsvar">t0</span>&raquo;, модель будет выглядеть так:</p>

<pre class="cpp">  x=x+(DynTime-t0)*v;  // Разностное уравнение
  t0=DynTime;          // Запоминание предудущего отсчета времени</pre>

<p>Можно видеть, что формула для вычисления <span class="cpp">x</span> в точности соответствует разностному 
уравнению. На каждом шаге расчета в <span class="cpp">DynTime</span> будет находиться новое значение времени, 
для которого нужно вычислить новую координату <span class="cpp">x</span>, а в <span class="cpp">t0</span> &ndash; 
значение времени, запомненное при прошлом вычислении (это обеспечивается второй строчкой программы).</p>
  
<p>Для тестирования созданного блока соберем схему, изображенную 
на <a href="#pic1" title="Тестирование вычислителя координаты объекта, движущегося с задаваемой скоростью">рис.&nbsp;397</a>. 
В ней к входу скорости &laquo;<span class="rdsvar">v</span>&raquo; присоединено поле ввода, а выход координаты объекта 
&laquo;<span class="rdsvar">x</span>&raquo; подан на график. На второй график подано значение скорости с поля ввода, которое мы 
будем изменять в процессе расчета. В 
<a href="um_3_7_3_1.htm#pic1" title="Блок-планировщик и его самые важные параметры">параметрах</a> блока-планировщика 
задан шаг расчета 0.1 и время остановки 10. Синхронизация с реальным временем включена, иначе мы не успеем 
изменить скорость на входе блока за время расчета (можно даже замедлить расчет, увеличив в параметрах 
планировщика множитель задержки). На рисунке изображен результат расчета, в процессе которого сначала значение 
на входе блока равнялось двум, после третьей секунды оно было изменено на ноль, после пятой &ndash; на минус 
один (это видно на нижнем графике). В результате в течение первых трех секунд расчета координата объекта 
увеличивалась, затем он остановился (горизонтальная линия на верхнем графике), а затем, после пятой секунды, 
двинулся в обратном направлении с вдвое меньшей, чем в начале, скоростью.</p>

<div class="pic"><div class="container" id="pic1">
<img src="../img/AC_speedint_test.png" width="596" height="342" alt="Тестирование вычислителя координаты объекта, движущегося с задаваемой скоростью" />
<p id="light_pic1">Рис.&nbsp;397. Тестирование вычислителя координаты объекта,<br />движущегося с задаваемой скоростью</p>
</div></div>


<p>Фактически, мы только что создали простейшую модель интегратора &ndash; линейного динамического блока, 
часто используемого при моделировании различных процессов. Из таких блоков можно собирать большие схемы, 
численно решающие различные системы дифференциальных уравнений, но, во многих случаях, гораздо удобнее закладывать 
всю систему уравнений в одну модель блока &ndash; такие примеры будут рассмотрены далее.</p>


<div class="picright"><div class="container" id="pic2">
<img src="../img/AC_RC.png" width="300" height="146" alt="Электрическая схема RC-цепи" />
<p id="light_pic2">Рис.&nbsp;398. Электрическая схема RC-цепи</p>
</div></div>


<p>Разумеется, численно моделировать можно не только процессы в механических системах, вычисляя координаты, 
скорости и ускорения различных объектов или деталей механизмов. Описанным выше способом можно моделировать любые 
процессы, которые описываются системами дифференциальных уравнений: электрические, термодинамические и т.п. 
Рассмотрим, например, электрические процессы, протекающие в стандартной RC-цепи 
(<a href="#pic2" title="Электрическая схема RC-цепи">рис.&nbsp;398</a>) 
и блок, моделирующий эти процессы.</p>

<p>Цепь представляет собой последовательное соединение резистора сопротивлением <i>R</i> и конденсатора емкостью 
<i>C</i>, подключенное к источнику напряжения <i>u</i><sub>ВХ</sub><i>(t)</i>, значение которого будет задаваться 
на входе нашего блока. Напряжение на конденсаторе <i>u</i><sub>C</sub><i>(t)</i> будет выходом нашего блока. При 
изменении напряжения <i>u</i><sub>ВХ</sub> конденсатор будет заряжаться или разряжаться &ndash; именно процесс 
его заряда и разряда мы и будем моделировать.</p>

<p>Сначала составим дифференциальные уравнения, описывающие электрическую схему. Резистор и конденсатор 
соединены последовательно, поэтому сила тока, протекающего через них, одинакова (ток через вольтметр, 
подключенный к конденсатору для измерения <i>u</i><sub>C</sub>, будем считать пренебрежимо малым):</p>
  
<p class="center"><img class="formula" src="../img/Form_ac_10.png" width="202" height="31" alt="iR(t)=iC(t)=i(t)" /></p>

<p>Эта сила тока является функцией времени <i>t</i>. Сумма падений напряжения на резисторе и конденсаторе будет 
равна входному напряжению цепи:</p>

<p class="center"><img class="formula" src="../img/Form_ac_11.png" width="250" height="31" alt="uR(t)+uC(t)=uВХ(t)" /></p>

<p>Сила тока через конденсатор равна его емкости, умноженной на производную напряжения на нем по времени:</p>

<p class="center"><img class="formula" src="../img/Form_ac_12.png" width="176" height="67" alt="i(t)=C duC(t)/dt" /></p>

<p>Падение напряжения на резисторе равно произведению силы тока через него на его сопротивление. 
С использованием предыдущей формулы для силы тока можно записать:</p>

<p class="center"><img class="formula" src="../img/Form_ac_13.png" width="309" height="67" alt="uR(t)=R i(t)=RC duC(t)/dt" /></p>

<p>Таким образом,</p>

<p class="center"><img class="formula" src="../img/Form_ac_14.png" width="493" height="67" alt="uR(t)+uC(t) = RC duC(t)/dt + uC(t) = uВХ(t)" /></p>

<p>Это и есть дифференциальное уравнение, описывающее процессы в RC-цепи. Переписав его в нормальной форме Коши, 
то есть переместив производную в левую часть уравнения, получим:</p>

<p class="center"><img class="formula" src="../img/Form_ac_15.png" width="241" height="65" alt="uR(t)+uC(t) = RC duC(t)/dt + uC(t) = uВХ(t)" /></p>

<p>Для этого дифференциального уравнения должны быть заданы начальные условия &ndash; в данном случае, напряжение 
на конденсаторе в нулевой момент времени. Для простоты будем считать, что конденсатор исходно разряжен, то есть 
<i>u</i><sub>C</sub>(0)=0. Переходя к дискретному времени и заменяя по методу Эйлера производную напряжения 
на отношение его изменения за шаг расчета к изменению времени за этот же шаг, получим:</p>

<p class="center"><img class="formula" src="../img/Form_ac_16.png" width="520" height="80" alt="duC/dt{при t=t[k]...t[k+1]} = (uC[k+1]-uC[k])/(t[k+1]-t[k]) = 1/(RC) (uВХ[k]-uC[k])" /></p>

<p>Таким образом, мы получили следующее разностное уравнение для вычисления очередного (<i>k+</i>1-го) значения 
<i>u</i><sub>C</sub>:</p>

<p class="center"><img class="formula" src="../img/Form_ac_17.png" width="408" height="59" alt="uC[k+1]=uC[k]+(t[k+1]-t[k]) (uВХ[k]-uC[k])/(RC)" /></p>

<p>По этому уравнению легко будет написать модель блока.</p>

<p>Создадим блок, входами которого будет напряжение источника <i>u</i><sub>ВХ</sub><i>(t)</i> &laquo;<span class="rdsvar">Uin</span>&raquo; 
в вольтах, сопротивление резистора &laquo;<span class="rdsvar">R</span>&raquo; в омах и емкость конденсатора &laquo;<span class="rdsvar">C</span>&raquo; в фарадах, 
а выходом &ndash; напряжение на конденсаторе &laquo;<span class="rdsvar">Uc</span>&raquo; в вольтах. Конечно, удобнее было бы задавать 
емкость конденсатора в каких-нибудь более часто используемых единицах &ndash; например, микрофарадах &ndash; но 
мы, для упрощения модели, будем все задавать в единицах СИ. Прошлое значение времени для вычисления шага расчета 
будем, как и в предыдущем примере, хранить во внутренней вещественной переменной &laquo;<span class="rdsvar">t0</span>&raquo;. Начальное 
напряжение на конденсаторе (мы решили считать его исходно разряженным) запишем в значение по умолчанию переменной 
&laquo;<span class="rdsvar">Uc</span>&raquo;. Структура переменных нашего блока будет такой:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td class="vcenter">Start</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">R</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td></td>
    <td class="center">1</td>
  </tr>

  <tr>
    <td class="vcenter">C</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td></td>
    <td class="center">1</td>
  </tr>

  <tr>
    <td class="vcenter">Uin</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">Uc</td>
    <td class="center">double</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>
  
  <tr>
    <td class="vcenter">t0</td>
    <td class="center">double</td>
    <td class="center">Внутренняя</td>
    <td></td>
    <td class="center">0</td>
  </tr>
</table>
</div></div>

<p>Начальные значения входов &laquo;<span class="rdsvar">R</span>&raquo; и &laquo;<span class="rdsvar">C</span>&raquo; мы, на всякий случай, сделаем единицами: 
если мы забудем подключить к этим входам поля ввода, деление на их произведение на вызовет ошибки.</p>

<p><a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">Создадим</a> новый блок с автокомпилируемой моделью, зададим для него 
<a href="um_3_7_2_1.htm#pic2" title="Установка запуска по сигналу в окне параметров блока">запуск по сигналу</a> и введем в редакторе модели указанную 
выше структуру переменных. <a href="um_3_7_3_1.htm#light_ref4" title="Добавление связи с переменной DynTime">Присоединим</a> блок к динамической переменной 
&laquo;<span class="rdsvar">DynTime</span>&raquo;. Параметры модели изменять не будем &ndash; они останутся установленными по умолчанию, 
и наш блок будет автоматически запускаться при каждом изменении времени (то есть на каждом шаге расчета). На 
вкладке &laquo;<span class="menu"><a href="um_3_3.htm#pic8" title="Окно редактора пустой модели">модель</a></span>&raquo; редактора введем программу, соответствующую 
полученному выше разностному уравнению для <i>u</i><sub>C</sub>:</p>

<pre class="cpp">  Uc+=(DynTime-t0)*(Uin-Uc)/(R*C);
  t0=DynTime;</pre>

<p>В первой строчке мы вычисляем новое значение <span class="cpp">Uc</span> на момент времени 
<i>t</i><sup>k+1</sup>, во второй &ndash; запоминаем текущее время в <span class="cpp">t0</span>, чтобы на 
следующем шаге расчета вычесть его из изменившегося времени и получить величину шага. Для упрощения примера в 
этой модели мы не сравниваем входы блока <span class="cpp">Uc</span>, <span class="cpp">R</span> и 
<span class="cpp">C</span> с признаком ошибки 
<span class="cpp"><a href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a></span> и не проверяем <span class="cpp">R</span> и <span class="cpp">C</span>
на равенство нулю.</p>

<p>Для тестирования модели соберем схему, изображенную 
на <a href="#pic3" title="Тестирование блока моделирования RC-цепи (заряд конденсатора напряжением 10 В в течение 10 секунд, затем разряд в течение еще 10 секунд)">рис.&nbsp;399</a>. 
Зададим сопротивление резистора &laquo;<span class="rdsvar">R</span>&raquo; равным 2 кОм (2000 Ом), емкость конденсатора 
&laquo;<span class="rdsvar">C</span>&raquo; &ndash; 1000 мкФ (0.001 Ф). Шаг расчета в 
<a href="um_3_7_3_1.htm#pic1" title="Блок-планировщик и его самые важные параметры">параметрах</a> блока-планировщика зададим равным 0.1 с, а время 
остановки &ndash; 10 с. Подадим на вход &laquo;<span class="rdsvar">Uin</span>&raquo; напряжение 10 В и запустим расчет 
&ndash; на графике можно будет увидеть заряд конденсатора. Когда расчет остановится, подадим на вход 
блока ноль вольт и снова запустим расчет (время остановки при этом автоматически удвоится, то есть станет 
равным 20 с) &ndash; на графике будет видно, как разряжается ранее заряженный конденсатор.</p>

<div class="pic"><div class="container" id="pic3">
<img src="../img/AC_RC_test.png" width="602" height="201" alt="Тестирование блока моделирования RC-цепи (заряд конденсатора напряжением 10 В в течение 10 секунд, затем разряд в течение еще 10 секунд)" />
<p id="light_pic3">Рис.&nbsp;399. Тестирование блока моделирования RC-цепи (заряд конденсатора<br />напряжением 10 В в течение 10 секунд, затем разряд в течение еще 10 секунд)</p>
</div></div>



</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_7_3_3.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_4_2.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_4_1">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
