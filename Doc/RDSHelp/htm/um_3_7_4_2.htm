<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.7.4.2. Система дифференциальных уравнений и задание начальных условий</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7_4">&sect;3.7.4. Моделирование длящихся во времени процессов</a></p>
<div class="level"><p>&sect;3.7.4.2. Система дифференциальных уравнений и задание начальных условий</p>
</div>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_7_4_1.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_4_3.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_4_2">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</h3>
<h4 class="off">&sect;3.7.4. Моделирование длящихся во времени процессов</h4>
<h5>&sect;3.7.4.2. Система дифференциальных уравнений и задание начальных условий</h5>
<p class="abstract">Рассматривается моделирование процессов, описываемых дифференциальным уравнением второго и выше порядка или системой дифференциальных уравнений. Описывается способ задания начальных условий при помощи отдельных входов блока.</p>


<p>В <a href="um_3_7_4_1.htm" title="&sect;3.7.4.1. Общие принципы численного моделирования непрерывных процессов">&sect;3.7.4.1</a> рассмотрены примеры процессов, описываемых одним
дифференциальным уравнением первого порядка. Если процесс описывается уравнением более высокого порядка
или системой уравнений, принципы моделирования не меняются: порядок уравнения понижается заменой его на
систему уравнений первого порядка, система записывается в
<a href="um_3_7_4_1.htm#ref4" title="Система уравнений в форме Коши">нормальной форме Коши</a>, после чего каждое из получившихся уравнений преобразуется
в разностное одним из методов численного интегрирования &ndash; например,
<a href="um_3_7_4_1.htm#ref3" title="Метод Эйлера">методом Эйлера</a>.</p>

<div class="picright"><div class="container" id="pic1">
<img src="../img/AC_fly.png" width="251" height="204" alt="Тело в свободном полете" />
<p id="light_pic1">Рис.&nbsp;400. Тело в свободном полете</p>
</div></div>


<p>Рассмотрим движение объекта в двух измерениях под действием силы тяжести. Будем рассчитывать полет тела,
брошенного с заданной начальной скоростью <i>v</i><sub>0</sub> под заданным углом &alpha; к горизонту
(<a href="#pic1" title="Тело в свободном полете">рис.&nbsp;400</a>).
Направим ось <i>x</i> горизонтально в направлении полета, <i>y</i> &ndash; вертикально вверх. Чтобы упростить
пример и не связываться с вычислением влияния сопротивления воздуха на полет тела, будем считать, что
все это происходит в безвоздушном пространстве &ndash; например, на Луне
(в <a href="pm_2_14_2.htm" title="&sect;2.14.2. Сброс подсистемы в начальное состояние">&sect;2.14.2 руководства программиста</a> решается такая же задача, но на Земле с
учетом сопротивления воздуха). На тело, находящееся в свободном полете, действует только сила тяжести,
которая сообщает ему ускорение, равное ускорению свободного падения и направленное вертикально вниз.
В горизонтальном направлении никаких сил на тело не действует, и, поэтому, никаких ускорений в горизонтальном
направлении телу не сообщается. Горизонтальное и вертикальное движение тела можно рассматривать независимо,
раскладывая скорость <i>v</i> на горизонтальную и вертикальную проекции
<i>v</i><sub>x</sub> и
<i>v</i><sub>y</sub> соответственно, а ускорение <i>a</i> &ndash; на
<i>a</i><sub>x</sub> и
<i>a</i><sub>y</sub>. При этом горизонтальная проекция ускорения
<i>a</i><sub>x</sub> на всем протяжении полета
равна нулю (нет горизонтальных сил), а вертикальная
<i>a</i><sub>y</sub> &ndash; ускорению свободного падения
<i>g</i> со знаком минус (ось <i>y</i> направлена вверх, ускорение свободного падения &ndash; вниз):</p>

<p class="center"><img class="formula" src="../img/Form_ac_18.png" width="103" height="81" alt="aX=0, aY=-g" /></p>

<p>В каждой проекции ускорение &ndash; это вторая производная координаты по времени. Таким образом,
мы получаем следующую систему дифференциальных уравнений, описывающих движение нашего брошенного тела в
свободном полете (начальные условия пока опустим):</p>

<p class="center"><img class="formula" src="../img/Form_ac_19.png" width="130" height="172" alt="d^2x/dt^2 = 0, d^2y/dt^2 = -g" /></p>

<p>Эта система состоит из двух уравнений второго порядка. Чтобы понизить порядок, вспомним,
что скорость &ndash; это производная координаты по времени, а ускорение &ndash; производная скорости по
времени. Введя в уравнение скорости, мы получим вместо двух уравнений второго порядка четыре
уравнения первого:</p>

<p class="center"><img class="formula" src="../img/Form_ac_20.png" width="174" height="329" alt="dvX/dt = aX = 0, dx/dt=vX, dvY/dt = aY = -g, dy/dt = vY" /></p>

<p>Теперь необходимо определить начальные условия для этой системы. Будем считать, что объект начинает
движение из начала координат, поэтому <i>x</i>(0)=<i>y</i>(0)=0. Начальную скорость объекта разложим на
проекции по осям координат
<i>v</i><sub>0x</sub> и
<i>v</i><sub>0y</sub> &ndash; эти значения и будут начальными условиями для скоростей:</p>

<p class="center"><img class="formula" src="../img/Form_ac_21.png" width="247" height="81" alt="vX(0)=v0X=v0 cos Alpha, vY(0)=v0Y=v0 sin Alpha" /></p>

<p>Таким образом, мы получаем следующую систему дифференциальных уравнений, описывающих движение нашего
брошенного тела в свободном полете:</p>

<p class="center"><img class="formula" src="../img/Form_ac_22.png" width="326" height="329" alt="dvX/dt = 0; vX(0)=v0 cos Alpha, dx/dt=vX; x(0)=0, dvY/dt = -g; vY(0)=v0 sin Alpha, dy/dt = vY;y(0)=0" /></p>

<p>Эта система легко решается аналитически, но мы рассматриваем моделирование процессов с дискретным временем,
поэтому будем решать ее численно. Система записана в нормальной форме Коши, и из нее легко получить разностные
уравнения <a href="um_3_7_4_1.htm#ref3" title="Метод Эйлера">методом Эйлера</a>:</p>

<p class="center"><img class="formula" src="../img/Form_ac_23.png" width="560" height="192" alt="vX[k+1]=vX[k], x[k+1]=x[k]+h vX[k], vY[k+1]=vY[k]-h g, y[k+1]=y[k]+h vY[k], где h=t[k+1]-t[k]" /></p>

<p>Буквой <i>h</i> здесь обозначен шаг расчета, то есть интервал между соседними моментами
дискретного времени. Для удобства записи номер отсчета мы снова перенесли в верхний индекс:
<i>y</i><sup>k</sup> – это не &laquo;<i>y</i> в степени <i>k</i>&raquo;, это
&laquo;<i>k</i>-й отсчет переменной <i>y</i>&raquo;.</p>

<p>Из первого уравнения этой системы видно, что горизонтальная составляющая скорости
<i>v</i><sub>x</sub>
в процессе полета не изменяется и всегда равна
<i>v</i><sub>0</sub> cos &alpha;, следовательно, вычислять
ее в модели блока на каждом шаге не нужно.</p>

<p>Создадим блок, который будет вычислять траекторию полета тела по полученным разностным уравнениям.
Выходами нашего блока будут вещественные переменные &laquo;<span class="rdsvar">x</span>&raquo; и &laquo;<span class="rdsvar">y</span>&raquo;, в
которых мы будем записывать вычисленные координаты тела. В вещественных переменных
&laquo;<span class="rdsvar">vx</span>&raquo; и &laquo;<span class="rdsvar">vy</span>&raquo; мы будем хранить и вычислять проекции скорости тела
&ndash; эти переменные можно сделать внутренними. Для упрощения примера вместо модуля начальной скорости
<i>v</i><sub>0</sub> и ее угла к горизонту &alpha; мы будем просто вводить вычисленные вручную значения
проекций начальной скорости в значения по умолчанию переменных &laquo;<span class="rdsvar">vx</span>&raquo; и &laquo;<span class="rdsvar">vy</span>&raquo;
(позже мы изменим модель так, чтобы можно было непосредственно подавать на вход блока угол и начальную скорость).
Будем считать, что мы бросаем наше тело со скоростью 3 м/с под углом 50&deg; к горизонту
&ndash; при этом начальное значение &laquo;<span class="rdsvar">vx</span>&raquo; должно равняться
3&sdot;cos&nbsp;50&deg;&nbsp;=&nbsp;1.928, а начальное значение &laquo;<span class="rdsvar">vy</span>&raquo; &ndash;
3&sdot;sin&nbsp;50&deg;&nbsp;=&nbsp;2.298.
Кроме указанных переменных нам еще потребуется внутренняя переменная для хранения значения времени
предыдущего шага расчета &ndash; как и в рассмотренных ранее примерах, назовем ее &laquo;<span class="rdsvar">t0</span>&raquo;.</p>

<p>Структура переменных нашего блока будет такой:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td class="vcenter">Start</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">x</td>
    <td class="center">double</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">y</td>
    <td class="center">double</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">vx</td>
    <td class="center">double</td>
    <td class="center">Внутренняя</td>
    <td></td>
    <td class="center">1.928</td>
  </tr>

  <tr>
    <td class="vcenter">vy</td>
    <td class="center">double</td>
    <td class="center">Внутренняя</td>
    <td></td>
    <td class="center">2.298</td>
  </tr>

  <tr>
    <td class="vcenter">t0</td>
    <td class="center">double</td>
    <td class="center">Внутренняя</td>
    <td></td>
    <td class="center">0</td>
  </tr>
</table>
</div></div>

<p><a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">Создадим</a> блок с автокомпилируемой моделью, зададим для него
<a href="um_3_7_2_1.htm#pic2" title="Установка запуска по сигналу в окне параметров блока">запуск по сигналу</a>, введем в редакторе модели
указанную выше структуру переменных и
<a href="um_3_7_3_1.htm#light_ref4" title="Добавление связи с переменной DynTime">Присоединим</a> блок к динамической переменной
&laquo;<span class="rdsvar">DynTime</span>&raquo;.
<a href="um_3_6_7.htm" title="&sect;3.6.7. Параметры модели">Параметры</a>
модели по умолчанию изменять не будем &ndash; она будет
автоматически запускаться при изменении &laquo;<span class="rdsvar">DynTime</span>&raquo; и блокировать реакции при отсутствии
этой переменной в схеме. На вкладке
&laquo;<span class="menu"><a href="um_3_3.htm#pic8" title="Окно редактора пустой модели">модель</a></span>&raquo; редактора необходимо ввести программу,
соответствующую полученным выше разностным уравнением (за исключением уравнения для &laquo;<span class="rdsvar">vx</span>&raquo; &ndash;
эта переменная не изменяется, и уравнение для нее не нужно). В отличие от примеров из
<a href="um_3_7_4_1.htm" title="&sect;3.7.4.1. Общие принципы численного моделирования непрерывных процессов">&sect;3.7.4.1</a>, в этой модели будет три уравнения, а не одно, и,
из-за этого, в написании программы для нее возникает особенность, на которую следует обратить внимание.</p>

<p>Кажется логичным просто перенести уравнения для <span class="cpp">x</span>,
<span class="cpp">vy</span> и <span class="cpp">y</span> в модель в виде операторов присваивания следующим
образом (будем считать, что в переменной <span class="cpp">g</span> записано значение ускорения
свободного падения):</p>

<pre class="cpp">  x=x+(DynTime-t0)*vx;	// x[k+1]  = x[k] + h vx[k]
  vy=vy-(DynTime-t0)*g;	// vy[k+1] = vy[k] – h g
  y=y+(DynTime-t0)*vy;	// y[k+1]  = y[k] + h vy[k]</pre>

<p>Однако, если внимательно посмотреть на вторую и третью строчки этой программы, можно увидеть,
что во второй строчке в переменную <span class="cpp">vy</span> записывается вычисленное значение
<i>v</i><sub>y</sub><sup>k+1</sup>, а в третьей это же самое значение в правой части оператора
присваивания умножается на шаг расчета (<span class="cpp">DynTime-t0</span>) для вычисления
<i>y</i><sup>k+1</sup>. Но ведь в правой части третьего уравнения должно находиться
<i>v</i><sub>y</sub><sup>k</sup>, а не
<i>v</i><sub>y</sub><sup>k+1</sup>. Во второй строчке мы потеряли значение
<span class="cpp">vy</span> на предыдущем шаге расчета, записав в эту же переменную новое значение,
и теперь нам неоткуда взять его для правой части следующего уравнения. Получается, что третье уравнение
будет &laquo;обгонять&raquo; остальные на один шаг расчета. Чем меньше шаг расчета, тем слабее будет
выражен этот эффект &ndash; в такой простой системе мы, вероятнее всего, его даже не заметим. Но,
формально, это является ошибкой, поэтому при численном интегрировании системы нескольких разностных
уравнений нужно разделять переменные прошлого и следующего шага. Проще всего ввести в программе модели
вспомогательные временные переменные и записать все значения (<i>k</i>+1)-го шага в них, а затем, по
окончании расчета, переписать эти значения в соответствующие им статические переменные блока.
В этом случае операторы присваивания в модели выглядели бы так:</p>

<pre class="cpp">  double x_n,y_n,vy_n; // Временные переменные для (k+1)-го шага
  // Расчет значений (k+1)-го шага
  x_n=x+(DynTime-t0)*vx;    // x[k+1]  = x[k] + h vx[k]
  vy_n=vy-(DynTime-t0)*g;   // vy[k+1] = vy[k] – h g
  y_n=y+(DynTime-t0)*vy;    // y[k+1]  = y[k] + h vy[k]
  // Запись вычисленных значений в переменные блока
  x=x_n;
  y=y_n;
  vy=vy_n;</pre>

<p>Здесь мы не теряем значения <i>k</i>-го шага, поскольку вычисленные для
(<i>k</i>+1)-го записываем в другие переменные.</p>

<p>В нашем случае система уравнений очень проста, и желаемого результата можно добиться просто переставив местами
операторы вычисления <span class="cpp">y</span> и <span class="cpp">vy</span>: при этом мы сначала используем
переменную <span class="cpp">vy</span>, в которой хранится
<i>v</i><sub>y</sub><sup>k</sup>, для вычисления нового значения
<span class="cpp">y</span>, и только затем запишем в <span class="cpp">vy</span> новое значение
<i>v</i><sub>y</sub><sup>k+1</sup>. Если бы система была сложнее и уравнения были бы сильнее
связаны друг с другом, перестановка строк программы ничего бы не дала, и пришлось бы вводить
временные переменные, как указано выше.</p>

<p>Таким образом, для расчета по полученным разностным уравнениям на вкладку
&laquo;<span class="menu">модель</span>&raquo; можно ввести следующий текст программы:</p>

<pre class="cpp">  double g=1.62; // Ускорение свободного падения на Луне
  double h;      // Вспомогательная переменная для шага расчета

  h=DynTime-t0;  // Шаг расчета
  t0=DynTime;    // Запоминание текущего времени – на следующем
                 // шаге оно станет предыдущим

  // Вычисления новых значений переменных
  x=x+h*vx;
  y=y+h*vy;
  vy=vy-h*g; // Новое vy вычисляем ПОСЛЕ нового y</pre>

<p>Значение горизонтальной скорости тела не меняется, поэтому оператора присваивания для
<span class="cpp">vx</span> в этой модели нет &ndash; в течение всего полета тело сохраняет одну и ту же
проекцию горизонтальной скорости. У нашего блока нет входов, поэтому мы ничего не сравниваем с признаком ошибки
<span class="cpp"><a href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a></span> &ndash; этому признаку просто неоткуда взяться в переменных блока.</p>

<p>Для тестирования созданной модели можно собрать схему, изображенную
на <a href="#pic2" title="Тестирование модели свободного полета брошенного тела">рис.&nbsp;401</a>.
Входов у нашего блока нет, а к его выходам присоединен график, отображающий зависимость двух переменных от
времени: выход блока &laquo;<span class="rdsvar">x</span>&raquo; подан на горизонтальную координату графика, выход
&laquo;<span class="rdsvar">y</span>&raquo; &ndash; на вертикальную. В <a href="um_3_7_3_1.htm#pic1" title="Блок-планировщик и его самые важные параметры">параметрах</a> блока-планировщика
следует задать шаг расчета 0.01 (наше тело будет лететь довольно быстро, поэтому интервал между дискретными
моментами времени должен быть небольшим) и время остановки 3 секунды. Синхронизацию с реальным временем можно
включить или выключить по желанию. Если запустить расчет, на графике можно будет увидеть траекторию полета
тела. Это парабола, как, согласно теории, и должно быть.</p>

<div class="pic"><div class="container" id="pic2">
<img src="../img/AC_gravity1_test.png" width="404" height="201" alt="Тестирование модели свободного полета брошенного тела" />
<p id="light_pic2">Рис.&nbsp;401. Тестирование модели свободного полета брошенного тела</p>
</div></div>


<p>В этой модели нам пришлось вручную вычислять проекции начальной скорости тела на оси координат и вводить
их в качестве начальных значений в структуру переменных блока &ndash; это не очень удобно. К тому же, если
мы захотим увидеть траекторию полета тела при другой начальной скорости или другом угле броска, нам
придется менять значения внутри структуры переменных и компилировать модель заново. Гораздо лучше сделать
модуль начальной скорости <i>v</i><sub>0</sub> и ее угол к горизонту &alpha; входами блока. Однако,
поскольку это &ndash; начальные условия, нужно будет написать модель блока таким образом, чтобы значения
этих двух входов считывались только в самом начале расчета. Этим мы сейчас и займемся.</p>

<p>Может показаться хорошей идеей считывать модуль и угол начальной скорости со входа блока в реакции модели на
<a href="um_3_6_4.htm#light_ref8" title="Событие запуска расчета">событие запуска расчета</a>
(<span class="cpp"><a href="ac_RDS_BFM_STARTCALC.htm" title="&sect;3.8.3.2. Запуск расчета">RDS_BFM_STARTCALC</a></span>).
Однако, это &ndash;
не самый лучший выбор по двум причинам. Во-первых, это событие возникает не только при самом первом,
но и при повторном запуске расчета. Если остановить расчет, а затем запустить его, реакция модели на запуск
будет вызвана снова. Чтобы отличить первый запуск от продолжения расчета, необходимо анализировать
параметры события. Во-вторых, и это более важная причина,
событие запуска возникает перед тем, как первый такт расчета будет выполнен. Если мы будем подавать значения
на входы блока с полей ввода, все будет в порядке: перед расчетом производится начальная передача данных по
связям, и значения с полей ввода поступят на входы. Если же начальные значения вычисляются цепочкой каких-либо
соединенных блоков (например, значение угла с поля ввода будет подано на вход блока, переводящего радианы в
градусы, а с его выхода &ndash; уже на вход нашего блока), эта цепочка не успеет вычислить правильное значение
начального условия до того, как оно будет считано моделью с входа блока. Действительно, такты расчета,
в которых модели всех блоков цепочки будут выполнять вычисления, начнутся уже после того, как блок среагирует на
событие запуска расчета и считает начальные значения со своих входов. Таким образом, вместо правильных начальных
значений будут считаны значения по умолчанию выходов последнего блока цепочки, непосредственно соединенного с
нашим.</p>

<p><span id="ref1">Если</span>
модель динамического блока (то есть блока, вычисления которого связаны со временем) должна
<span id="light_ref1">получать начальные значения с входов</span>, лучше всего делать это на
первом шаге расчета &ndash; именно на первом шаге, а не на первом
<a href="um_1_3.htm#ref4" title="Такт расчета">такте</a>.
<span id="light_ref2">Шаг расчета</span>
&ndash; это изменение динамической переменной &laquo;<span class="rdsvar">DynTime</span>&raquo;, и на каждый шаг обычно
приходится несколько тактов расчета. Число тактов на один шаг задается в
<a href="um_3_7_3_1.htm#pic1" title="Блок-планировщик и его самые важные параметры">параметрах</a> блока-планировщика в поле ввода
&laquo;<span class="menu">дополнительные такты</span>&raquo;. Кроме того, при первом запуске расчета перед самым первым изменением
&laquo;<span class="rdsvar">DynTime</span>&raquo; блок планировщик выполняет так называемые
<span class="term">начальные такты</span>, то есть пропускает заданное в его настройках число тактов
прежде чем в первый раз увеличивать значение времени. Эти начальные такты нужны как раз для того,
чтобы цепочки блоков, вычисляющих начальные значения, успели сработать. Следовательно, чтобы считать с входов
правильные начальные значения, модель должна дождаться самого первого изменения переменной
&laquo;<span class="rdsvar">DynTime</span>&raquo;. Поскольку величина шага расчета модели заранее не известна, для того, чтобы
определить момент первого шага лучше всего завести в переменных блока специальный логический флаг с
начальным значением 1. Если &laquo;<span class="rdsvar">DynTime</span>&raquo; изменилась, и при этом этот флаг равен единице,
значит, это и есть самый первый шаг расчета &ndash; модель должна считать начальные условия и сбросить флаг в
ноль, чтобы все последующие шаги не считались первыми.</p>

<p>Именно так мы и поступим. Добавим к структуре переменных нашего блока три новых: вещественные входы
&laquo;<span class="rdsvar">v0</span>&raquo; и &laquo;<span class="rdsvar">Alpha</span>&raquo;, на которые будем подавать модуль начальной скорости и
угол броска в градусах соответственно, и внутреннюю логическую переменную &laquo;<span class="rdsvar">Init</span>&raquo; с начальным
значением 1, которую будем использовать как флаг первого шага расчета. В начальные значения
&laquo;<span class="rdsvar">vx</span>&raquo; и &laquo;<span class="rdsvar">vy</span>&raquo; не будем записывать никаких значений, вычисленных вручную
&ndash; теперь все будет выполняться автоматически. Новая структура переменных блока будет такой:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td class="vcenter">Start</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">x</td>
    <td class="center">double</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">y</td>
    <td class="center">double</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">vx</td>
    <td class="center">double</td>
    <td class="center">Внутренняя</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">vy</td>
    <td class="center">double</td>
    <td class="center">Внутренняя</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">t0</td>
    <td class="center">double</td>
    <td class="center">Внутренняя</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">v0</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">Alpha</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">Init</td>
    <td class="center">Логический</td>
    <td class="center">Внутренняя</td>
    <td></td>
    <td class="center">1</td>
  </tr>

</table>
</div></div>

<p>Модель блока изменим следующим образом:</p>

<pre class="cpp">  double g=1.62; // Ускорение свободного падения на Луне
  double h;      // Вспомогательная переменная для шага расчета

  if(DynTime==t0) // Время не изменилось – нет нового
    return;       // шага расчета

  if(Init) // Самый первый шаг расчета (инициализация)
    { if(v0==<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a> || Alpha==<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a>)
        vx=vy=<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a>; // Ошибка на входе
      else
        { double alpha_rad=Alpha*M_PI/180; // В радианы
          // Вычисление начальных проекций скорости
          vx=v0*cos(alpha_rad);
          vy=v0*sin(alpha_rad);
        }
      // Сброс флага инициализации
      Init=0;
    }

  if(vx==<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a> || vy==<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a>)
    { x=y=<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a>; // На входах была ошибка
      return;
    }

  h=DynTime-t0; // Шаг расчета
  t0=DynTime;   // Запоминание текущего времени – на следующем
                // шаге оно станет предыдущим

  // Вычисление по разностным уравнениям
  x=x+h*vx;
  y=y+h*vy;
  vy=vy-h*g; // Новое vy вычисляем ПОСЛЕ нового y</pre>

<p>От предыдущей эта модель отличается тремя добавленными операторами <span class="cpp">if</span>. Если значение
<span class="cpp">DynTime</span> (текущее время) равно значению <span class="cpp">t0</span> (времени на
момент последнего расчета), то шаг расчета не совершен &ndash; модель вызвана в один из дополнительных
или начальных тактов. При этом ни чтения начальных условий, ни вычислений делать не нужно, мы немедленно завершаем
реакцию оператором <span class="cpp">return</span>. Может показаться, что проверка этого условия &ndash; лишняя,
ведь наша модель вызывается не при изменении входов и не каждый такт, а при изменении динамических переменных,
то есть ее единственной динамической переменной &laquo;<span class="rdsvar">DynTime</span>&raquo;, и наша реакция, вроде бы,
не должна выполняться без изменения времени. Однако, такая проверка позволит нашей модели правильно работать даже
если, например, пользователь ошибочно задаст блоку запуск каждый такт &ndash; поскольку этот
<span class="cpp">if</span> не сильно усложняет модель, лучше сделать ее устойчивой к таким ошибкам.</p>

<p>Если время изменилось, реакция выполняется дальше, и проверяется значение флага инициализации
<span class="cpp">Init</span>. Если оно не нулевое (а по умолчанию мы дали этой переменной значение 1),
мы проверяем входы блока на значение ошибки <span class="cpp">rdsbcppHugeDouble</span>, и, если оба они
не равны этому значению, значение входа <span class="cpp">Alpha</span> будет переведено в радианы
(библиотечные функции <span class="cpp">sin</span> и <span class="cpp">cos</span> требуют аргумента в радианах)
и по нему и по значению модуля начальной скорости <span class="cpp">v0</span> будут вычислены исходные
значения проекций скорости <span class="cpp">vx</span> и <span class="cpp">vy</span>. Если хотя бы один из
входов окажется равным <span class="cpp">rdsbcppHugeDouble</span>, расчет будет невозможен, и мы присваиваем это
же значение и <span class="cpp">vx</span>, и <span class="cpp">vy</span>. Затем флаг
<span class="cpp">Init</span> будет сброшен, чтобы инициализация не выполнялась на следующих шагах расчета.</p>

<p>После инициализации начинается фрагмент программы, выполняющийся на каждом шаге расчета. В нем мы сначала
сравниваем <span class="cpp">vx</span> и <span class="cpp">vy</span> с <span class="cpp">rdsbcppHugeDouble</span>
&ndash; такое значение могло оказаться в этих переменных, если при инициализации на одном из входов было
значение ошибки. В этом случае, мы не можем рассчитывать траекторию, поэтому обоим выходам блока присваивается
<span class="cpp">rdsbcppHugeDouble</span> и модель немедленно завершается.</p>

<p>Далее располагается уже знакомый нам фрагмент программы, в котором вычисляется шаг расчета
<span class="cpp">h</span> и значения вертикальной скорости и координат на новом шаге &ndash; он оставлен без
изменений. При данной структуре программы этот фрагмент будет выполнен, только если
<span class="cpp">vx</span> и <span class="cpp">vy</span> были успешно инициализированы.</p>

<p>Эта модель будет работать следующим образом. В тактах расчета, в которых время не изменилось,
она будет завершаться, ничего не вычисляя. Когда время изменится в самый первый раз, сработает проверка
&laquo;<span class="cpp">if(Init)&hellip;</span>&raquo;
и будут вычислены начальные значений проекций скорости тела, а флаг <span class="cpp">Init</span> будет
сброшен, после чего будут вычислены новые значения координат и скорости тела, то есть значения на первом шаге.
При всех последующих изменениях времени проверка для присвоения начальных условий срабатывать не будет из-за
сброшенного флага, и модель будет просто вычислять значения переменных на новом шаге. Если остановить и снова
запустить расчет, ничего не изменится &ndash; флаг <span class="cpp">Init</span> останется сброшенным, и
модель будет работать так, как будто расчет и не останавливался. Если же сбросить расчет, все переменные блока,
включая <span class="cpp">Init</span>, вернутся к исходным значениям, и при следующем запуске проверка
&laquo;<span class="cpp">if(Init)&hellip;</span>&raquo; снова сработает и снова присвоит проекциям
скорости исходные значения.</p>

<p>Для тестирования созданной модели изменим схему: подключим к входам блока &laquo;<span class="rdsvar">v0</span>&raquo; и
&laquo;<span class="rdsvar">Alpha</span>&raquo; поля ввода
(<a href="#pic3" title="Модель свободного полета с внешним заданием начальных условий">рис.&nbsp;402</a>)
и введем в них те же значения, которые использовались при проверке прошлой модели:
3 м/с и 50&deg; соответственно. Параметры блока-планировщика оставим теми же. Запустив расчет, мы
увидим ту же самую параболу.</p>

<div class="pic"><div class="container" id="pic3">
<img src="../img/AC_gravity2_test.png" width="499" height="201" alt="Модель свободного полета с внешним заданием начальных условий" />
<p id="light_pic3">Рис.&nbsp;402. Модель свободного полета с внешним заданием начальных условий</p>
</div></div>


<p>В состав стандартного модуля автокомпиляции входит универсальный
<a href="um_3_9_2.htm" title="&sect;3.9.2. Добавление и изменение шаблонов моделей">шаблон модели</a>
динамического блока, позволяющий несколько быстрее создавать модели, подобные только что описанной.
Использование этого шаблона рассмотрено в <a href="um_3_7_4_4.htm" title="&sect;3.7.4.4. Создание динамического блока по шаблону">&sect;3.7.4.4</a>.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_7_4_1.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_4_3.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_4_2">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
