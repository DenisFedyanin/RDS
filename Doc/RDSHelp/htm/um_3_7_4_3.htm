<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.7.4.3. Важность правильного выбора шага расчета</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7_4">&sect;3.7.4. Моделирование длящихся во времени процессов</a></p>
<div class="level"><p>&sect;3.7.4.3. Важность правильного выбора шага расчета</p>
</div>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_7_4_2.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_4_4.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_4_3">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</h3>
<h4 class="off">&sect;3.7.4. Моделирование длящихся во времени процессов</h4>
<h5>&sect;3.7.4.3. Важность правильного выбора шага расчета</h5>
<p class="abstract">Описываются проблемы, возникающие при выборе слишком большого шага расчета при численном решении дифференциальных уравнений.</p>


<p>При численном моделировании очень важно правильно выбрать шаг расчета. Независимо от используемого метода
численного интегрирования, увеличение шага ведет к тому, что приближенное численное решение будет все сильнее
отличаться от точного. Слишком большой шаг может привести не только к ухудшению точности моделирования, но
и к качественному изменению поведения системы &ndash; полученное при этом решение не будет иметь ничего
общего с моделируемым процессом (чаще всего это проявляется в виде расходящихся колебаний моделируемых величин).
Существуют различные теоретические методы, позволяющие определить минимально допустимый шаг расчета
для данной системы разностных уравнений и данного численного метода, однако проще всего промоделировать
систему с разными шагами: изменение поведения системы укажет на слишком большой шаг.</p>

<div class="picright"><div class="container" id="pic1">
<img src="../img/AC_Weight.png" width="386" height="324" alt="Груз с пружиной на наклонной плоскости" />
<p id="light_pic1">Рис.&nbsp;403. Груз с пружиной на наклонной плоскости</p>
</div></div>


<p>В качестве примера рассмотрим еще одну механическую систему. Имеется груз массой <i>m</i>,
лежащий на наклонной плоскости и прикрепленный к пружине, расположенной параллельно этой плоскости
(<a href="#pic1" title="Груз с пружиной на наклонной плоскости">рис.&nbsp;403</a>).
Массу пружины и сопротивление воздуха учитывать не будем. Мы снова рассматриваем именно механическую систему,
поскольку ее поведение представить проще, чем, например, поведение электрической, и правильность этого поведения
легко проверить повседневным опытом.</p>

<p>На груз на наклонной плоскости будут действовать следующие силы:</p>

<ul>
  <li>сила сжатия или растяжения пружины <i>F</i><sub>П</sub>, направленная вдоль плоскости
  в сторону положения конца пружины при отсутствии ее деформации;</li>

  <li>сила тяжести <i>mg</i>, направленная вертикально вниз;</li>

  <li>сила реакции опоры <i>N</i>, направленная перпендикулярно плоскости (предполагаем, что груз от
  плоскости не отрывается и всегда движется по ней);</li>

  <li>сила трения <i>F</i><sub>ТР</sub>, направленная против движения груза, если он движется (трение
  скольжения), или против приложенной силы, если он покоится (трение покоя);</li>

  <li>заданная внешняя сила <i>F</i><sub>ВХ</sub>, направленная вдоль плоскости.</li>
</ul>

<p>Расположим ось <i>x</i> вдоль плоскости, направив ее вниз и выбрав началом координат оси точку,
в которой деформация пружины равна нулю (то есть точку, в которой будет находиться конец пружины без
груза). Большая часть сил, действующих на груз, будет действовать вдоль этой оси. Исключение составят
сила реакции опоры <i>N</i> и сила тяжести <i>mg</i>. Груз при движении не отрывается от плоскости,
поэтому сумма проекций всех сил на ось, перпендикулярную плоскости, должна быть равна нулю, то
есть перпендикулярная плоскости составляющая силы тяжести должна быть равна силе реакции опоры.
Считая, что плоскость расположена под углом &alpha; к горизонтали, получаем</p>

<p class="center"><img class="formula" src="../img/Form_ac_24.png" width="151" height="26" alt="N = mg cos Alpha" /></p>

<p>Согласно закону Гука, сила пружины <i>F</i><sub>П</sub> будет пропорциональна величине ее деформации:</p>

<p class="center"><img class="formula" src="../img/Form_ac_25.png" width="132" height="23" alt="Fп = -Kп x" /></p>

<p>где <i>K</i><sub>П</sub> &ndash; коэффициент жесткости пружины. Знак минус в формуле указывает на то,
что сила пружины направлена против направления деформации.</p>

<p>Сила трения, препятствующая движению груза, вычисляется по-разному, в зависимости от того, движется
груз или покоится. Если груз движется, на него действует сила трения скольжения, направленная
против направления движения и пропорциональная силе, прижимающей груз к плоскости:</p>

<p class="center"><img class="formula" src="../img/Form_ac_26.png" width="430" height="51" alt="Fтр при v!=0 = -sign(v) Kтр.ск mg cos Alpha" /></p>

<p>где <i>v</i> &ndash; скорость движения груза, <i>K</i><sub>ТР.СК</sub> &ndash; коэффициент трения
скольжения, зависящий от трущихся материалов, а <i>sign</i> &ndash; функция знака, имеющая значение
&minus;1 для отрицательных аргументов, 1 для положительных, и ноль для нулевого аргумента:</p>

<p class="center"><img class="formula" src="../img/Form_ac_27.png" width="283" height="120" alt="sign(x)={-1, x<0; 0, x=0; 1, x>0" /></p>

<p>Согласно этой формуле, при движении груза сила трения направлена против вектора скорости тела и
постоянна по модулю.</p>

<p>Если груз покоится, при приложении к нему сил на него будет действовать сила трения покоя,
направленная против суммы проекций остальных приложенных сил на направление возможного движения, и
равная ей по модулю, до тех пор, пока эта сумма не превысит максимальную силу трения покоя,
вычисляемую по формуле</p>

<p class="center"><img class="formula" src="../img/Form_ac_28.png" width="448" height="34" alt="Fтр.пок.max = Kтр.пок N = Kтр.пок mg cos Alpha" /></p>

<p>где <i>N</i> &ndash; сила реакции опоры (равная по модулю силе, прижимающей груз к плоскости), а
<i>K</i><sub>ТР.ПОК</sub> &ndash; коэффициент трения покоя, который, как и коэффициент трения скольжения,
зависит от трущихся материалов. Пока сумма остальных сил меньше этой максимальной силы, груз будет
оставаться в покое, поскольку сила трения покоя будет равна этой сумме по модулю и противоположна по направлению,
то есть сумма всех сил, действующих на груз, будет равна нулю. Как только сумма остальных сил
превысит максимальную силу трения покоя, груз начнет движение, и на него уже будет действовать сила трения
скольжения. Таким образом, силу трения покоя можно вычислить по следующей формуле:</p>

<p class="center"><img class="formula" src="../img/Form_ac_29.png" width="590" height="96" alt="Fтр при v=0 = {-Fe, |Fe|<=Fтр.пок.max; -sign(Fe)Fтр.пок.max, |Fe|>Fтр.пок.max" /></p>

<p>где <i>F</i><sub>E</sub> &ndash; сумма проекций на ось <i>x</i> всех сил, приложенных к грузу,
кроме силы трения. В момент, когда <i>F</i><sub>E</sub> превысит максимальную силу трения покоя,
сила трения, действующая на груз, скачкообразно изменится с максимальной силы трения покоя на силу
трения скольжения, вычисляемую по другой формуле, приведенной несколькими абзацами выше.</p>

<p>Для простоты будем считать, что и груз, и плоскость сделаны из стали и между ними есть
слой смазки &ndash; в этом случае коэффициент трения покоя можно считать равным коэффициенту трения скольжения
(оба они будут равны 0.16). При этом скачок силы трения в момент страгивания груза с места будет
отсутствовать, и сила трения скольжения будет равна максимальной силе трения покоя. С этим допущением силу
трения, действующую на груз, можно вычислять по следующей формуле:</p>

<p class="center"><img class="formula" src="../img/Form_ac_30.png" width="672" height="152" alt="Fтр = {-sign(v) Kтр.ск mg cos Alpha, v!=0; -Fe, v=0 & |Fe|<=Fтр.max; -sign(Fe)Fтр.max, v=0 & |Fe|>Fтр.max" /></p>

<p>где <i>v</i> &ndash; скорость движения груза, <i>K</i><sub>ТР</sub> &ndash;
коэффициент трения (теперь общий для скольжения и покоя),  <i>F</i><sub>E</sub> &ndash;
сумма проекций на ось <i>x</i> всех остальных сил, приложенных к грузу, а максимальная сила трения
покоя <i>F</i><sub>TP</sub><sup>MAX</sup> теперь вычисляется через коэффициент трения <i>K</i><sub>ТР</sub>:</p>

<p class="center"><img class="formula" src="../img/Form_ac_31.png" width="243" height="35" alt="Fтр.max = Kтр mg cos Alpha" /></p>

<p>Верхняя строчка в формуле для <i>F</i><sub>TP</sub> относится к движению груза, средняя
&ndash; к покою, нижняя &ndash; к моменту страгивания (перехода от покоя к движению).</p>

<p>В сумму проекций <i>F</i><sub>E</sub> входят сила пружины
<i>F</i><sub>П</sub> = &minus; <i>K</i><sub>П</sub> <i>x</i>, внешняя сила
<i>F</i><sub>ВХ</sub> и проекция силы тяжести на ось <i>x</i> (<i>mg</i> sin &alpha;):</p>

<p class="center"><img class="formula" src="../img/Form_ac_32.png" width="324" height="27" alt="Fe = Fвх - Kп x + mg sin Alpha" /></p>

<p>Согласно второму закону Ньютона, сумма всех сил, приложенных к грузу, равна произведению его массы на
ускорение. Рассматривая движение вдоль оси <i>x</i>, получаем дифференциальное уравнение второго порядка,
описывающее нашу систему:</p>

<p class="center"><img class="formula" src="../img/Form_ac_33.png" width="358" height="69" alt="ma = m dv/dt = m d^2x/dt^2 = Fe + Fтр" /></p>

<p>где <i>a</i> &ndash; ускорение груза, а <i>v</i> &ndash; его скорость вдоль оси <i>x</i>.
Преобразуем это уравнение в систему из двух уравнений первого порядка относительно скорости и координаты
груза, и добавим начальные условия для этих переменных (без начальных условий мы не сможем получить
решение уравнения):</p>

<p class="center"><img class="formula" src="../img/Form_ac_34.png" width="315" height="163" alt="{ dv/dt=(Fe+Fтр)/m, v(0)=v0, dx/dt=v, x(0)=x0" /></p>

<p>Применив к этой системе
<a href="um_3_7_4_1.htm#ref3" title="Метод Эйлера">метод Эйлера</a>, получим систему из двух разностных уравнений, позволяющий вычислить
(<i>k</i>+1)-е состояние механической системы по ее <i>k</i>-му состоянию:</p>

<p class="center"><img class="formula" src="../img/Form_ac_35.png" width="266" height="127" alt="{ v[k+1]=v[k]+h(Fe[k]+Fтр[k])/m, x[k+1]=x[k]+h v[k]" /></p>

<p>где <i>h</i> = <i>t</i><sup>k+1</sup>&minus;<i>t</i><sup>k</sup> &ndash; шаг расчета.</p>

<p>Как и в предыдущих примерах, для удобства записи номер отсчета сделан верхним индексом:
<i>v</i><sup>k</sup> &ndash; это не &laquo;скорость груза в степени <i>k</i>&raquo;, это
&laquo;<i>k</i>-й отсчет скорости груза&raquo;.</p>

<p>Теперь можно создать модель блока, который будет рассчитывать движение груза, но прежде решим, как
мы будем определять, покоится груз или движется &ndash; это важно для вычисления силы трения.
Проверять скорость на точное равенству нулю было бы плохой идеей: любые вычисления выполняются с
некоторой погрешностью, поэтому вещественная переменная, в которой мы будем хранить значение
скорости, вряд ли когда-нибудь получит в точности нулевое значение в результате вычислений.
Вместо точной проверки равенства будем считать, что груз остановился, если модуль его скорости
стал меньше очень маленького, заранее заданного, значения <i>v</i><sub>MIN</sub>. В качестве
этого значения можно взять, например, 10<sup>&minus;6</sup> м/с (один микрометр в секунду
можно считать практически полной остановкой). Однако, есть еще одна проблема, которую введение такой
проверки остановки не решит. Мы считаем в дискретном времени с шагом <i>h</i>, и, при достаточно
большой скорости груза, за один шаг скорость может пройти через ноль, но при этом и значение в
начале шага, и значение в его конце по модулю будут больше <i>v</i><sub>MIN</sub>.</p>

<div class="picright"><div class="container" id="pic2">
<img src="../img/AC_Weight_Stop.png" width="359" height="280" alt="Определение момента остановки" />
<p id="light_pic2">Рис.&nbsp;404. Определение момента остановки</p>
</div></div>


<p>На <a href="#pic2" title="Определение момента остановки">рис.&nbsp;404</a>
изображены два отсчета скорости груза: <i>v</i><sup>k</sup> при времени
<i>t</i><sup>k</sup> и <i>v</i><sup>k+1</sup> при времени
<i>t</i><sup>k+1</sup>. Оба значения скорости по модулю больше <i>v</i><sub>MIN</sub>, поэтому
проверка остановки не сработает ни в начале, ни в конце такта. При этом где-то внутри шага расчета
скорость проходит через ноль, то есть груз останавливается. Если при этом сумма сил <i>F</i><sub>E</sub>
окажется меньшей максимальной силы трения покоя <i>F</i><sub>TP</sub><sup>MAX</sup>,
груз останется в покое (приложенных к нему сил будет недостаточно для преодоления трения покоя), и
скорость в момент времени <i>t</i><sup>k+1</sup> будет равна нулю, а не значению
<i>v</i><sup>k+1</sup>, которое мы вычислили, считая, что груз будет продолжать
двигаться весь шаг расчета.</p>

<p>Уменьшение шага расчета позволит обойти эту проблему: если шаг подобран так, чтобы за него
при максимально возможном ускорении скорость груза изменялась бы не более чем на <i>v</i><sub>MIN</sub>,
один из отсчетов около момента остановки обязательно попадет в интервал
&minus;<i>v</i><sub>MIN</sub>&hellip;<i>v</i><sub>MIN</sub>. Однако, есть более простое решение, не
требующее подбора шага: если за шаг расчета скорость изменила свой знак (то есть прошла через ноль),
можно проверить, достаточно ли на этом шаге приложенных сил, чтобы преодолеть трение покоя. Если окажется,
что этих сил недостаточно, значит, в текущем шаге расчета груз остановится. Можно даже более точно
определить время остановки <i>t</i><sub>c</sub>. На всем шаге расчета мы считаем ускорение постоянным,
поэтому скорость будет меняться линейно &ndash; это видно из разностного уравнения для скорости:</p>

<p class="center"><img class="formula" src="../img/Form_ac_36.png" width="571" height="70" alt="v[k+1]=v[k]+h a[k], где h=t[k+1]-t[k], a[k]=(Fe[k]+Fтр[k])/m" /></p>

<p>Груз остановится через промежуток времени <i>h</i><sub>C</sub> после момента времени
<i>t</i><sup>k</sup>, то есть скорость в этот момент будет равна нулю:</p>

<p class="center"><img class="formula" src="../img/Form_ac_37.png" width="148" height="36" alt="0=v[k]+h a[k]" /></p>

<p>Таким образом, интервал времени <i>h</i><sub>C</sub> после <i>k</i>-го отсчета времени,
через который груз остановится
(см. <a href="#pic2" title="Определение момента остановки">рис.&nbsp;404</a>), и момент времени остановки
<i>t</i><sub>c</sub> вычисляются по формулам</p>

<p class="center"><img class="formula" src="../img/Form_ac_38.png" width="262" height="70" alt="hc=-v[k]/a[k], tc=t[k]+hc" /></p>

<p>Деление на ускорение в первой формуле не вызовет проблемы: мы вычисляем время остановки только
тогда, когда значения <i>v</i><sup>k</sup> и <i>v</i><sup>k+1</sup> лежат по разные стороны нуля, то
есть скорость изменяется, а это значит, что ускорение не равно нулю. Координата груза в момент
остановки вычисляется подстановкой <i>h</i><sub>C</sub> вместо <i>h</i> в разностное уравнение для
<i>x</i>:</p>

<p class="center"><img class="formula" src="../img/Form_ac_39.png" width="162" height="36" alt="xc=x[k]+hc v[k]" /></p>

<p>В момент времени <i>t</i><sub>c</sub> мы будем проверять, продолжит ли груз движение, то есть
хватит ли приложенных к нему в положении <i>x</i><sub>C</sub> сил для преодоления трения покоя.</p>

<p>Создадим блок для моделирования поведения этой механической системы. Входами блока будут переменные
&laquo;<span class="rdsvar">x0</span>&raquo; (начальное положение груза на плоскости, м),
&laquo;<span class="rdsvar">v0</span>&raquo; (начальная скорость груза, м/с),
&laquo;<span class="rdsvar">Alpha</span>&raquo; (угол в основании наклонной плоскости, градусов),
&laquo;<span class="rdsvar">Ktr</span>&raquo; (безразмерный коэффициент трения),
&laquo;<span class="rdsvar">Kp</span>&raquo; (жесткость пружины, Н/м),
&laquo;<span class="rdsvar">m</span>&raquo; (масса груза, кг) и
&laquo;<span class="rdsvar">Fvh</span>&raquo; (внешняя сила, Н). Выходами будут
&laquo;<span class="rdsvar">x</span>&raquo; (текущее положение груза, м) и
&laquo;<span class="rdsvar">v</span>&raquo; (текущая скорость груза,  м/с).
Для вычисления шага расчета нам потребуется внутренняя переменная &laquo;<span class="rdsvar">t0</span>&raquo;,
в которой мы будем хранить прошлый отсчет времени <i>t</i><sup>k</sup>
(см. примеры в <a href="um_3_7_4_1.htm" title="&sect;3.7.4.1. Общие принципы численного моделирования непрерывных процессов">&sect;3.7.4.1</a>). Кроме того, поскольку мы считываем
начальные условия с входов блока &laquo;<span class="rdsvar">x0</span>&raquo; и &laquo;<span class="rdsvar">v0</span>&raquo;, нам, как и в примере
из <a href="um_3_7_4_2.htm" title="&sect;3.7.4.2. Система дифференциальных уравнений и задание начальных условий">&sect;3.7.4.2</a>, потребуется внутренний логический флаг инициализации
&laquo;<span class="rdsvar">Init</span>&raquo;. В результате у нас получится следующая структура переменных блока:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr>
    <td class="vcenter">Start</td>
    <td class="center">Сигнал</td>
    <td class="center">Вход</td>
    <td class="center">&checkmark;</td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">Ready</td>
    <td class="center">Сигнал</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">Kp</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">Ktr</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">m</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td></td>
    <td class="center">1</td>
  </tr>

  <tr>
    <td class="vcenter">Fvh</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">Alpha</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">x0</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">v0</td>
    <td class="center">double</td>
    <td class="center">Вход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">Init</td>
    <td class="center">Логический</td>
    <td class="center">Внутренняя</td>
    <td></td>
    <td class="center">1</td>
  </tr>

  <tr>
    <td class="vcenter">x</td>
    <td class="center">double</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">v</td>
    <td class="center">double</td>
    <td class="center">Выход</td>
    <td></td>
    <td class="center">0</td>
  </tr>

  <tr>
    <td class="vcenter">t0</td>
    <td class="center">double</td>
    <td class="center">Внутренняя</td>
    <td></td>
    <td class="center">0</td>
  </tr>

</table>
</div></div>

<p>Переменной &laquo;<span class="rdsvar">m</span>&raquo; мы дали ненулевое начальное значение, чтобы, если мы забудем
подключить к ней поле для ввода массы груза, деление на массу при расчете ускорения в программе
модели не вызвало ошибки.</p>

<p><a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">Создадим</a> блок с автокомпилируемой моделью,
зададим для него <a href="um_3_7_2_1.htm#pic2" title="Установка запуска по сигналу в окне параметров блока">запуск по сигналу</a>,
введем в редакторе модели указанную выше структуру переменных и
<a href="um_3_7_3_1.htm#light_ref4" title="Добавление связи с переменной DynTime">присоединим</a> блок к динамической переменной
&laquo;<span class="rdsvar">DynTime</span>&raquo;.
<a href="um_3_6_7.htm" title="&sect;3.6.7. Параметры модели">Параметры</a> модели по умолчанию изменять не будем &ndash;
она будет автоматически запускаться при изменении &laquo;<span class="rdsvar">DynTime</span>&raquo; и блокировать реакции
при отсутствии этой переменной в схеме.
На вкладке &laquo;<span class="menu"><a href="um_3_3.htm#pic8" title="Окно редактора пустой модели">модель</a></span>&raquo; редактора введем следующий текст:</p>

<pre class="cpp">  double h,Fe,a_rad,Ft,Ft0,vn,a; // Вспомогательные переменные
  double vmin=1e-6; // Порог скорости (меньше - остановка)

  // Макрос для функции sign
  #define sign(x) ((x)<0.0?-1:1)

  if(DynTime==t0) // Время не изменилось
    return;

  if(Init) // Чтение начальных условий с входов
    { v=v0; x=x0;
      Init=0;
    }

  h=DynTime-t0; // Шаг расчета
  t0=DynTime;   // Запоминание времени очередного шага

  // Угол наклонной плоскости в радианах
  a_rad=Alpha*M_PI/180;

  // Максимальная сила трения покоя
  // (считаем ее равной силе трения скольжения)
  Ft0=Ktr*m*9.8*cos(a_rad);

  // Сумма сил кроме силы трения
  Fe=m*9.8*sin(a_rad)+Fvh-Kp*x;

  // Расчет силы трения скольжения/покоя
  if(fabs(v)&lt;vmin) // Покой
    { if(fabs(Fe)&lt;Ft0) // Меньше страгивания
        Ft=-Fe;
      else // Cтрагивание
        Ft=-sign(Fe)*Ft0;
    }
  else // Движение
    Ft=-sign(v)*Ft0;

  a=(Fe+Ft)/m; // Ускорение на этом шаге
  vn=v+h*a;    // Скорость в конце шага

  // Проверка изменения знака скорости (т.е. остановки)
  if(sign(v)!=sign(vn))
    { // Скорость изменила знак внутри шага расчета
      if(fabs(Fe)&lt;Ft0) // Внешние силы меньше max трения
        { // Полная остановка
          double hs;
          hs=-v*m/a; // Время остановки (после t0)
          x=x+hs*v;  // Точка остановки
          v=0;       // Остановились – обнуляем скорость
          return;
        }
    }
  // Скорость не меняла знак или внешние силы больше
  // max силы трения - движение продолжается
  x=x+h*v; // Новое положение груза
  v=vn;    // Новая скорость уже вычислена в vn</pre>

<p>В самом начале этой программы мы вводим несколько вспомогательных переменных, которые будут
использоваться далее. Среди них &ndash; <span class="cpp">vmin</span> со значением
<span class="cpp">1e-6</span> (то есть
1&sdot;10<sup>&minus;6</sup>), которое мы будем использовать как пороговое значение скорости для
определения остановки груза. Затем мы описываем макрос для функции <span class="cpp">sign</span>,
возвращающей знак аргумента &ndash; она потребуется нам для вычисления силы трения и для обнаружения
прохода скорости через ноль. Результат вычисления выражения в этом макросе будет равен
&minus;1 для отрицательных аргументов и 1 для неотрицательных. При равенстве аргумента нулю выражение
должно было бы давать нулевой результат, но в рассмотренных нами формулах это не принципиально, поэтому
мы упростили вычисление <span class="cpp">sign</span>. После описания макроса находятся два уже знакомых
нам по модели из <a href="um_3_7_4_2.htm" title="&sect;3.7.4.2. Система дифференциальных уравнений и задание начальных условий">&sect;3.7.4.2</a> оператора
<span class="cpp">if</span>, необходимых для считывания начальных условий движения из входов
<span class="cpp">x0</span> и
<span class="cpp">v0</span>: первый оператор блокирует выполнение модели, если время не
изменилось с прошлого расчета (<span class="cpp">DynTime==t0</span>), второй
&ndash; переписывает <span class="cpp">x0</span> и <span class="cpp">v0</span> в
<span class="cpp">x</span> и <span class="cpp">v</span> соответственно, если флаг инициализации
<span class="cpp">Init</span> взведен (флаг после этого сбрасывается). Далее, как обычно, вычисляется
шаг расчета <span class="cpp">h</span>, новое значение времени запоминается в переменной
<span class="cpp">t0</span> для следующего шага, после чего начинается основная часть программы,
ответственная за моделирование движения груза.</p>

<p>Прежде всего, угол наклонной плоскости <span class="cpp">Alpha</span> переводится из градусов в
радианы (тригонометрические функции в стандартных библиотеках языка C работают именно с радианами) и
записывается во вспомогательную переменную <span class="cpp">a_rad</span>. Максимальная сила трения покоя
<i>F</i><sub>TP</sub><sup>MAX</sup> записывается в переменную <span class="cpp">Ft0</span>, сумма всех
сил вдоль оси <i>x</i> за исключением силы трения &ndash; в переменную <span class="cpp">Fe</span>.
Затем, в зависимости от состояния груза и приложенных сил, вычисляется сила трения <span class="cpp">Ft</span>.</p>

<p>Если абсолютное значение скорости груза <span class="cpp">v</span> меньше принятого нами порогового
значения <span class="cpp">vmin</span>, мы считаем, что груз покоится &ndash; в этом случае сумма
приложенных сил <span class="cpp">Fe</span> сравнивается с максимальной силой трения покоя
<span class="cpp">Ft0</span>. Если абсолютное значение <span class="cpp">Fe</span> меньше
<span class="cpp">Ft0</span>, приложенных сил недостаточно для страгивания груза с места, и
сила трения в этом случае равна <span class="cpp">-Fe</span> (сила трения компенсирует приложенные силы
и груз остается в покое). Если же <span class="cpp">Fe</span> превышает <span class="cpp">Ft0</span>, груз
начинает движение &ndash; сила трения, действующая на него, равна
<span class="cpp">Ft0</span> по модулю и имеет знак, обратный <span class="cpp">Fe</span>.</p>

<p>Если абсолютное значение скорости больше порога <span class="cpp">vmin</span>, значит, груз
в данный момент движется, и на него действует сила трения скольжения, равная по модулю
<span class="cpp">Ft0</span> (то есть максимальной силе трения покоя, поскольку мы решили считать коэффициенты
трения покоя и скольжения равными) и имеющая знак, обратный скорости.</p>

<p>Зная силу трения <span class="cpp">Ft</span> и сумму остальных сил вдоль оси <i>x</i>
<span class="cpp">Fe</span> (все силы рассчитаны на момент начала шага расчета), мы рассчитываем
ускорение груза <span class="cpp">a</span> (сумма всех сил, деленная на массу) и, по разностному уравнению
для скорости, скорость груза на конец шага расчета <span class="cpp">vn</span>. Теперь нужно проверить,
не остановился ли груз на данном шаге расчета и, если это так, вычислить момент времени остановки
согласно <a href="#pic2" title="Определение момента остановки">рис.&nbsp;404</a>.</p>

<p>Если за шаг расчета скорость поменяла знак (знак <span class="cpp">v</span> не равен знаку
<span class="cpp">vn</span>), значит, скорость груза прошла через ноль. В этом случае сумма сил
<span class="cpp">Fe</span> сравнивается с максимальной силой трения покоя
<span class="cpp">Ft0</span>: если трение покоя превышает сумму остальных сил, груз останется стоять.
При этом вычисляется интервал времени <span class="cpp">hs</span> внутри шага расчета <span class="cpp">h</span>
до момента остановки. Затем этот интервал подставляется в разностное уравнение для координаты
<i>x</i> и вычисляется положение груза на момент остановки &ndash; поскольку он останется стоять, по
крайней мере, до конца шага (и далее, если приложенная сила <span class="cpp">Fvh</span> на следующем
шаге не изменится), это и будет его координатой на момент конца шага. Его скорость на конец шага будет
нулевой, поэтому переменной <span class="cpp">v</span> присваивается ноль, и модель завершается оператором
<span class="cpp">return</span> &ndash; до начала следующего шага расчета больше нечего вычислять.</p>

<p>Если же скорость не меняла знак или максимальная сила трения покоя меньше суммы остальных сил,
груз будет продолжать движение &ndash; в этом случае его новая координата <span class="cpp">x</span>
вычисляется согласно разностному уравнению, а уже полученная новая скорость переписывается из
вспомогательной переменной <span class="cpp">vn</span> в переменную блока <span class="cpp">v</span>.</p>

<p>Для тестирования созданной модели соберем схему, изображенную
на <a href="#pic3" title="Схема для тестирования модели движения груза на пружине">рис.&nbsp;405</a>.
Внешнюю силу &laquo;<span class="rdsvar">Fvh</span>&raquo;, начальное положение груза &laquo;<span class="rdsvar">x0</span>&raquo; и его начальную скорость
&laquo;<span class="rdsvar">v0</span>&raquo; зададим нулевыми &ndash; пусть груз движется из положения покоя в
начале координат. Угол наклона плоскости установим в 45&deg;, массу груза
&ndash; 1 кг, коэффициент трения &ndash; 0.16 (сталь по стали со смазкой), жесткость пружины
&ndash; 5 Н/м (специально возьмем пружину малой жесткости, чтобы смещение груза было побольше). К
выходам координаты &laquo;<span class="rdsvar">x</span>&raquo; и скорости &laquo;<span class="rdsvar">v</span>&raquo; присоединим графики.</p>

<div class="pic"><div class="container" id="pic3">
<img src="../img/AC_sliding_test1.png" width="569" height="393" alt="Схема для тестирования модели движения груза на пружине" />
<p id="light_pic3">Рис.&nbsp;405. Схема для тестирования модели движения груза на пружине</p>
</div></div>


<p>Установим в <a href="um_3_7_3_1.htm#pic1" title="Блок-планировщик и его самые важные параметры">параметрах</a> блока-планировщика время остановки 10 с
и шаг расчета 0.1 с. Запустив моделирование, на графиках мы увидим расходящиеся колебания
(<a href="#pic4" title="Расходящиеся колебания при моделировании с шагом расчета 0.1 секунды">рис.&nbsp;406</a>).
Если не останавливать расчет после десяти секунд, их амплитуда будет увеличиваться бесконечно.</p>

<div class="pic"><div class="container" id="pic4">
<img src="../img/AC_sliding_test2.png" width="569" height="393" alt="Расходящиеся колебания при моделировании с шагом расчета 0.1 секунды" />
<p id="light_pic4">Рис.&nbsp;406. Расходящиеся колебания при моделировании с шагом расчета 0.1 секунды</p>
</div></div>


<p>Но откуда в такой механической системе без подвода энергии извне (мы обнулили внешнюю силу)
могут взяться расходящиеся колебания? В системе есть трение, поэтому, по всем законам физики, груз
должен со временем остановиться, а не наращивать амплитуду колебаний. Дело в том, что шаг расчета в одну
десятую секунды, установленный в параметрах блока-планировщика, слишком велик для заданных нами
параметров груза, плоскости и сил при выбранном методе численного интегрирования. Слишком велики интервалы,
на которых мы считаем скорость и ускорение груза постоянными, поэтому моделирование теряет не только точность,
но и устойчивость &ndash; полученная картина уже не имеет ничего общего с поведением моделируемой системы.
В этом легко убедиться, уменьшив шаг расчета в десять раз &ndash; при шаге в 0.01 с колебания затухают и
груз останавливается
(<a href="#pic5" title="Моделирование с шагом расчета 0.01 секунды">рис.&nbsp;407</a>).</p>

<div class="pic"><div class="container" id="pic5">
<img src="../img/AC_sliding_test3.png" width="569" height="393" alt="Моделирование с шагом расчета 0.01 секунды" />
<p id="light_pic5">Рис.&nbsp;407. Моделирование с шагом расчета 0.01 секунды</p>
</div></div>


<p>С таким значением шага можно моделировать движение груза и из других начальных условий, и меняя внешнюю
силу <span class="cpp">Fvh</span>. Например,
на <a href="#pic6" title="Моделирование с изменением внешней силы">рис.&nbsp;408</a>
начиная с пятой секунды к уже остановившемуся грузу прикладывается постоянная сила в 5 Н &ndash;
груз снова начинает двигаться и останавливается уже в другом положении.</p>

<div class="pic"><div class="container" id="pic6">
<img src="../img/AC_sliding_test4.png" width="569" height="393" alt="Моделирование с изменением внешней силы" />
<p id="light_pic6">Рис.&nbsp;408. Моделирование с изменением внешней силы</p>
</div></div>


<p>Следует учитывать, что изменение других параметров системы, входящих в разностные уравнения
(угла наклона плоскости, коэффициента трения и т.п.) может потребовать подбора другого шага расчета.</p>

<p>Рассмотренный, достаточно простой, пример показывает важность правильного выбора шага расчета.
Слишком большой шаг приводит к потере устойчивости счета. С другой стороны, слишком маленький шаг
приводит к замедлению вычислений. Получив разностные уравнения, теоретически можно определить, как
максимально допустимый шаг расчета зависит от параметров системы. Однако, на практике такие вычисления
могут оказаться слишком сложными, поэтому можно промоделировать систему несколько раз с разными шагами
расчета &ndash; при недопустимо большом шаге поведение системы будет существенно другим, и
это можно будет заметить по графикам процессов в ней.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_7_4_2.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_4_4.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_4_3">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
