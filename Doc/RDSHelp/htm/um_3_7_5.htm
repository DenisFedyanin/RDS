<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.7.5. Блоки, программно рисующие свое изображение</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</a></p>
<div class="level"><p>&sect;3.7.5. Блоки, программно рисующие свое изображение</p>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_7_4_4.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_6.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_5">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</h3>
<h4>&sect;3.7.5. Блоки, программно рисующие свое изображение</h4>
<p class="abstract">Рассматривается создание моделей, программно формирующих изображение блока в подсистеме. Такие модели используются для сложных анимированных блоков-индикаторов. Также описывается введение в модель реакции на изменение размера блока, позволяющей корректировать размеры, заданные пользователем, сохраняя пропорции блока неизменными.</p>


<p>В схемах RDS
<a href="um_1_2.htm#light_ref21" title="Варианты внешнего вида блока">внешний вид</a>
любого блока задается либо прямоугольником с произвольным текстом внутри него, либо векторной картинкой,
либо рисуется программно моделью блока. Прямоугольники с текстом обычно используются в блоках, внешний
вид которых остается неизменным на протяжении всего расчета &ndash; так выглядят все стандартные
математические и логические блоки. Векторные картинки чаще всего используются в блоках с
анимированными изображениями, поскольку отдельные элементы картинки можно связать с
переменными блока, в результате чего в процессе расчета эти элементы будут поворачиваться, перемещаться,
менять размер и цвет, появляться или исчезать (векторные картинки подробно рассматриваются в
<a href="um_index.htm#light_htm:um_2_10" title="&sect;2.10. Редактирование векторной картинки блока">&sect;2.10</a>). Программное рисование тоже используется в блоках,
внешний вид которых меняется в процессе расчета, если векторной картинки для его задания недостаточно или
она получается слишком сложной и неудобной для редактирования. К таким блокам относятся, например, графики,
сложные рукоятки и индикаторы и т.п. Во многих случаях проще написать небольшую программу рисования вместо того,
чтобы тщательно подгонять друг к другу подвижные элементы векторной картинки и рассчитывать их координаты
и размеры.</p>

<p><span id="ref1">Для</span>
того, чтобы модель блока программно рисовала его изображение в подсистеме, должны быть выполнены два
условия: в окне параметров блока на
<a href="um_2_9_1.htm#ref11" title="Параметры блока - внешний вид">вкладке &laquo;<span class="menu">внешний вид</span>&raquo;</a>
должен быть включен флажок &laquo;<span class="menu">внешний вид &ndash; определяется функцией DLL</span>&raquo;
(<a href="#pic1" title="Флажок, разрешающий программное рисование в окне параметров блока">рис.&nbsp;411</a>),
а в модели должна быть введена реакция на событие &laquo;рисование блока&raquo;. Эта реакция находится на
вкладке &laquo;<span class="menu">события</span>&raquo; левой панели окна редактора модели
(см. <a href="um_3_6_4.htm#pic1" title="Список фрагментов программы модели">рис.&nbsp;336</a>) в
группе &laquo;внешний вид блока&raquo;, и ей соответствует константа
<span id="light_ref1"><span class="cpp"><a href="RDS_BFM_DRAW.htm" title="А.2.6.3. RDS_BFM_DRAW &ndash; рисование внешнего вида блока">RDS_BFM_DRAW</a></span></span>. Если разрешить
программное рисование флажком в окне параметров,
но не ввести соответствующую реакцию модели, блок станет невидимым:
RDS будет вызывать его модель для рисования блока в окне подсистемы, а модель будет игнорировать этот
вызов &ndash; в результате, ничего не будет нарисовано. Если ввести реакцию модели на рисование,
но в окне параметров блока вместо флажка &laquo;<span class="menu">внешний вид &ndash; определяется функцией DLL</span>&raquo;
оставить включенным &laquo;<span class="menu">определяется картинкой</span>&raquo; или &laquo;<span class="menu">прямоугольник с текстом</span>&raquo;,
RDS не будет вызывать модель для программного рисования, несмотря на то, что в ней есть
соответствующая реакция, и блок будет выглядеть согласно установленным флажкам.</p>

<div class="pic"><div class="container" id="pic1">
<img src="../img/AC_SelfDrawParams.png" width="534" height="463" alt="Флажок, разрешающий программное рисование в окне параметров блока" />
<p id="light_pic1">Рис.&nbsp;411. Флажок, разрешающий программное рисование в окне параметров блока</p>
</div></div>


<p>Как правило, модели блоков, которые рисуют себя программно, пишут таким образом, чтобы изображение
подстраивалось под размер блока, заданный пользователем. В этом случае вместе с флажком
&laquo;<span class="menu">внешний вид &ndash; определяется функцией DLL</span>&raquo; на вкладке
&laquo;<span class="menu">внешний вид</span>&raquo; окна параметров имеет смысл включить и флажок
&laquo;<span class="menu">разрешить масштабирование</span>&raquo;, чтобы пользователь мог задать размеры блока,
<a href="um_2_6.htm#ref9" title="Изменение размеров блока">растягивая мышью</a>
маркеры его выделения. Можно также, при желании, нажать кнопку
&laquo;<span class="menu">размер для функции DLL</span>&raquo; и ввести точный размер блока в точках экрана для
масштаба 100%.</p>

<p><span id="ref2">В</span>
<span id="ref3">реакции</span>
модели блока на рисование можно пользоваться всеми графическими функциями Windows API, а
также <a href="app_index.htm#light_htm:app_a_5_18" title="А.5.18. Графические функции">специальными графическими функциями RDS</a>
(все эти функции начинаются с символов &laquo;<span class="cpp">rdsXG</span>&raquo;).
Графические функции RDS позволяют проще задавать цвет заполнения, толщину линии, шрифт и
другие параметры рисования, в остальном же они почти полностью повторяют функции Windows API.
Разработчик модели выбирает, какими из них пользоваться, исходя из собственных предпочтений (допускается
смешивать в одной модели вызовы и тех, и других, хотя это может запутать не очень опытного программиста).
В функцию рисования, создаваемую для реакции, передается один параметр с именем
<span class="cpp" id="light_ref2">DrawData</span> &ndash; это указатель на стандартную структуру RDS
<span id="light_ref3"><span class="cpp"><a href="RDS_BFM_DRAW.htm#ref1" title="Структура RDS_DRAWDATA">RDS_DRAWDATA</a></span></span>, в которой содержатся параметры, необходимые для выполнения рисования.
Подробно эта структура рассматривается в разделе
<a href="RDS_BFM_DRAW.htm" title="А.2.6.3. RDS_BFM_DRAW &ndash; рисование внешнего вида блока">А.2.6.3 приложений</a>,
здесь же мы кратко перечислим ее поля и их назначение.</p>

<dl>
  <dt><span id="light_ref4"><span class="cpp">dc</span>&emsp;(<span class="cpp"><i>HDC</i></span>)</span></dt>
  <dd>Контекст устройства Windows
  (device context, <span class="cpp"><a href="app_ids.htm#light_ref16" title="Контекст устройства Windows">HDC</a></span>), на котором модель рисует
  изображение. Этот параметр используется только в графических функциях Windows API, в графических функциях
  RDS его указывать не нужно.</dd>

  <dt><span class="cpp">CalcMode</span>&emsp;(<span class="cpp"><i>BOOL</i></span>)</dt>
  <dd><span class="cpp">TRUE</span>, если RDS находится в
  <a href="um_1_3.htm" title="&sect;1.3. Режимы работы RDS">режимах</a> моделирования
  или расчета, и <span class="cpp">FALSE</span>, если
  RDS находится в режиме редактирования (в режиме редактирования сложные блоки часто рисуют в
  наиболее общей их форме и со всеми включенными дополнительными элементами, если эти элементы могут
  исчезать в процессе расчета).</dd>

  <dt><span class="cpp">BlockX</span>,&nbsp;<span class="cpp">BlockY</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Координаты верхнего левого угла изображения блока в текущем масштабе окна его подсистемы. В
  этих координатах уже учтена возможная связь положения блока с его переменными, которая может быть задана в
  <a href="#pic1" title="Флажок, разрешающий программное рисование в окне параметров блока">окне параметров</a>
  на панели &laquo;<span class="menu">координаты точки привязки</span>&raquo;.</dd>

  <dt><span class="cpp">DoubleZoom</span>&emsp;(<span class="cpp"><i>double</i></span>)</dt>
  <dd>Текущий масштаб окна родительской подсистемы блока в долях единицы: 1 &ndash; 100%, 0.5 &ndash; 50%,
  2 &ndash; 200% и т.п. Если какие-то внутренние элементы программно рисуемого изображения блока (например,
  шрифт надписи) должны масштабироваться вместе с ним, при рисовании размеры этих элементов необходимо умножать на
  значение этого поля.</dd>

  <dt><span class="cpp">RectValid</span>&emsp;(<span class="cpp"><i>BOOL</i></span>)</dt>
  <dd>Признак изменения размеров прямоугольника блока. Если в результате рисования модель изменяет размер
  блока (например, если его высота или ширина отражают его внутреннее состояние), в это поле необходимо записать
  значение <span class="cpp">TRUE</span> и занести в следующие четыре целых поля
  (<span class="cpp">Left</span>, <span class="cpp">Top</span>, <span class="cpp">Width</span> и
  <span class="cpp">Height</span>) новые координаты и размеры блока. В автокомпилируемых блоках эта возможность
  используется крайне редко.</dd>

  <dt><span class="cpp">Left</span>,&nbsp;<span class="cpp">Top</span>,&nbsp;<span class="cpp">Width</span>,&nbsp;<span class="cpp">Height</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Координаты левого верхнего угла (<span class="cpp">Left</span>, <span class="cpp">Top</span>) прямоугольной
  области, занимаемой блоком, ее ширина (<span class="cpp">Width</span>) и высота (<span class="cpp">Height</span>)
  в текущем масштабе с учетом возможной связи положения блока с его переменными. Эти значения можно непосредственно
  использовать в функциях рисования. В эти же поля модель может записать новые координаты и размеры блока, если,
  по какой-либо причине, она решит изменить их при рисовании (при этом также необходимо записать
  <span class="cpp">TRUE</span> в поле <span class="cpp">RectValid</span>).</dd>

  <dt><span id="light_ref5"><span class="cpp">VisibleRect</span>&emsp;(<span class="cpp"><i>RECT*</i></span>)</span></dt>
  <dd>Указатель на структуру <span class="cpp"><a href="app_ids.htm#light_ref23" title="Координаты прямоугольника в Windows API">RECT</a></span> Windows API, в которой записаны координаты видимой в
  данный момент в окне части рабочего поля подсистемы. Модель может использовать их для того, чтобы уменьшить
  потери времени на обновление окна, не рисуя части блока, не попавшие в видимую в данный момент область. Делать
  это не обязательно &ndash; рисование за пределами видимой в окне области отсекается автоматически.</dd>

  <dt><span class="cpp">FullDraw</span>&emsp;(<span class="cpp"><i>BOOL</i></span>)</dt>
  <dd>Логическое поле, указывающее на необходимость полной перерисовки всего изображения блока
  (<span class="cpp">TRUE</span>) или только тех его частей, которые изменились с момента последнего рисования
  (<span class="cpp">FALSE</span>). Его использование позволяет снизить потери времени на обновление окна,
  не рисуя не изменившиеся части изображения блока без необходимости. В автокомпилируемых блоках эта возможность
  используется крайне редко, подробно она рассматривается в
  <a href="pm_2_10_2.htm" title="&sect;2.10.2. Оптимизация рисования">&sect;2.10.2 руководства программиста</a>.</dd>

</dl>

<p class="noindent">Поскольку параметр функции реакции <span class="cpp">DrawData</span> &ndash; это указатель на данную
структуру, все обращения к полям структуры нужно предварять
&laquo;<span class="cpp">DrawData-&gt;</span>&raquo;. Например, чтобы узнать масштаб окна подсистемы рисуемого блока, необходимо
записать &laquo;<span class="cpp">DrawData-&gt;DoubleZoom</span>&raquo;.</p>

<p><span id="light_ref6">Создадим модель простейшего блока-индикатора &ndash; индикатора уровня</span>.
Блок будет выглядеть как прямоугольник, разделенный по вертикали на две части: верхняя часть будет белой,
нижняя &ndash; синей, причем высота синей части будет пропорциональна значению входа блока: при нуле
на входе весь блок будет белым, при значении входа 100 весь блок будет синим, при значении 50 граница раздела
будет находиться точно в середине блока. Таким образом, блок будет рисовать синий вертикальный столбик, высота
которого в процентах относительно полной высоты блока равна значению входа (подобный пример рассматривается в
<a href="pm_2_10_1.htm" title="&sect;2.10.1. Рисование изображения блока в окне подсистемы">&sect;2.10.1 руководства программиста</a>). Для того, чтобы блок лучше выглядел, будем
рисовать вокруг него черную рамку, причем в масштабе 100% и меньше рамка будет иметь толщину в одну точку экрана,
а в крупных масштабах ее толщина будет увеличиваться согласно выбранному масштабу (если этого не сделать,
на печати в высоком разрешении рамка в одну точку будет практически не заметна).</p>

<p>Прежде всего, <a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">создадим</a> новый пустой блок,
переключим его в режим работы
<a href="um_3_7_2_1.htm#pic2" title="Установка запуска по сигналу в окне параметров блока">по сигналу</a> и создадим для него новую пустую модель. После
этого откроется окно редактора модели с пустой вкладкой
&laquo;<span class="menu"><a href="um_3_3.htm#pic8" title="Окно редактора пустой модели">модель</a></span>&raquo; &ndash; на ней мы ничего вводить не будем,
поскольку у нашего блока-индикатора не будет реакции на такт расчета. Зададим для блока структуру статических
переменных &ndash; кроме обязательных сигналов &laquo;<span class="rdsvar">Start</span>&raquo; и &laquo;<span class="rdsvar">Ready</span>&raquo; у него
будет единственный вещественных вход &laquo;<span class="rdsvar">x</span>&raquo;:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  
  <tr><td class="vcenter">Start</td>
<td class="center">Сигнал</td>
<td class="center">Вход</td>
<td class="center">&checkmark;</td>
<td class="center">0</td>
</tr>

  <tr><td class="vcenter">Ready</td>
<td class="center">Сигнал</td>
<td class="center">Выход</td>
<td></td>
<td class="center">0</td>
</tr>

  <tr><td class="vcenter">x</td>
<td class="center">double</td>
<td class="center">Вход</td>
<td></td>
<td class="center">0</td>
</tr>


</table>
</div></div>

<p>Флаг &laquo;<span class="menu">пуск</span>&raquo; у входа &laquo;<span class="rdsvar">x</span>&raquo; мы не устанавливаем, поскольку нам не нужно
запускать модель при изменении этого входа. Модель нашего блока будет вызываться при обновлении окна
его подсистемы, в этот момент она и будет считывать текущее значение входа.</p>

<div class="picright"><div class="container" id="pic2">
<img src="../img/AC_events_draw.png" width="291" height="367" alt="Реакция на рисование блока в списке событий" />
<p id="light_pic2">Рис.&nbsp;412. Реакция на рисование<br />блока в списке событий</p>
</div></div>


<p>Модель блока-индикатора будет состоять из единственной реакции на событие рисования. По умолчанию
вкладка для этой реакции не открыта, необходимо открыть ее вручную. Для этого на
<a href="um_3_6_4.htm" title="&sect;3.6.4. Описания программы и реакции блока на события">левой панели</a>
окна редактора следует выбрать вкладку &laquo;<span class="menu">события</span>&raquo;, раскрыть на ней раздел
&laquo;<span class="menu">внешний вид блока</span>&raquo; и дважды щелкнуть на его подразделе
&laquo;<span class="menu">рисование блока (RDS_BFM_DRAW)</span>&raquo;
(<a href="#pic2" title="Реакция на рисование блока в списке событий">рис.&nbsp;412</a>).
При этом значок подраздела станет желтым, а в правой части окна появится новая пустая вкладка
&laquo;<span class="menu">рисование</span>&raquo;. На этой вкладке мы и запишем текст программы, которая будет рисовать внешний
вид индикатора.</p>

<p>Рисовать индикатор мы будем при помощи графических функций RDS (они несколько проще, чем
стандартные функции Windows API) в следующей последовательности:</p>

<ul>
  <li>сначала проверим вход блока <span class="cpp">x</span> на значение-признак ошибки
  <span class="cpp"><a href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a></span>, и, если они совпадают, нарисуем красный прямоугольник с черной
  рамкой и завершим реакцию;</li>

  <li>вычислим высоту синей (нижней) части блока в точках экрана согласно значению <span class="cpp">x</span>;</li>

  <li>нарисуем в верхней части блока белый прямоугольник шириной во весь блок и высотой, равной разности высоты
  блока и вычисленной высоты синей части;</li>

  <li>в нижней части блока нарисуем синий прямоугольник вычисленной высоты и шириной во весь блок;</li>

  <li>вокруг всего блока нарисуем черную рамку, толщина которой равна текущему масштабу в долях
  единицы, но не меньше одной точки.</li>
</ul>

<p class="noindent">Выполняя эти действия, нам нужно будет проверять значение входа <span class="cpp">x</span>
на попадание в диапазон [0&hellip;100]: если <span class="cpp">x</span> меньше нуля, весь блок будет белым,
если больше ста &ndash; синим. Мы не будем разрешать границе раздела синей и белой частей выходить за
пределы заданного в подсистеме размера блока.</p>

<p>Можно было бы несколько упростить приведенную последовательность действий и нарисовать блок не в
три приема (белая часть, синяя часть, рамка), а в два: сначала белый прямоугольник с черной рамкой размером во
весь блок, а затем, в его нижней части и поверх него, синий прямоугольник нужной высоты. Однако, в этом
случае пришлось бы учитывать утолщение рамки в крупных масштабах и подстраивать размеры синего прямоугольника так,
чтобы он не перекрыл собой эту рамку. Описанная же последовательность действий позволяет не заботиться об
этом, поскольку рамка будет нарисована самой последней и гарантированно не будет ничем перекрыта.</p>

<p>Для выполнения указанных выше действий на вкладке &laquo;<span class="menu">рисование</span>&raquo; редактора модели нужно
ввести следующий текст:</p>

<pre class="cpp">  // Вспомогательные переменные
  int right,bottom,h;

  // Правый нижний угол области блока
  right=DrawData-&gt;Left+DrawData-&gt;Width;
  bottom=DrawData-&gt;Top+DrawData-&gt;Height;

  // Проверка наличия ошибки на входе
  if(x==<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a>) // Заливаем красным
    { // Красный фон
      <a class="hidden" href="rdsXGSetBrushStyle.htm" title="А.5.18.20. rdsXGSetBrushStyle &ndash; установить стиль заливки">rdsXGSetBrushStyle</a>(0,RDS_GFS_SOLID,0xff);
      // Черная линия
      <a class="hidden" href="rdsXGSetPenStyle.htm" title="А.5.18.25. rdsXGSetPenStyle &ndash; установить стиль линии">rdsXGSetPenStyle</a>(0,PS_SOLID,
                       DrawData-&gt;DoubleZoom,0,R2_COPYPEN);
      // Прямоугольник - черная рамка и красный фон
      <a class="hidden" href="rdsXGRectangle.htm" title="А.5.18.18. rdsXGRectangle &ndash; прямоугольник">rdsXGRectangle</a>(DrawData-&gt;Left,DrawData-&gt;Top,right,bottom);
      // Завершаем реакцию, больше ничего не рисуем
      return;
    }

  // Высота синего столбика в точках экрана
  h=x*DrawData-&gt;Height/100.0;
  // Ограничение
  if(h&lt;0)
    h=0;
  else if(h&gt;DrawData-&gt;Height)
    h=DrawData-&gt;Height;

  // Отключаем рамку
  <a class="hidden" href="rdsXGSetPenStyle.htm" title="А.5.18.25. rdsXGSetPenStyle &ndash; установить стиль линии">rdsXGSetPenStyle</a>(RDS_GFSTYLE,<a class="hidden" href="rdsXGSetPenStyle.htm#light_ref11" title="PS_NULL">PS_NULL</a>,0,0,0);

  // Рисуем верхнюю (белую) часть
  if(h!=DrawData-&gt;Height) // Есть белое
    { // Белый фон
      <a class="hidden" href="rdsXGSetBrushStyle.htm" title="А.5.18.20. rdsXGSetBrushStyle &ndash; установить стиль заливки">rdsXGSetBrushStyle</a>(0,RDS_GFS_SOLID,0xffffff);
      // Верхняя часть - на h меньше высоты блока
      <a class="hidden" href="rdsXGRectangle.htm" title="А.5.18.18. rdsXGRectangle &ndash; прямоугольник">rdsXGRectangle</a>(DrawData-&gt;Left,
                     DrawData-&gt;Top,
                     right,
                     bottom-h+1);
    }
  // Рисуем нижнюю (синюю) часть
  if(h!=0)
    { // Синий фон
      <a class="hidden" href="rdsXGSetBrushStyle.htm" title="А.5.18.20. rdsXGSetBrushStyle &ndash; установить стиль заливки">rdsXGSetBrushStyle</a>(0,RDS_GFS_SOLID,0xff0000);
      // Нижняя часть - от h до высоты блока
      <a class="hidden" href="rdsXGRectangle.htm" title="А.5.18.18. rdsXGRectangle &ndash; прямоугольник">rdsXGRectangle</a>(DrawData-&gt;Left,
                     bottom-h,
                     right,
                     bottom);
    }

  // Рисуем рамку
  // Черная линия, толщина - с учетом масштаба
  <a class="hidden" href="rdsXGSetPenStyle.htm" title="А.5.18.25. rdsXGSetPenStyle &ndash; установить стиль линии">rdsXGSetPenStyle</a>(0,PS_SOLID,DrawData-&gt;DoubleZoom,0,R2_COPYPEN);
  // Отключаем заливку
  <a class="hidden" href="rdsXGSetBrushStyle.htm" title="А.5.18.20. rdsXGSetBrushStyle &ndash; установить стиль заливки">rdsXGSetBrushStyle</a>(RDS_GFSTYLE,RDS_GFS_EMPTY,0);
  // Прямоугольник рамки
  <a class="hidden" href="rdsXGRectangle.htm" title="А.5.18.18. rdsXGRectangle &ndash; прямоугольник">rdsXGRectangle</a>(DrawData-&gt;Left,DrawData-&gt;Top,right,bottom);</pre>

<p>В этой модели мы использовали три графических функции RDS: функцию установки параметров рисуемой линии
<span class="cpp"><a href="rdsXGSetPenStyle.htm" title="А.5.18.25. rdsXGSetPenStyle &ndash; установить стиль линии">rdsXGSetPenStyle</a></span>, функцию установки цвета заполнения геометрических фигур
<span class="cpp"><a href="rdsXGSetBrushStyle.htm" title="А.5.18.20. rdsXGSetBrushStyle &ndash; установить стиль заливки">rdsXGSetBrushStyle</a></span> и функцию рисования прямоугольника
<span class="cpp"><a href="rdsXGRectangle.htm" title="А.5.18.18. rdsXGRectangle &ndash; прямоугольник">rdsXGRectangle</a></span>. Рассмотрим подробно, что именно делает эта программа.</p>

<p>Сначала мы вычисляем координаты правого нижнего угла прямоугольной области, занимаемой блоком, и записываем их
во вспомогательные целые переменные <span class="cpp">right</span> (горизонтальная координата) и
<span class="cpp">bottom</span> (вертикальная координата). Координаты левого верхнего угла этой области у
нас уже есть: они записаны RDS в поля <span class="cpp">Left</span> и <span class="cpp">Top</span> структуры,
указатель на которую передан в нашу функцию реакции в параметре <span class="cpp">DrawData</span>. В полях
<span class="cpp">Width</span> и <span class="cpp">Height</span> этой структуры записаны ширина и высота
области соответственно, поэтому для вычисления координаты правой границы области (<span class="cpp">right</span>)
нужно сложить <span class="cpp">DrawData-&gt;Left</span> и <span class="cpp">DrawData-&gt;Width</span>, а
для вычисления координаты нижней границы (<span class="cpp">bottom</span>) &ndash;
<span class="cpp">DrawData-&gt;Top</span> и <span class="cpp">DrawData-&gt;Height</span>. Следует помнить,
что рисование ведется в оконных координатах Windows, поэтому горизонтальная ось всегда направлена слева
направо, а вертикальная &ndash; сверху вниз.</p>

<p><span id="ref7">Далее</span> мы сравниваем вход блока <span class="cpp">x</span> с
признаком ошибки
<span class="cpp"><a href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a></span>. Если они равны, мы должны нарисовать красный прямоугольник.
Для этого сначала мы устанавливаем красный цвет заливки вызовом</p>

<pre class="cpp">  <span id="light_ref7"><a class="hidden" href="rdsXGSetBrushStyle.htm" title="А.5.18.20. rdsXGSetBrushStyle &ndash; установить стиль заливки">rdsXGSetBrushStyle</a></span>(0,              // Маска параметров
                     RDS_GFS_SOLID,  // Стиль
                     0xff);          // Цвет</pre>

<p><span id="ref8">В</span>
<span id="ref9">первом</span> параметре этой функции указывается маска устанавливаемых параметров (мы передаем ноль, что
означает установку всех параметров одновременно), во втором &ndash; стиль заливки
(константа <span class="cpp" id="light_ref8">RDS_GFS_SOLID</span> означает сплошную заливку цветом),
в третьем &ndash; цвет заливки в формате <span id="light_ref9"><span class="cpp"><a href="app_ids.htm#light_ref13" title="Цвет Windows API">COLORREF</a></span></span>,
используемом в Windows. В данном
случае, шестнадцатеричное число <span class="cpp">0xff</span> (десятичное 255) означает красный цвет:
младший байт числа <span class="cpp">COLORREF</span> задает интенсивность красной компоненты цвета (у
нас &ndash; максимально возможная), второй и третий байты &ndash; интенсивности зеленой и синей компонент
соответственно (в числе 255 они нулевые). После этого вызова все рисуемые замкнутые геометрические фигуры будут
иметь сплошной красный цвет максимальной интенсивности.</p>

<p><span id="ref10">Затем</span> мы устанавливаем параметры линии рамки геометрических фигур вызовом</p>

<pre class="cpp">  <span id="light_ref10"><a class="hidden" href="rdsXGSetPenStyle.htm" title="А.5.18.25. rdsXGSetPenStyle &ndash; установить стиль линии">rdsXGSetPenStyle</a></span>(0,                    // Маска параметров
                   PS_SOLID,             // Стиль
                   DrawData-&gt;DoubleZoom, // Толщина
                   0,                    // Цвет
                   R2_COPYPEN);          // Режим</pre>

<p><span id="ref11">В</span>
<span id="ref12">первом</span>
<span id="ref13">параметре</span> опять передается маска устанавливаемых параметров (0 &ndash;
все параметры устанавливаются одновременно). Второй параметр задает стиль линии
(<span class="cpp" id="light_ref11">PS_SOLID</span> &ndash; сплошная линия), третий
&ndash; ее толщину (в данном случае передается <span class="cpp">DrawData-&gt;DoubleZoom</span>, то есть
текущий масштаб подсистемы), в четвертом &ndash; цвет линии (переданный ноль означает черный цвет &ndash;
все три компоненты цвета имеют нулевую интенсивность). Наконец, в пятом параметре передается режим рисования,
или <span id="light_ref12">&laquo;растровая операция&raquo;</span>. Этот режим задает способ смешения
цвета фона и цвета линии, переданная константа
<span class="cpp" id="light_ref13">R2_COPYPEN</span> указывает на то, что цвет фона должен просто
заменяться на заданный цвет линии. После вызова <span class="cpp">rdsXGSetPenStyle</span> с этими параметрами
все рисуемые геометрические фигуры будут иметь видимую сплошную рамку черного цвета, толщина которой будет
равна текущему масштабу подсистемы в долях единицы, то есть одной точке при масштабе 100%, двум точкам
при масштабе 200% и т.д.</p>

<p>Может возникнуть вопрос: что будет с толщиной линии рамки при масштабах, меньших 100% &ndash; например,
при 25%? В качестве толщины мы передаем масштаб подсистемы в долях единицы
<span class="cpp">DrawData-&gt;DoubleZoom</span>, для 25% это значение будет равно 0.25. Третий параметр
функции <span class="cpp">rdsXGSetPenStyle</span> имеет тип <span class="cpp">int</span>, то есть 0.25
будет округлено до нуля и передано в функцию &ndash; получается, что мы устанавливаем толщину линии в ноль
точек. В RDS ноль в качестве толщины линии указывает на минимально возможную толщину, то есть толщину в
одну точку экрана. Таким образом, в крупных масштабах толщина рамки нашего прямоугольника будет увеличиваться
вместе с масштабом, а в мелких (при значении <span class="cpp">DoubleZoom</span>, меньшем единицы) &ndash;
оставаться равной одной точке, как мы и хотели.</p>

<p><span id="ref14">После</span> того, как параметры заливки и рамки установлены, вызов функции
<span id="light_ref14"><span class="cpp"><a href="rdsXGRectangle.htm" title="А.5.18.18. rdsXGRectangle &ndash; прямоугольник">rdsXGRectangle</a></span></span> рисует прямоугольник с этими параметрами:</p>

<pre class="cpp">  <a class="hidden" href="rdsXGRectangle.htm" title="А.5.18.18. rdsXGRectangle &ndash; прямоугольник">rdsXGRectangle</a>(DrawData-&gt;Left,  // Левая граница
                 DrawData-&gt;Top,   // Верхняя граница
                 right,           // Правая граница
                 bottom);         // Нижняя граница</pre>

<p>В параметрах этой функции передаются координаты левого верхнего
(<span class="cpp">DrawData-&gt;Left</span> и <span class="cpp">DrawData-&gt;Top</span>) и правого нижнего
(<span class="cpp">right</span>, <span class="cpp">bottom</span>) углов рисуемого прямоугольника. Поскольку это
рисование выполняется при ошибке на входе, после вызова <span class="cpp">rdsXGRectangle</span> мы немедленно
завершаем реакцию оператором <span class="cpp">return</span>.</p>

<p>Если же на входе не было ошибки, мы вычисляем высоту синей части блока как <span class="cpp">x</span>% от
полной высоты блока и записываем ее во вспомогательную переменную <span class="cpp">h</span>:</p>

<pre class="cpp">  h=x*DrawData-&gt;Height/100.0;</pre>

<p>Чтобы ограничить рисование границами области блока, вместо того, чтобы проверять попадание <span class="cpp">x</span>
в диапазон [0&hellip;100], мы проверяем значение <span class="cpp">h</span>. Если значение
<span class="cpp">x</span> отрицательно, значение <span class="cpp">h</span> тоже будет отрицательным &ndash;
в этом случае мы принудительно присваиваем <span class="cpp">h</span> ноль, что не даст синей части блока выйти
вниз за границы его области. Если значение <span class="cpp">x</span> больше ста, значение <span class="cpp">h</span>
будет больше высоты блока <span class="cpp">DrawData-&gt;Height</span> &ndash; в этом случае мы принудительно
присваиваем <span class="cpp">h</span> значение высоты блока, что не даст синей части выйти за границу области
блока вверх.</p>

<p>Теперь можно рисовать белую и синюю части блока. Сначала мы отключаем рисование рамки вызовом уже
знакомой функции <span class="cpp"><a href="rdsXGSetPenStyle.htm" title="А.5.18.25. rdsXGSetPenStyle &ndash; установить стиль линии">rdsXGSetPenStyle</a></span>, но с другими параметрами:</p>

<pre class="cpp">  <a class="hidden" href="rdsXGSetPenStyle.htm" title="А.5.18.25. rdsXGSetPenStyle &ndash; установить стиль линии">rdsXGSetPenStyle</a>(RDS_GFSTYLE,<a class="hidden" href="rdsXGSetPenStyle.htm#light_ref11" title="PS_NULL">PS_NULL</a>,0,0,0);</pre>

<p><span id="ref15">В</span>
<span id="ref16">первом</span> параметре функции передается битовый флаг
<span class="cpp" id="light_ref15">RDS_GFSTYLE</span>, указывающий на то, что мы меняем только стиль
линии. Во втором параметре передается константа стиля
<span class="cpp" id="light_ref16">PS_NULL</span>, задающая невидимую линию. Остальные параметры функции
&ndash; нулевые: из-за того, что в первом параметре передан единственный флаг установки стиля, они все равно
будут проигнорированы RDS, и в них можно указать любые значения.</p>

<p>Если высота синей части <span class="cpp">h</span> не равна полной высоте блока
<span class="cpp">DrawData-&gt;Height</span>, в верхней части области блока необходимо нарисовать белый
прямоугольник. Белый цвет заливки мы устанавливаем вызовом</p>

<pre class="cpp">  <a class="hidden" href="rdsXGSetBrushStyle.htm" title="А.5.18.20. rdsXGSetBrushStyle &ndash; установить стиль заливки">rdsXGSetBrushStyle</a>(0,RDS_GFS_SOLID,0xffffff);</pre>

<p class="noindent">в котором шестнадцатеричное число <span class="cpp">0xffffff</span> (десятичное
16777215 = 255&times;65536 + 255&times;256 + 255) задает белый цвет: все три байта этого числа равны
255, то есть красная, зеленая и синяя компоненты цвета имеют максимально возможные интенсивности). Затем мы
рисуем прямоугольник, верхняя граница которого совпадает с верхней границей всей области блока, а нижняя
отстоит от нижней границы блока на <span class="cpp">h</span>:</p>

<pre class="cpp">  <a class="hidden" href="rdsXGRectangle.htm" title="А.5.18.18. rdsXGRectangle &ndash; прямоугольник">rdsXGRectangle</a>(DrawData-&gt;Left,  // Левая граница блока
                 DrawData-&gt;Top,   // Верх блока
                 right,           // Правая граница блока
                 bottom-h+1);     // На h выше нижней границы</pre>

<p>Прямоугольник будет нарисован без рамки, поскольку рамку мы отключили предыдущим вызовом
<span class="cpp">rdsXGSetPenStyle</span>. В последнем параметре функции передается
&laquo;<span class="cpp">bottom-h+1</span>&raquo;, а не &laquo;<span class="cpp">bottom-h</span>&raquo;, чтобы не было зазора между верхней и
нижней частями прямоугольника. Иногда по результатам рисования приходится увеличивать или уменьшать координаты
рисуемых элементов на одну точку, чтобы точно подогнать их друг к другу &ndash; это как раз такой случай.
Если убрать из параметра &laquo;<span class="cpp">+1</span>&raquo;, можно будет видеть, что между белым прямоугольником и синим,
который мы нарисуем позже, окажется полоска цвета фона окна подсистемы высотой в одну точку экрана.</p>

<p>Если высота синей части <span class="cpp">h</span> не равна нулю, мы точно так же рисуем в нижней части
блока синий прямоугольник. Для этого мы устанавливаем синий цвет заливки вызовом</p>

<pre class="cpp">  <a class="hidden" href="rdsXGSetBrushStyle.htm" title="А.5.18.20. rdsXGSetBrushStyle &ndash; установить стиль заливки">rdsXGSetBrushStyle</a>(0,RDS_GFS_SOLID,0xff0000);</pre>

<p class="noindent">где шестнадцатеричное число <span class="cpp">0xff0000</span> (десятичное
16711680 = 255&times;65536) задает синий цвет: третий байт числа, указывающий синюю компоненту цвета,
равен 255, остальные &ndash; нулевые, то есть красная и зеленая компоненты имеют нулевую интенсивность.
Затем рисуется нижний прямоугольник блока:</p>

<pre class="cpp">  <a class="hidden" href="rdsXGRectangle.htm" title="А.5.18.18. rdsXGRectangle &ndash; прямоугольник">rdsXGRectangle</a>(DrawData-&gt;Left,  // Левая граница блока
                 bottom-h,        // На h выше нижней границы
                 right,           // Правая граница блока
                 bottom);         // Нижняя граница</pre>

<p>По вертикали нижний прямоугольник начинается там, где закончился верхний: в точке
<span class="cpp">bottom-h</span>. Эта точка и будет границей раздела цветов нашего индикатора,
перемещающейся вверх и вниз при изменении входа блока.</p>

<p>Теперь, когда оба цветных прямоугольника внутри блока нарисованы, можно нарисовать вокруг него черную рамку.
Для этого сначала мы задаем черную сплошную линию рамки, связывая ее толщину с масштабом подсистемы, в которой
находится блок:</p>

<pre class="cpp">  <a class="hidden" href="rdsXGSetPenStyle.htm" title="А.5.18.25. rdsXGSetPenStyle &ndash; установить стиль линии">rdsXGSetPenStyle</a>(0,                     // Маска параметров
                   PS_SOLID,              // Стиль
                   DrawData-&gt;DoubleZoom,  // Толщина
                   0,                     // Цвет
                   R2_COPYPEN);           // Режим</pre>

<p>Точно такой же вызов мы уже рассматривали выше, при описании действий в момент обнаружения на входе
блока значения-индикатора ошибки <span class="cpp">rdsbcppHugeDouble</span>. Затем мы отключаем заливку вызовом</p>

<pre class="cpp">  <a class="hidden" href="rdsXGSetBrushStyle.htm" title="А.5.18.20. rdsXGSetBrushStyle &ndash; установить стиль заливки">rdsXGSetBrushStyle</a>(RDS_GFSTYLE,RDS_GFS_EMPTY,0);</pre>

<p><span id="ref17">Здесь</span> в первом параметре функции мы передаем битовый флаг
<span class="cpp">RDS_GFSTYLE</span>, указывающий на то, что мы меняем только стиль заливки, во втором
&ndash; новый стиль заливки
<span class="cpp" id="light_ref17">RDS_GFS_EMPTY</span>, отключающий ее, и в третьем &ndash; ноль,
поскольку цвет заливки при передаче флага <span class="cpp">RDS_GFSTYLE</span> мы не устанавливаем (третий
параметр функции будет проигнорирован RDS). После этих двух вызовов все рисуемые геометрические фигуры будут
иметь черную сплошную рамку и не будут иметь заливки внутри. Теперь мы можем нарисовать рамку блока, то
есть прямоугольник размером во всю область, занимаемую блоком:</p>

<pre class="cpp">  <a class="hidden" href="rdsXGRectangle.htm" title="А.5.18.18. rdsXGRectangle &ndash; прямоугольник">rdsXGRectangle</a>(DrawData-&gt;Left,  // Левая граница блока
                 DrawData-&gt;Top,   // Верхняя граница блока
                 right,           // Правая граница блока
                 bottom);         // Нижняя граница блока</pre>

<p>Модель нашего блока-индикатора создана &ndash; можно скомпилировать ее и закрыть редактор. Однако,
внешний вид блока после этого останется таким же, как и после его создания. Для того, чтобы функция
модели смогла самостоятельно рисовать внешний вид блока, мало ввести в нее соответствующую реакцию, нужно
еще и разрешить ей делать это в окне параметров блока. Можно было бы сделать это сразу, в момент создания
блока, однако, в этот момент у модели еще не было реакции рисования, и блок стал бы невидимым: модель вызывалась
бы для рисования и не рисовала бы ничего. Чтобы не искать потом этот невидимый блок в подсистеме, лучше
сначала написать, хотя бы частично, реакцию рисования, и только потом разрешить это рисование в параметрах
блока.</p>

<p>Откроем окно параметров созданного блока (например, пунктом
&laquo;<span class="menu"><a href="um_3_3.htm#pic1_1" title="Создание простого блока (а) и вызов окна его параметров (б)">параметры</a></span>&raquo; контекстного меню)
и выберем в нем вкладку &laquo;<span class="menu">внешний вид</span>&raquo;. На этой вкладке на панели
&laquo;<span class="menu">внешний вид блока</span>&raquo; необходимо включить флажок
&laquo;<span class="menu">определяется функцией DLL</span>&raquo;
(<a href="#pic3" title="Включение программного рисования в окне параметров блока">рис.&nbsp;413</a>).
Имеет смысл также включить флажок &laquo;<span class="menu">разрешить масштабирование</span>&raquo;, чтобы пользователь мог задавать
размер блока перетаскиванием маркеров его выделения.</p>

<div class="pic"><div class="container" id="pic3">
<img src="../img/AC_dlldraw_on.png" width="534" height="463" alt="Включение программного рисования в окне параметров блока" />
<p id="light_pic3">Рис.&nbsp;413. Включение программного рисования в окне параметров блока</p>
</div></div>


<div class="picright"><div class="container" id="pic4">
<img src="../img/AC_selfdraw_level_test.png" width="120" height="116" alt="Тестирование индикатора уровня" />
<p id="light_pic4">Рис.&nbsp;414. Тестирование<br />индикатора уровня</p>
</div></div>


<p>После того, как окно будет закрыто кнопкой &laquo;<span class="menu">OK</span>&raquo;, за рисование нашего блока будет отвечать его
собственная модель. Чтобы проверить ее, можно собрать схему, изображенную
на <a href="#pic4" title="Тестирование индикатора уровня">рис.&nbsp;414</a>. В ней блок-индикатор вытянут мышью по
вертикали, а к его входу &laquo;<span class="rdsvar">x</span>&raquo; подключено поле ввода. Если запустить расчет и вводить в
это поле значения от 0 до 100, высота закрашенной части индикатора будет изменяться. При вводе в поле
отрицательных значений весь индикатор будет белым, при вводе значений, больших 100 &ndash; синим.</p>

<p>Подобный индикатор можно было бы создать и не прибегая к программному рисованию &ndash; в редакторе
векторной картинки есть элемент
&laquo;<a href="um_2_10_2.htm" title="&sect;2.10.2. Рисование прямоугольников и эллипсов">прямоугольник</a>&raquo;,
вертикальный масштаб которого можно связать с переменной блока. Однако, в этом случае пользователь не
смог бы свободно менять размер блока: у векторной картинки нельзя изменить высоту, не изменив ширину,
ее можно только увеличить или уменьшить всю целиком.</p>

<p><span id="ref18">Рассмотрим</span>
теперь модель более сложного блока, изображение которого не удалось бы создать при помощи векторной картинки.
Сделаем <span id="light_ref18">индикатор с круглой шкалой и стрелкой</span>
(<a href="#pic5" title="Предполагаемый вид и параметры стрелочного индикатора">рис.&nbsp;415</a>),
причем начало и конец шкалы, шаг чисел на этой шкале, число знаков в дробной части этих чисел и количество
дополнительных делений между числами на шкале будут входами блока, чтобы их можно было изменять в процессе
расчета.Таким образом, мы дадим нашему блоку следующие входы:</p>

<ul>
  <li>начало шкалы &ndash; вещественный вход &laquo;<span class="rdsvar">Min</span>&raquo;;</li>
  <li>конец шкалы &ndash; вещественный вход &laquo;<span class="rdsvar">Max</span>&raquo;;</li>
  <li>шаг чисел шкалы &ndash; вещественный вход &laquo;<span class="rdsvar">Step</span>&raquo;;</li>
  <li>количество знаков в дробной части чисел шкалы &ndash; целый вход &laquo;<span class="rdsvar">Dec</span>&raquo;;</li>
  <li>число дополнительных делений (мелких рисок) между числами шкалы &ndash; целый вход &laquo;<span class="rdsvar">Sub</span>&raquo;;</li>
  <li>индицируемое значение (положение стрелки) &ndash; вещественный вход &laquo;<span class="rdsvar">x</span>&raquo;.</li>
</ul>

<div class="pic"><div class="container" id="pic5">
<img src="../img/AC_ArrowGauge_Layout.png" width="716" height="314" alt="Предполагаемый вид и параметры стрелочного индикатора" />
<p id="light_pic5">Рис.&nbsp;415. Предполагаемый вид и параметры стрелочного индикатора</p>
</div></div>


<p>На рисунке индикатор изображен для значений Min=0, Max=6, Step=1, Dec=0, Sub=10 и x=3.28.</p>

<p>Кроме указанных выше, для рисования индикатора нам потребуются дополнительные параметры, задающие
размер различных его элементов: рисок шкалы, стрелки, чисел и т.п. (все эти параметры изображены на
<a href="#pic5" title="Предполагаемый вид и параметры стрелочного индикатора">рис.&nbsp;415</a>). Вместо того, чтобы делать их входами блока,
мы просто опишем их как локальные переменные в модели. Это приведет к тому, что все индикаторы с этой
моделью будут иметь одинаковый размер рисок и чисел шкалы. При желании, можно сделать эти параметры
настраиваемыми пользователем (см. <a href="um_3_7_6.htm" title="&sect;3.7.6. Блоки с настраиваемыми пользователем параметрами">&sect;3.7.6</a>), но для упрощения примера
мы не будем этого делать.</p>

<p>Внешний вид нашего индикатора будет определяться следующими дополнительными параметрами (все угловые
величины будем задавать в радианах, все линейные &ndash; в точках экрана для масштаба 100%):</p>

<ul>
  <li><span class="cpp">StartAngle</span> &ndash; угол между вертикалью и началом шкалы;</li>
  <li><span class="cpp">EndAngle</span> &ndash; угол между вертикалью и концом шкалы;</li>
  <li><span class="cpp">ExcessAngle</span> &ndash; дополнительный угол, на который мы разрешим стрелке
  отклоняться наружу от диапазона шкалы (это позволит пользователю увидеть, что значение на входе
  блока вышло за отображаемый диапазон);</li>
  <li><span class="cpp">FontHeight</span> &ndash; высота шрифта чисел шкалы;</li>
  <li><span class="cpp">BigTick</span> &ndash; размер больших рисок шкалы, около которых будут выводиться числа;</li>
  <li><span class="cpp">SmallTick</span> &ndash; размер маленьких рисок шкалы, располагающихся между большими;</li>
  <li><span class="cpp">D_Tick</span> &ndash; расстояние между внешним краем прибора и рисками;</li>
  <li><span class="cpp">D_Num</span> &ndash; расстояние между внутренним концом большой риски и числом;</li>
  <li><span class="cpp">D_Arr</span> &ndash; расстояние между внешним краем прибора и стрелкой;</li>
  <li><span class="cpp">CenterDisk</span> &ndash; диаметр центрального круга прибора.</li>
</ul>

<p>Независимо от заданных пользователем размеров блока, мы всегда будем рисовать прибор круглым в центре
прямоугольной области, занимаемой блоком: диаметр круга будет равен наименьшему из двух размеров блока.
При изменении масштаба подсистемы мы будем соответствующим образом подстраивать линейные размеры всех
элементов блока, включая размер шрифта чисел, а также толщину всех линий.</p>

<p>Теперь, когда мы определились с внешним видом и параметрами индикатора, можно приступать к созданию модели.
<a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">Создадим</a> новый пустой блок, переключим его в режим работы
<a href="um_3_7_2_1.htm#pic2" title="Установка запуска по сигналу в окне параметров блока">по сигналу</a> и создадим для него новую пустую модель.
Зададим для блока следующую структуру статических переменных:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  
  <tr><td class="vcenter">Start</td>
<td class="center">Сигнал</td>
<td class="center">Вход</td>
<td class="center">&checkmark;</td>
<td class="center">0</td>
</tr>

  <tr><td class="vcenter">Ready</td>
<td class="center">Сигнал</td>
<td class="center">Выход</td>
<td></td>
<td class="center">0</td>
</tr>

  <tr><td class="vcenter">Min</td>
<td class="center">double</td>
<td class="center">Вход</td>
<td></td>
<td class="center">0</td>
</tr>

  <tr><td class="vcenter">Max</td>
<td class="center">double</td>
<td class="center">Вход</td>
<td></td>
<td class="center">100</td>
</tr>

  <tr><td class="vcenter">Step</td>
<td class="center">double</td>
<td class="center">Вход</td>
<td></td>
<td class="center">20</td>
</tr>

  <tr><td class="vcenter">Dec</td>
<td class="center">int</td>
<td class="center">Вход</td>
<td></td>
<td class="center">0</td>
</tr>

  <tr><td class="vcenter">Sub</td>
<td class="center">int</td>
<td class="center">Вход</td>
<td></td>
<td class="center">10</td>
</tr>

  <tr><td class="vcenter">x</td>
<td class="center">double</td>
<td class="center">Вход</td>
<td></td>
<td class="center">0</td>
</tr>


</table>
</div></div>

<p>Мы снова не устанавливаем флаг &laquo;<span class="menu">пуск</span>&raquo; у входов &ndash; наш блок не будет ничего вычислять в
<a href="um_1_3.htm#ref4" title="Такт расчета">такте расчета</a>, и нам не нужно запускать его модель при изменении входов.
Вкладка реакции на рисование блока по умолчанию закрыта &ndash; откроем ее, как было описано в
предыдущем примере: на
<a href="#pic2" title="Реакция на рисование блока в списке событий">левой панели</a>
окна редактора выберем вкладку &laquo;<span class="menu">события</span>&raquo;, раскроем раздел
&laquo;<span class="menu">внешний вид блока</span>&raquo; и дважды щелкнем на подразделе
&laquo;<span class="menu">рисование блока</span>&raquo;. На открывшейся вкладке
&laquo;<span class="menu">рисование</span>&raquo; введем следующий текст:</p>

<pre class="cpp">  //--------- Параметры рисования ---------
  // Углы начала и конца шкалы от направления "вверх"
  double StartAngle=0.66*M_PI,   // Начало шкалы (+120гр)
         EndAngle=-0.66*M_PI;    // Конец шкалы (-120гр)
  double ExcessAngle=0.055*M_PI; // По краям шкалы (10гр)
  // Размеры цифр и рисок в точках экрана для масштаба 100%
  int FontHeight=17; // Высота шрифта
  int BigTick=10;    // Размер большой риски
  int SmallTick=4;   // Размер маленькой риски
  int D_Tick=5;      // Зазор между внешней границей и большой риской
  int D_Num=2;       // Зазор между числом и большой риской
  int D_Arr=2;       // Зазор между внешней границей и стрелкой
  int CenterDisk=10; // Диаметр центрального диска
  //---------------------------------------

  // Макрос для расчета угла от направления "вверх" по значению входа
  #define V_TO_A(v) \
    ( ((v)-Min)*(EndAngle-StartAngle)/(Max-Min)+StartAngle )

  // Макрос для расчета координат точки по радиусу и углу
  #define CALCPOINT(r,a,x,y) \
    x=CenterX-(r)*sin(a); \
    y=CenterY-(r)*cos(a);

  // Вспомогательные переменные
  int CenterX,CenterY,left,top,right,bottom,R,r1,r2,
      ix1,iy1,ix2,iy2,rf,w,rs,ra;
  double a,v,e_min,e_max;
  char *str;
  <a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> x_error,scale_error;

  // Допустимы ли значения шкалы?
  scale_error=(Min==<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a> ||
               Max==<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a> ||
               Step==<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a> ||
               Max&lt;=Min || Step&lt;=0.0);
  // Допустимо ли значение на входе?
  x_error=(x==<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a>);

  // Центр изображения блока
  CenterX=DrawData-&gt;Left+DrawData-&gt;Width/2;
  CenterY=DrawData-&gt;Top+DrawData-&gt;Height/2;

  // Выделяем центральный квадрат блока
  if(DrawData-&gt;Width&gt;DrawData-&gt;Height)
    { // Блок вытянут по ширине
      R=DrawData-&gt;Height/2;
      left=CenterX-R;
      right=CenterX+R;
      top=DrawData-&gt;Top;
      bottom=DrawData-&gt;Top+DrawData-&gt;Height;
    }
  else
    { // Блок вытянут по высоте
      R=DrawData-&gt;Width/2;
      left=DrawData-&gt;Left;
      right=DrawData-&gt;Left+DrawData-&gt;Width;
      top=CenterY-R;
      bottom=CenterY+R;
    }
  // R - радиус большого круга

  // Рисуем белый (красный при ошибке) круг с черной рамкой
  <a class="hidden" href="rdsXGSetPenStyle.htm" title="А.5.18.25. rdsXGSetPenStyle &ndash; установить стиль линии">rdsXGSetPenStyle</a>(0,PS_SOLID,DrawData-&gt;DoubleZoom,0,R2_COPYPEN);
  <a class="hidden" href="rdsXGSetBrushStyle.htm" title="А.5.18.20. rdsXGSetBrushStyle &ndash; установить стиль заливки">rdsXGSetBrushStyle</a>(0,RDS_GFS_SOLID,
    (scale_error||x_error)?0xff:0xffffff);
  <a class="hidden" href="rdsXGEllipse.htm" title="А.5.18.6. rdsXGEllipse &ndash; эллипс или окружность">rdsXGEllipse</a>(left,top,right,bottom);

  if(scale_error) // Без шкалы ничего больше не нарисовать
    return;

  // Расширенный диапазон (на ExcessAngle больше шкалы)
  a=ExcessAngle*(Max-Min)/fabs(EndAngle-StartAngle);
  e_min=Min-a;
  e_max=Max+a;

  // Отключаем заливку
  <a class="hidden" href="rdsXGSetBrushStyle.htm" title="А.5.18.20. rdsXGSetBrushStyle &ndash; установить стиль заливки">rdsXGSetBrushStyle</a>(RDS_GFSTYLE,RDS_GFS_EMPTY,0);

  // Вычисляем вспомогательные радиусы
  r1=R-D_Tick*DrawData-&gt;DoubleZoom;     // Внешний радиус большой риски
  r2=r1-BigTick*DrawData-&gt;DoubleZoom;   // Внутр. радиус большой риски
  rs=r1-SmallTick*DrawData-&gt;DoubleZoom; // Внутренний радиус маленькой риски
  rf=r2-D_Num*DrawData-&gt;DoubleZoom;     // Внешний радиус чисел
  ra=R-D_Arr*DrawData-&gt;DoubleZoom;      // Радиус стрелки

  // Рисуем шкалу в цикле
  for(v=Min;v&lt;=Max+Step*0.001;v+=Step)
    { // Угол, соответствующий v
      a=V_TO_A(v);
      // Расчет точек большой риски
      CALCPOINT(r1,a,ix1,iy1)
      CALCPOINT(r2,a,ix2,iy2)
      // Рисование большой риски
      <a class="hidden" href="rdsXGMoveTo.htm" title="А.5.18.14. rdsXGMoveTo &ndash; установить текущую точку рисования">rdsXGMoveTo</a>(ix1,iy1);
      <a class="hidden" href="rdsXGLineTo.htm" title="А.5.18.13. rdsXGLineTo &ndash; отрезок прямой">rdsXGLineTo</a>(ix2,iy2);
      // Выводимое число (строку нужно потом освободить rdsFree)
      str=<a class="hidden" href="rdsDtoA.htm" title="А.5.4.5. rdsDtoA &ndash; преобразование вещественного числа в строку">rdsDtoA</a>(v,Dec,NULL);
      // Не повернутый шрифт
      <a class="hidden" href="rdsXGSetFont.htm" title="А.5.18.22. rdsXGSetFont &ndash; установить шрифт">rdsXGSetFont</a>(RDS_GFFONTALLHEIGHT,"Arial",
                   FontHeight*DrawData-&gt;DoubleZoom,
                   0,DEFAULT_CHARSET,
                   0,
                   FALSE,FALSE,FALSE,FALSE);
      // Ширина числа
      <a class="hidden" href="rdsXGGetTextSize.htm" title="А.5.18.10. rdsXGGetTextSize &ndash; получить размеры строки текста">rdsXGGetTextSize</a>(str,&amp;w,NULL);
      // Повернутый шрифт
      <a class="hidden" href="rdsXGSetFont.htm" title="А.5.18.22. rdsXGSetFont &ndash; установить шрифт">rdsXGSetFont</a>(RDS_GFFONTALLHEIGHT,"Arial",
                   FontHeight*DrawData-&gt;DoubleZoom,
                   0,DEFAULT_CHARSET,
                   a*180.0/M_PI,
                   FALSE,FALSE,FALSE,FALSE);
      // Координаты центра верхней линии шрифта
      CALCPOINT(rf,a,ix1,iy1)
      // Вычисление левого верхнего угла текста числа
      ix2=ix1-0.5*w*cos(a);
      iy2=iy1+0.5*w*sin(a);
      // Вывод числа
      <a class="hidden" href="rdsXGTextOut.htm" title="А.5.18.27. rdsXGTextOut &ndash; строка текста">rdsXGTextOut</a>(ix2,iy2,str);
      <span id="ref19">//</span> Освобождение памяти, отведенной в rdsDtoA
      <span id="light_ref19"><a class="hidden" href="rdsFree.htm" title="А.5.4.8. rdsFree &ndash; освобождение отведенной динамической памяти">rdsFree</a></span>(str);
      // Рисование маленьких рисок
      for(int i=1;i&lt;Sub;i++)
        { a=v+i*Step/Sub; // Значение риски
          if(a&gt;Max) break;
          a=V_TO_A(a); // Угол риски
          CALCPOINT(r1,a,ix1,iy1)
          CALCPOINT(rs,a,ix2,iy2)
          <a class="hidden" href="rdsXGMoveTo.htm" title="А.5.18.14. rdsXGMoveTo &ndash; установить текущую точку рисования">rdsXGMoveTo</a>(ix1,iy1);
          <a class="hidden" href="rdsXGLineTo.htm" title="А.5.18.13. rdsXGLineTo &ndash; отрезок прямой">rdsXGLineTo</a>(ix2,iy2);
        } // for(int i=1;...)
    } // for(v=Min;...)

  // Рисуем стрелку
  if(!x_error)
    { // Устанавливаем красный цвет линии
      <a class="hidden" href="rdsXGSetPenStyle.htm" title="А.5.18.25. rdsXGSetPenStyle &ndash; установить стиль линии">rdsXGSetPenStyle</a>(0,PS_SOLID,
                       DrawData-&gt;DoubleZoom,0xff,R2_COPYPEN);
      // Ограничиваем по расширенному диапазону шкалы
      if(x&lt;e_min)
        v=e_min;
      else if(x&gt;e_max)
        v=e_max;
      else
        v=x;
      // Вычисляем координаты конца стрелки
      CALCPOINT(ra,V_TO_A(v),ix1,iy1)
      // Рисуем линию стрелки
      <a class="hidden" href="rdsXGMoveTo.htm" title="А.5.18.14. rdsXGMoveTo &ndash; установить текущую точку рисования">rdsXGMoveTo</a>(CenterX,CenterY);
      <a class="hidden" href="rdsXGLineTo.htm" title="А.5.18.13. rdsXGLineTo &ndash; отрезок прямой">rdsXGLineTo</a>(ix1,iy1);
    }

  // Рисуем центральный диск
  w=0.5*CenterDisk*DrawData-&gt;DoubleZoom;
  <a class="hidden" href="rdsXGSetPenStyle.htm" title="А.5.18.25. rdsXGSetPenStyle &ndash; установить стиль линии">rdsXGSetPenStyle</a>(0,PS_SOLID,DrawData-&gt;DoubleZoom,0,R2_COPYPEN);
  <a class="hidden" href="rdsXGSetBrushStyle.htm" title="А.5.18.20. rdsXGSetBrushStyle &ndash; установить стиль заливки">rdsXGSetBrushStyle</a>(0,RDS_GFS_SOLID,0xffffff);
  <a class="hidden" href="rdsXGEllipse.htm" title="А.5.18.6. rdsXGEllipse &ndash; эллипс или окружность">rdsXGEllipse</a>(CenterX-w,CenterY-w,
               CenterX+w,CenterY+w);</pre>

<p>Эта модель тоже пользуется для рисования графическими функциями RDS. Помимо уже рассмотренных ранее
функций <span class="cpp">rdsXGSetPenStyle</span> и <span class="cpp">rdsXGSetBrushStyle</span>, в ней вызываются
функции рисования
<a href="rdsXGEllipse.htm" title="А.5.18.6. rdsXGEllipse &ndash; эллипс или окружность">эллипса</a>,
<a href="rdsXGLineTo.htm" title="А.5.18.13. rdsXGLineTo &ndash; отрезок прямой">линии</a>,
функция <a href="rdsXGSetFont.htm" title="А.5.18.22. rdsXGSetFont &ndash; установить шрифт">установки шрифта</a> и функция
<a href="rdsXGGetTextSize.htm" title="А.5.18.10. rdsXGGetTextSize &ndash; получить размеры строки текста">определения размеров</a> заданного текста в точках экрана.
Кроме того, в ней используется пара функций работы со строками, при помощи которых формируются текстовые
строки с числами, выводимыми на шкале. Все эти функции подробно описаны в
<a href="app_index.htm#light_htm:app_a_5_18" title="А.5.18. Графические функции">А.5.18 приложений</a>.</p>

<p>В самом начале модели описаны переменные, соответствующие параметрам внешнего вида индикатора,
изображенным
на <a href="#pic5" title="Предполагаемый вид и параметры стрелочного индикатора">рис.&nbsp;415</a>.
Переменным <span class="cpp">StartAngle</span> и <span class="cpp">EndAngle</span> мы присваиваем значения
0.66&pi; и –0.66&pi; радиан соответственно &ndash; шкала нашего прибора будет начинаться в точке, отстоящей
от вертикали на 120&deg; против часовой стрелки, а заканчиваться &ndash; в точке, отстоящей от вертикали на
120&deg; по часовой стрелке (значение <span class="cpp">StartAngle</span> положительно, а <span class="cpp">EndAngle</span>
&ndash; отрицательно, потому что положительные углы во всех математических функциях откладываются против часовой
стрелки). Переменной <span class="cpp">ExcessAngle</span> присвоено значение 0.055&pi; радиан: разрешенный выход
стрелки за шкалу будет составлять примерно 10&deg;. Далее задаются размеры в точках экрана (в масштабе
подсистемы 100%) для всех элементов изображения.</p>

<p>Сразу после параметров рисования описаны два макроса, которые будут использоваться для пересчета
значения на входе блока в угловое положение точки на шкале и ее экранные координаты. Можно было бы сделать
эти макросы обычными функциями, но, поскольку они не будут использоваться нигде за пределами реакции модели
на рисование блока, а для написания функций пришлось бы открывать новую вкладку глобальных описаний,
ввести макросы будет проще.</p>

<p>Макрос <span class="cpp">V_TO_A(v)</span> с единственным параметром <span class="cpp">v</span> вычисляет
угол относительно вертикали, который на шкале прибора соответствует отображаемому значению <span class="cpp">v</span>.
В макросе записано обычное линейное преобразование диапазона
[<span class="cpp">Min</span>&hellip;<span class="cpp">Max</span>] в диапазон
[<span class="cpp">StartAngle</span>&hellip;<span class="cpp">EndAngle</span>]. Макрос
<span class="cpp">CALCPOINT(r,a,x,y)</span> записывает в параметры <span class="cpp">x</span> и
<span class="cpp">y</span> горизонтальную и вертикальную координаты точки, находящейся под углом
<span class="cpp">a</span> к вертикали на окружности радиуса <span class="cpp">r</span>, центр которой совпадает
с центром прибора (в макросе используются координаты центра прибора
<span class="cpp">CenterX</span> и <span class="cpp">CenterY</span>, которые будут вычислены позже).
С помощью этого макроса будут вычисляться и координаты концов всех рисок, и координаты конца стрелки. Сразу
за макросами описывается некоторое количество вспомогательных переменных, которые будут использованы
в программе.</p>

<p>Первое действие, которое мы делаем в программе модели, это проверка допустимости значений на входах блока.
Если хотя бы один из входов <span class="cpp">Max</span>, <span class="cpp">Min</span> или
<span class="cpp">Step</span>, описывающих шкалу, будет равен признаку ошибки
<span class="cpp"><a href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a></span>, или конец шкалы <span class="cpp">Max</span> будет меньше или равен
началу шкалы <span class="cpp">Min</span>, или шаг шкалы <span class="cpp">Step</span> будет равен нулю или
отрицателен, логической (<span class="cpp"><a href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a></span>) переменной <span class="cpp">scale_error</span> будет
присвоено значение <span class="cpp">TRUE</span>. Эту переменную мы будем использовать как признак
ошибки шкалы &ndash; при такой ошибке мы не можем ни нарисовать шкалу на приборе, ни, очевидно,
отобразить на нем значение входа. Если вход блока <span class="cpp">x</span> равен признаку ошибки, значение
<span class="cpp">TRUE</span> получит переменная <span class="cpp">x_error</span>
&ndash; при такой ошибке мы можем нарисовать шкалу, но не сможем нарисовать стрелку.</p>

<p>Записав признаки ошибок в логические переменные (они потребуются нам позже, при рисовании),
мы вычисляем <span class="cpp">CenterX</span> и <span class="cpp">CenterY</span> &ndash; координаты центра
прямоугольной области, занимаемой блоком, которая будет также центром нашего круглого прибора. Для этого
мы используем уже знакомые по прошлому примеру поля <span class="cpp">Left</span>, <span class="cpp">Top</span>,
<span class="cpp">Width</span> и <span class="cpp">Height</span> из структуры описания события рисования
<span class="cpp"><a href="RDS_BFM_DRAW.htm#ref1" title="Структура RDS_DRAWDATA">RDS_DRAWDATA</a></span>, указатель <span class="cpp">DrawData</span> на которую передается в
нашу функцию реакции. Горизонтальная координата центра &ndash; это левая граница плюс половина ширины блока,
а вертикальная &ndash; верхняя граница плюс половина его высоты. Напомним, что в структуре
<span class="cpp">RDS_DRAWDATA</span> все поля заполнены уже с учетом текущего масштаба подсистемы,
поэтому здесь нам не нужно умножать координаты на масштабный коэффициент (поле <span class="cpp">DoubleZoom</span>
той же структуры) самостоятельно.</p>

<p>Определив координаты центра прибора, мы вычисляем радиус <span class="cpp">R</span> его круга и координаты
<span class="cpp">left</span>, <span class="cpp">top</span>, <span class="cpp">right</span> и
<span class="cpp">bottom</span> квадрата в центральной части блока, в который будет вписан этот круг.
Для этого мы сравниваем ширину блока <span class="cpp">DrawData-&gt;Width</span> с его высотой
<span class="cpp">DrawData-&gt;Height</span>. Если ширина блока больше высоты (то есть блок вытянут
по горизонтали), верхняя граница <span class="cpp">top</span> и нижняя граница
<span class="cpp">bottom</span> его центрального квадрата будут совпадать с границами всего блока,
радиус круга будет равен половине высоты, а левая <span class="cpp">left</span> и правая
<span class="cpp">right</span> границы квадрата будут отстоять от центра на <span class="cpp">R</span>. Если
же высота блока больше ширины (блок вытянут по вертикали), <span class="cpp">left</span> и
<span class="cpp">right</span> будут совпадать с левой и правой границами блока, радиус круга
<span class="cpp">R</span> будет равен половине ширины, а <span class="cpp">top</span> и
<span class="cpp">bottom</span> будут на <span class="cpp">R</span> отстоять от центра прямоугольника.</p>

<p>Теперь мы можем нарисовать большой круг прибора, поверх которого будут выводиться шкала и стрелка.
Сделаем этот круг красным, если на входах блока есть какие-либо ошибки (то есть либо
<span class="cpp">x_error</span>, либо <span class="cpp">scale_error</span> имеют значение
<span class="cpp">TRUE</span>), а его рамку сделаем черной и сплошной, и будем, как и у рассмотренного
ранее индикатора уровня, увеличивать ее толщину вместе с масштабом. Сначала уже рассматривавшейся ранее
графической функцией RDS
<span class="cpp"><a href="rdsXGSetPenStyle.htm" title="А.5.18.25. rdsXGSetPenStyle &ndash; установить стиль линии">rdsXGSetPenStyle</a></span> мы устанавливаем параметры рамки (в качестве толщины рамки передается
текущий масштабный множитель подсистемы <span class="cpp">DrawData-&gt;DoubleZoom</span>), затем функцией
<span class="cpp"><a href="rdsXGSetBrushStyle.htm" title="А.5.18.20. rdsXGSetBrushStyle &ndash; установить стиль заливки">rdsXGSetBrushStyle</a></span> устанавливаются параметры заливки (в качестве цвета заливки
передается результат выполнения условного оператора &laquo;<span class="cpp">?:</span>&raquo; проверяющего признаки ошибок,
и возвращающего либо красный цвет <span class="cpp">0xff</span>, либо белый <span class="cpp">0xffffff</span>).
После этого вызывается функция рисования эллипса <span class="cpp"><a href="rdsXGEllipse.htm" title="А.5.18.6. rdsXGEllipse &ndash; эллипс или окружность">rdsXGEllipse</a></span>, очень похожая на
рассматривавшуюся ранее функцию рисования прямоугольника <span class="cpp"><a href="rdsXGRectangle.htm" title="А.5.18.18. rdsXGRectangle &ndash; прямоугольник">rdsXGRectangle</a></span>:</p>

<pre class="cpp">  <a class="hidden" href="rdsXGEllipse.htm" title="А.5.18.6. rdsXGEllipse &ndash; эллипс или окружность">rdsXGEllipse</a>(left,    // Левая граница
               top,     // Верхняя граница
               right,   // Правая граница
               bottom); // Нижняя граница</pre>

<p class="noindent">Поскольку <span class="cpp">left</span>, <span class="cpp">top</span>,
<span class="cpp">right</span> и <span class="cpp">bottom</span> &ndash; границы центрального квадрата блока,
эта функция нарисует эллипс с осями одинаковой длины, то есть круг.</p>

<p>Нарисовав круг прибора, мы проверяем значение признака ошибки шкалы <span class="cpp">scale_error</span>.
Если оно истинно, мы немедленно завершаем модель: без параметров шкалы мы ничего больше не сможем нарисовать.
Таким образом, если параметры шкалы заданы неверно, наш прибор будет выглядеть просто как красный круг с
черной рамкой.</p>

<p>Если же параметры шкалы прошли все проверки, мы продолжаем выполнение модели и вычисляем расширенный диапазон
шкалы с учетом добавочного разрешенного угла отклонения стрелки <span class="cpp">ExcessAngle</span>. Сначала
в переменную <span class="cpp">a</span> записывается интервал значений, соответствующий на шкале углу
<span class="cpp">ExcessAngle</span> (это линейное преобразование диапазона
[<span class="cpp">StartAngle</span>&hellip;<span class="cpp">EndAngle</span>] в диапазон
[<span class="cpp">Min</span>&hellip;<span class="cpp">Max</span>], обратное выполняемому макросом
<span class="cpp">V_TO_A</span>, но без знака и смещений). Вычитая этот интервал из
<span class="cpp">Min</span> и добавляя его к <span class="cpp">Max</span>, мы получаем границы расширенного
на дополнительный угол диапазона входных значений <span class="cpp">e_min</span> и
<span class="cpp">e_max</span> соответственно. В этих пределах входное значение будет преобразовываться в
угол отклонения стрелки.</p>

<p>Далее мы отключаем заливку геометрических фигур вызовом <span class="cpp">rdsXGSetBrushStyle</span> (если
не сделать этого, числа на шкале будут выведены в закрашенных прямоугольниках) и вычисляем радиусы концентрических
окружностей, на которых располагаются различные элементы шкалы и конец стрелки:</p>

<ul>
  <li><span class="cpp">r1</span> &ndash; радиус окружности, на которой лежат внешние концы всех рисок;</li>
  <li><span class="cpp">r2</span> &ndash; радиус окружности, на которой лежат внутренние концы больших рисок;</li>
  <li><span class="cpp">rs</span> &ndash; радиус окружности, на которой лежат внутренние концы маленьких рисок;</li>
  <li><span class="cpp">rf</span> &ndash; радиус окружности, на которой лежат внешние границы чисел шкалы;</li>
  <li><span class="cpp">ra</span> &ndash; радиус окружности, на которой лежит конец стрелки.</li>
</ul>

<p class="noindent">Все эти радиусы вычисляются согласно изображенным
на <a href="#pic5" title="Предполагаемый вид и параметры стрелочного индикатора">рис.&nbsp;415</a>
параметрам рисования, но при этом эти параметры умножаются на <span class="cpp">DrawData-&gt;DoubleZoom</span>
для учета текущего масштаба подсистемы. Например, согласно рисунку, в масштабе 100% внешняя граница рисок
отстоит от края прибора на <span class="cpp">D_Tick</span> точек экрана. Масштаб 100% соответствует
<span class="cpp">DrawData-&gt;DoubleZoom</span>=1. Значит, в произвольном масштабе риски будут отстоять
от края прибора на произведение <span class="cpp">D_Tick</span> и
<span class="cpp">DrawData-&gt;DoubleZoom</span> &ndash; радиус окружности
<span class="cpp">r1</span> будет короче радиуса всего прибора <span class="cpp">R</span> на эту величину.</p>

<p>Теперь можно нарисовать шкалу. Мы будем рисовать ее в цикле по вещественной переменной
<span class="cpp">v</span>, изменяющейся от <span class="cpp">Min</span> до <span class="cpp">Max</span> с шагом
<span class="cpp">Step</span>:</p>

<pre class="cpp">  for(v=Min;v&lt;=Max+Step*0.001;v+=Step)</pre>

<p>Здесь в качестве конца цикла выбрано не <span class="cpp">Max</span>, а значение, большее
<span class="cpp">Max</span> на одну тысячную шага изменения: если диапазон кратен шагу, из-за
погрешностей вычисления последнее значение <span class="cpp">v</span> может оказаться чуть больше
<span class="cpp">Max</span>, и при обычной проверке <span class="cpp">v&lt;=Max</span> самая последняя
большая риска шкалы могла бы пропасть. Например, при <span class="cpp">Min</span>=0, <span class="cpp">Max</span>=100,
<span class="cpp">Step</span>=20 на шкале должно быть выведено шесть больших рисок с числами:
0, 20, 40, 60, 80 и 100. Однако, после пятого прибавления <span class="cpp">Step</span> (20) к <span class="cpp">v</span>
может получиться не 100, а 100.00000001. При этом, поскольку это число больше
<span class="cpp">Max</span>, риска не была бы нарисована. Добавление к концу шкалы небольшой доли шага позволяет
справиться с этой проблемой.</p>

<p>Внутри цикла мы при помощи макроса <span class="cpp">V_TO_A</span> вычисляем угол
<span class="cpp">a</span>, который на нашей шкале соответствует величине <span class="cpp">v</span>, и,
по этому углу и радиусам <span class="cpp">r1</span> и <span class="cpp">r2</span>, макросами
<span class="cpp">CALCPOINT</span> вычисляем координаты концов большой риски, соответствующей значению
<span class="cpp">v</span>. Эти координаты записываются в пары переменных
(<span class="cpp">ix1</span>,&nbsp;<span class="cpp">iy1</span>) и
(<span class="cpp">ix2</span>,&nbsp;<span class="cpp">iy2</span>). В RDS нет графической функции, позволяющей
одним вызовом нарисовать линию между двумя точками, поэтому, чтобы нарисовать риску, приходится делать два
вызова: сначала мы задаем координаты начала линии, вызвав функцию
&laquo;<span class="cpp"><a href="rdsXGMoveTo.htm" title="А.5.18.14. rdsXGMoveTo &ndash; установить текущую точку рисования">rdsXGMoveTo</a>(ix1,iy1)</span>&raquo;, а затем вызываем функцию
&laquo;<span class="cpp"><a href="rdsXGLineTo.htm" title="А.5.18.13. rdsXGLineTo &ndash; отрезок прямой">rdsXGLineTo</a>(ix2,iy2)</span>&raquo;, которая нарисует линию из этой точки в точку
(<span class="cpp">ix2</span>,&nbsp;<span class="cpp">iy2</span>).
Линия будет нарисована с параметрами, заданными последним вызовом <span class="cpp">rdsXGSetPenStyle</span>,
то есть риска шкалы будет черной сплошной линией с толщиной, равной масштабу подсистемы.</p>

<p>Теперь рядом с этой риской нужно вывести число <span class="cpp">v</span>, причем это число должно быть
повернуто на угол риски <span class="cpp">a</span>, как
на <a href="#pic5" title="Предполагаемый вид и параметры стрелочного индикатора">рис.&nbsp;415</a>.
Для этого придется последовательно выполнить следующие действия:</p>

<ul>
  <li>преобразовать число <span class="cpp">v</span> в текстовый вид, оставив в его дробной части
  <span class="cpp">Dec</span> знаков;</li>

  <li>установить шрифт для вывода текста &ndash; пока без поворота (будем использовать шрифт
  &laquo;Arial&raquo;, высота которого будет равна произведению параметра <span class="cpp">FontHeight</span>
  на масштаб подсистемы);</li>

  <li>вычислить ширину числа в точках экрана, которую оно займет, если вывести его текущим установленным шрифтом;</li>

  <li>установить шрифт, повернутый на угол риски шкалы <span class="cpp">a</span>;</li>

  <li>вычислить координаты левой верхней точки выводимого текста с учетом его поворота;</li>

  <li>вывести текст.</li>
</ul>

<p class="noindent"><span id="ref20">Для</span>
того, чтобы преобразовать вещественное число <span class="cpp">v</span> в строку, можно, например,
использовать стандартную функцию <span class="cpp">sprintf</span>, как в примере из
<a href="um_3_7_2_5.htm" title="&sect;3.7.2.5. Модели со строками">&sect;3.7.2.5</a>. Однако, ее использование требует добавления в раздел
глобальных описаний команды для включения файла &laquo;<span class="file">stdio.h</span>&raquo;, а для этого придется открыть
еще одну вкладку в редакторе модели. Чтобы не делать этого, воспользуемся сервисной функцией RDS
<span id="light_ref20"><span class="cpp"><a href="rdsDtoA.htm" title="А.5.4.5. rdsDtoA &ndash; преобразование вещественного числа в строку">rdsDtoA</a></span></span>, которая формирует в динамической памяти строку с текстовым представлением
числа с заданным количеством знаков в дробной части:</p>

<pre class="cpp">  str=<a class="hidden" href="rdsDtoA.htm" title="А.5.4.5. rdsDtoA &ndash; преобразование вещественного числа в строку">rdsDtoA</a>(v,     // Преобразуемое число
              Dec,   // Знаков в дробной части
              NULL); // Через этот указатель функция может вернуть
                     // длину созданной строки</pre>

<p>В первом параметре функции передается преобразуемое число (<span class="cpp">v</span>), во втором
&ndash; необходимое число знаков после десятичной точки (<span class="cpp">Dec</span>), в третьем можно было
бы передать указатель на целую переменную, в которую функция запишет длину созданной ей строки, но
нам эта длина не нужна, поэтому в третьем параметре мы передаем <span class="cpp">NULL</span>. Функция возвращает
указатель (<span class="cpp">char*</span>) на созданную строку, который мы записываем во вспомогательную переменную
<span class="cpp">str</span>. Потом, когда эта строка уже не будет нам нужна, ее нужно будет обязательно удалить при помощи функции
<span class="cpp"><a href="rdsFree.htm" title="А.5.4.8. rdsFree &ndash; освобождение отведенной динамической памяти">rdsFree</a></span>.</p>

<p>Получив текст, который мы будем выводить рядом с риской шкалы, мы устанавливаем шрифт для вывода текста
функцией <span class="cpp"><a href="rdsXGSetFont.htm" title="А.5.18.22. rdsXGSetFont &ndash; установить шрифт">rdsXGSetFont</a></span>:</p>

<pre class="cpp">  <a class="hidden" href="rdsXGSetFont.htm" title="А.5.18.22. rdsXGSetFont &ndash; установить шрифт">rdsXGSetFont</a>(RDS_GFFONTALLHEIGHT,             // Маска установки
               "Arial",                         // Имя шрифта
               FontHeight*DrawData->DoubleZoom, // Размер шрифта
               0,                               // Цвет шрифта
               DEFAULT_CHARSET,                 // Набор символов
               0,                               // Угол поворота (гр)
               FALSE,                           // Жирность
               FALSE,                           // Курсив
               FALSE,                           // Подчеркивание
               FALSE);                          // Перечеркивание</pre>

<p><span id="ref21">В</span>
<span id="ref22">первом</span>
<span id="ref23">параметре</span> этой функции передается набор битовых флагов, указывающий на то, какие именно
параметры шрифта мы устанавливаем. Константа
<span class="cpp" id="light_ref21">RDS_GFFONTALLHEIGHT</span> объединяет флаги всех параметров,
причем размер шрифта при ее использовании задается в точках экрана, а не в типографских точках.
Второй параметр функции задает имя шрифта (у нас &ndash; &laquo;Arial&raquo;), третий &ndash;
размер (высоту <span class="cpp">FontHeight</span> для масштаба 100% мы умножаем на масштаб подсистемы
<span class="cpp">DrawData-&gt;DoubleZoom</span>), четвертый &ndash; цвет символов (0 означает черный).
В пятом параметре указывается используемый набор символов шрифта: мы будем выводить только цифры,
десятичную точку и знак минуса, поэтому в этом параметре указана стандартная константа Windows API для
набора по умолчанию &ndash; <span class="cpp" id="light_ref22">DEFAULT_CHARSET</span> (если бы, например,
нам нужно было вывести текст на русском языке, необходимо было бы передать в нем
<span class="cpp" id="light_ref23">RUSSIAN_CHARSET</span>).
В шестом параметре передается угол поворота шрифта в градусах &ndash; мы передаем ноль, поскольку мы его еще
не поворачиваем, нам пока предстоит определить ширину не повернутого текста в точках экрана. Наконец, в
последних четырех параметрах передаются логические признаки жирности, курсива, подчеркивания и
перечеркивания шрифта.</p>

<p>Шрифт установлен, теперь мы вызываем функцию <span class="cpp"><a href="rdsXGGetTextSize.htm" title="А.5.18.10. rdsXGGetTextSize &ndash; получить размеры строки текста">rdsXGGetTextSize</a></span>, которая
вернет нам ширину строки текста <span class="cpp">str</span>, выведенной текущим шрифтом,
в точках экрана:</p>
<pre class="cpp">  <a class="hidden" href="rdsXGGetTextSize.htm" title="А.5.18.10. rdsXGGetTextSize &ndash; получить размеры строки текста">rdsXGGetTextSize</a>(str,   // Текст
                   &amp;w,    // Сюда запишется ширина
                   NULL); // Сюда могла бы записаться высота</pre>

<p>В первом параметре функции передается указатель на строку, ширину которой мы хотим узнать, во втором
&ndash; указатель на целую переменную, в которую функция запишет ширину строки, в третьем можно было бы
передать указатель на переменную для высоты строки, но высота нас не интересует, поэтому мы передаем в
нем <span class="cpp">NULL</span>.</p>

<p>Теперь можно установить повернутый шрифт. Для этого мы снова вызываем <span class="cpp">rdsXGSetFont</span>
с теми же параметрами, только в качестве угла поворота теперь передается не ноль, а
<span class="cpp">a*180.0/M_PI</span> (то есть угол риски <span class="cpp">a</span>, переведенный в
градусы). Затем, при помощи макроса <span class="cpp">CALCPOINT</span>, мы вычисляем точку, находящуюся на
одной линии с риской, но на расстоянии <span class="cpp">rf</span> от центра круга, и записываем ее координаты в
переменные (<span class="cpp">ix1</span>,&nbsp;<span class="cpp">iy1</span>). Чтобы число на шкале располагалось
симметрично относительно риски, на эту точку должна приходиться середина верхней границы прямоугольной области,
занимаемой его текстом. Поскольку в функциях вывода текста место вывода задается левым верхним углом первого
символа строки, необходимо вычислить этот левый верхний угол. Если бы текст не был повернут, левый верхний угол
первого символа отстоял бы от (<span class="cpp">ix1</span>,&nbsp;<span class="cpp">iy1</span>) влево на половину
ширины строки, то есть на <span class="cpp">w/2</span>. Чтобы учесть поворот строки на угол <span class="cpp">a</span>,
необходимо умножить <span class="cpp">w/2</span> на синус (для вертикальной координаты) и косинус (для
горизонтальной) этого угла. Таким образом, левый верхний угол первого символа повернутого текста будет находиться
в точке (<span class="cpp">ix2</span>,&nbsp;<span class="cpp">iy2</span>):</p>

<pre class="cpp">  ix2=ix1-0.5*w*cos(a);
  iy2=iy1+0.5*w*sin(a);</pre>

<p>Теперь можно выводить число. Для этого используется функция
<span class="cpp"><a href="rdsXGTextOut.htm" title="А.5.18.27. rdsXGTextOut &ndash; строка текста">rdsXGTextOut</a></span>, в которую передаются вычисленные координаты
<span class="cpp">ix2</span> и <span class="cpp">iy2</span> и выводимая строка <span class="cpp">str</span>.
После вызова этой функции строка с числом нам уже не нужна, и мы освобождаем ее память вызовом
<span class="cpp"><a href="rdsFree.htm" title="А.5.4.8. rdsFree &ndash; освобождение отведенной динамической памяти">rdsFree</a></span>.</p>

<p>Большая риска с числом нарисована &ndash; теперь необходимо вывести после нее мелкие риски. В одном
большом интервале шкалы содержится <span class="cpp">Sub</span> маленьких интервалов, то есть необходимо вывести
<span class="cpp">Sub</span>–1 мелких рисок (в начале самого первого маленького интервала уже выведена большая
риска). Мы выводим их в цикле по целой переменной <span class="cpp">i</span>, изменяющейся от 1 до
<span class="cpp">Sub</span>–1. Внутри цикла мы вычисляем значение, соответствующее <span class="cpp">i</span>-й
мелкой риске, по формуле <span class="cpp">v+i*Step/Sub</span>:
<span class="cpp">v</span> &ndash; это значение большой риски шкалы в начале интервала, а
<span class="cpp">Step/Sub</span> &ndash; шаг мелких рисок. Если значение получилось больше верхнего предела
шкалы <span class="cpp">Max</span>, мы досрочно прерываем цикл, поскольку дальше риски рисовать не нужно.
В противном случае мы вычисляем угол мелкой риски при помощи макроса <span class="cpp">V_TO_A</span>, а
затем макросами <span class="cpp">CALCPOINT</span> рассчитываем координаты концов риски,
лежащих на радиусах <span class="cpp">r1</span> и <span class="cpp">rs</span>, после чего рисуем риску вызовами
<span class="cpp">rdsXGMoveTo</span> и <span class="cpp">rdsXGLineTo</span>.</p>

<p>После того, как вся шкала нарисована, можно нарисовать стрелку, если, конечно, вход блока
<span class="cpp">x</span> не содержит признака ошибки <span class="cpp">rdsbcppHugeDouble</span>
(в этом случае переменная <span class="cpp">x_error</span> будет иметь значение <span class="cpp">TRUE</span>).
<span id="ref24">Для</span> рисования стрелки мы меняем цвет линии на красный (<span class="cpp">0xff</span>) вызовом</p>

<pre class="cpp"> <a class="hidden" href="rdsXGSetPenStyle.htm" title="А.5.18.25. rdsXGSetPenStyle &ndash; установить стиль линии">rdsXGSetPenStyle</a>(RDS_GFCOLOR,0,0,0xff,0)</pre>

<p class="noindent">(константа <span class="cpp"id="light_ref24">RDS_GFCOLOR</span> в первом
параметре указывает на то, что мы меняем только цвет линии, а ее толщина, стиль и режим вывода
остаются неизменными). После этого мы, как и для рисок шкалы, при помощи макросов
<span class="cpp">V_TO_A</span> и <span class="cpp">CALCPOINT</span> вычисляем координаты конца стрелки,
соответствующие ее положению для значения на входе блока <span class="cpp">x</span>, и рисуем линию из
центра прибора в эту точку. Нарисовав стрелку, мы снова устанавливаем черный цвет линии, включаем сплошную
белую заливку и рисуем в центре прибора круг, радиус которого вычисляется как половина параметра
<span class="cpp">CenterDisk</span> (диаметр этого круга для масштаба 100%), умноженная на текущий масштаб
подсистемы блока.</p>

<p>Теперь можно скомпилировать модель и закрыть редактор. В параметрах внешнего вида блока следует
<a href="#pic3" title="Включение программного рисования в окне параметров блока">включить флажки</a>
&laquo;<span class="menu">внешний вид &ndash; определяется функцией DLL</span>&raquo; и
&laquo;<span class="menu">разрешить масштабирование</span>&raquo;, после чего можно будет растянуть маркеры выделения
блока, задав ему любой желаемый размер.</p>

<p>Для проверки работы модели можно собрать схему, изображенную
на <a href="#pic6" title="Тестирование модели стрелочного индикатора">рис.&nbsp;416</a>.
В ней к входам &laquo;<span class="rdsvar">x</span>&raquo; и &laquo;<span class="rdsvar">Max</span>&raquo; индикатора подключены поля ввода. Если
запустить расчет и изменять значение &laquo;<span class="rdsvar">x</span>&raquo;, стрелка прибора будет двигаться. Если изменять
значение &laquo;<span class="rdsvar">Max</span>&raquo;, будет меняться диапазон шкалы, а стрелка будет оставаться на одной и
той же риске.</p>

<div class="pic"><div class="container" id="pic6">
<img src="../img/AC_dlldraw_gauge.png" width="383" height="206" alt="Тестирование модели стрелочного индикатора" />
<p id="light_pic6">Рис.&nbsp;416. Тестирование модели стрелочного индикатора</p>
</div></div>


<p>Стрелочный индикатор, похожий на созданный, можно было бы нарисовать и при помощи векторной картинки
блока, но при этом его шкала была бы фиксированной, на ней не могли бы появляться новые риски и числа
при изменении входов &laquo;<span class="rdsvar">Min</span>&raquo;, &laquo;<span class="rdsvar">Max</span>&raquo; и &laquo;<span class="rdsvar">Step</span>&raquo;. В нашем же
блоке шкала формируется программно и может быть какой угодно.</p>

<p><span id="ref25">В</span>
моделях, рисующих внешний вид блока программно, часто вводят еще и
<span id="light_ref25">реакцию на изменение размеров блока</span> &ndash;
при этом можно пересчитывать какие-либо параметры рисования, или каким-либо образом вмешиваться в
изменение размеров. Созданный нами стрелочный индикатор, например, всегда имеет форму круга, поэтому было
бы логично не давать пользователю вытягивать его по горизонтали и вертикали. Сделаем так, чтобы, как
бы ни перетаскивал пользователь маркеры выделения нашего блока, его область всегда оставалась квадратной.</p>

<p>Моделью блока поддерживаются две реакции на события, связанные с изменениями размеров блока:
реакция на
<a href="ac_RDS_BFM_RESIZING.htm" title="&sect;3.8.9.2. Проверка изменения размера блока">перетаскивание маркеров выделения</a>
пользователем, и реакция на
<a href="ac_RDS_BFM_RESIZE.htm" title="&sect;3.8.9.1. Размер блока изменен">окончание изменения размеров</a> (подробно они описаны в
<a href="pm_2_12_8.htm" title="&sect;2.12.8. Реакция на действия пользователя при редактировании схемы">&sect;2.12.8 руководства программиста</a>). Первое событие возникает при каждом движении
мыши в процессе перетаскивания маркеров, второе &ndash; когда пользователь отпускает кнопку мыши по
окончании перетаскивания, или когда размер блока задан явно вводом ширины и высоты в окне его параметров.
Для упрощения примера мы введем в нашу модель только реакцию на первое событие, поскольку оно, как и
второе, позволяет скорректировать размер блока так, как нам надо, и дает пользователю визуальную обратную связь:
если модель вмешается в изменение размеров блока, это немедленно отразится на размере прямоугольника, который
пользователь видит при <a href="um_2_6.htm#ref9" title="Изменение размеров блока">перетаскивании</a>
меток масштабирования.</p>

<p><span id="ref26">Откроем</span>
вкладку события перетаскивания маркеров выделения: на левой панели окна редактора выберем
вкладку &laquo;<span class="menu">события</span>&raquo;
(см. <a href="um_3_6_4.htm" title="&sect;3.6.4. Описания программы и реакции блока на события">&sect;3.6.4</a>), раскроем на ней раздел
&laquo;<span class="menu">внешний вид блока</span>&raquo; и дважды щелкнем на его подразделе
&laquo;<span class="menu">проверка изменения размера (<span id="light_ref26">RDS_BFM_RESIZING</span>)</span>&raquo;
(<a href="#pic7" title="Реакция на изменение размеров блока в списке событий">рис.&nbsp;417</a>).
При этом значок подраздела станет желтым, а в правой части окна появится новая пустая вкладка
&laquo;<span class="menu">проверка размера</span>&raquo;.</p>

<div class="pic"><div class="container" id="pic7">
<img src="../img/AC_resizing_event.png" width="340" height="367" alt="Реакция на изменение размеров блока в списке событий" />
<p id="light_pic7">Рис.&nbsp;417. Реакция на изменение размеров блока в списке событий</p>
</div></div>


<p>Введем на этой вкладке следующий текст (точно такая же реакция используется в
примере из <a href="pm_2_12_8.htm" title="&sect;2.12.8. Реакция на действия пользователя при редактировании схемы">&sect;2.12.8 руководства программиста</a> руководства программиста):</p>

<pre class="cpp">
  if(ResizeData-&gt;HorzResize &amp;&amp; (!ResizeData-&gt;VertResize))
    // Перетаскивается левый или правый маркер
    ResizeData-&gt;newHeight=ResizeData-&gt;newWidth;
  else if((!ResizeData-&gt;HorzResize) &amp;&amp; ResizeData-&gt;VertResize)
    // Перетаскивается верхний или нижний маркер
    ResizeData-&gt;newWidth=ResizeData-&gt;newHeight;
  else // Перетаскивается угловой маркер
    { // Вычисляем среднее арифметическое размеров
      int avg=(ResizeData-&gt;newWidth+ResizeData-&gt;newHeight)/2;
      // Присваиваем его и ширине и высоте
      ResizeData-&gt;newWidth=ResizeData-&gt;newHeight=avg;
    }</pre>

<p><span id="ref27">В</span>
<span id="ref28">эту</span> реакцию передается указатель
<span class="cpp" id="light_ref27">ResizeData</span> на структуру
<span id="light_ref28"><span class="cpp"><a href="RDS_BFM_RESIZE.htm#ref2" title="Структура RDS_RESIZEDATA">RDS_RESIZEDATA</a></span></span>, которая описывает выполняемое изменение
размеров блока. Нас в этой структуре будут интересовать только четыре поля: целые
<span class="cpp">newWidth</span> и <span class="cpp">newHeight</span>, содержащие новые значения ширины
и высоты блока, и логические <span class="cpp">HorzResize</span> и
<span class="cpp">VertResize</span>, указывающие на то, какие маркеры выделения перетаскивает пользователь.
Различные сочетания значений <span class="cpp">HorzResize</span> и <span class="cpp">VertResize</span>
соответствует следующим ситуациям:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>HorzResize</th>
    <th>VertResize</th>
    <th>Способ изменения</th>
  </tr>

  <tr>
    <td class="center"><span class="cpp">TRUE</span></td>
    <td class="center"><span class="cpp">TRUE</span></td>
    <td>Пользователь перетаскивает один из угловых маркеров выделения</td>
  </tr>

  <tr>
    <td class="center"><span class="cpp">TRUE</span></td>
    <td class="center"><span class="cpp">FALSE</span></td>
    <td>Пользователь перетаскивает левый или правый маркер выделения</td>
  </tr>

  <tr>
    <td class="center"><span class="cpp">FALSE</span></td>
    <td class="center"><span class="cpp">TRUE</span></td>
    <td>Пользователь перетаскивает верхний или нижний маркер выделения</td>
  </tr>

</table>
</div></div>

<p>На момент вызова нашей реакции в полях структуры
<span class="cpp">ResizeData-&gt;newWidth</span> и
<span class="cpp">ResizeData-&gt;newHeight</span> находятся ширина и высота блока,
которые попытался установить пользователь. Если перетаскивается левый или правый маркер, значит,
пользователь пытается изменить ширину блока, и мы копируем <span class="cpp">newWidth</span> в
<span class="cpp">newHeight</span>,
чтобы высота блока оставалась равной ширине. Если перетаскивается верхний или нижний маркер, значит,
пользователь меняет высоту блока, и мы, наоборот, копируем <span class="cpp">newHeight</span> в
<span class="cpp">newWidth</span>, делая ширину блока равной высоте. Если же пользователь перетаскивает
один из угловых маркеров, значит, он пытается одновременно изменить и ширину, и высоту. В этом случае
мы присваиваем <span class="cpp">newWidth</span> и <span class="cpp">newHeight</span> среднее
арифметическое заданных пользователем размеров &ndash; при этом поведение блока будет выглядеть
более-менее естественным.</p>

<p>Теперь, если скомпилировать модель, область, занимаемая блоком, при перетаскивании маркеров выделения будет
все время оставаться квадратной, и круглый индикатор, нарисованный внутри нее, будет заполнять ее полностью.
Пользователь все еще может сделать область блока прямоугольной, войдя в окно его параметров, выбрав там
вкладку &laquo;<span class="menu">внешний вид</span>&raquo;, нажав на панели &laquo;<span class="menu">в подсистеме</span>&raquo; кнопку
&laquo;<span class="menu">размер для функции DLL</span>&raquo;
(см. <a href="#pic3" title="Включение программного рисования в окне параметров блока">рис.&nbsp;413</a>) и введя произвольные размеры. Работу
индикатора это не нарушит &ndash; его модель написана так, чтобы он всегда оставался круглым. Можно,
при желании, заблокировать и такое изменение размеров, просто скопировав введенную нами реакцию в реакцию
на событие &laquo;<span class="menu">размер блока изменен</span>&raquo;, которое находится в том же разделе
&laquo;<span class="menu">внешний вид блока</span>&raquo;
(см. <a href="#pic7" title="Реакция на изменение размеров блока в списке событий">рис.&nbsp;417</a>) на первом месте. В эту реакцию передается точно
такой же указатель <span class="cpp">ResizeData</span> на структуру <span class="cpp">RDS_RESIZEDATA</span>,
поэтому в тексте программы ничего не нужно изменять.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_7_4_4.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_6.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_5">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
