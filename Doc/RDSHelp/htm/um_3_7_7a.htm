<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.7.8. Программное управление динамическими переменными</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</a></p>
<div class="level"><p>&sect;3.7.8. Программное управление динамическими переменными</p>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_7_7.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_8.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_7a">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</h3>
<h4>&sect;3.7.8. Программное управление динамическими переменными</h4>
<p class="abstract">Описывается программное выполнение всех действий по созданию, удалению и подписке на динамические переменные.</p>


<p>В <a href="um_3_7_7.htm" title="&sect;3.7.7. Задание пользователем имен динамических переменных">&sect;3.7.7</a>
рассматриваются модели блоков, в которых имена динамических переменных хранятся в настроечных параметрах
блоков. Модуль автокомпиляции при этом автоматически добавляет в программу модели вызовы, необходимые
для удаления и прекращения подписки на переменную со старым именем и создания и подписки на
переменную с новым именем при изменении этого имени. В некоторых, довольно редких, случаях может потребоваться
задавать имя динамической переменной программно &ndash; например, при изменении состояния
блока или значений других его переменных. Это осуществимо, но при этом придется
отказаться от автоматического создания переменной и автоматического получения к ней доступа &ndash;
эти функции, добавляемые в модель модулем автокомпиляции, нужно будет отключить. Вместо этого придется создавать
переменную и получать к ней доступ вручную при помощи специальных функций-членов объекта для работы с
переменной. В каждом таком объекте для этой цели предусмотрено четыре функции:</p>

<dl>
  <dt><span class="cpp"><a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> <span id="light_ref1">Create</span>(<span id="ref2">int</span> <span id="ref3">Block</span>,<span id="ref4">char</span> *Name,<a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> Fixed)</span></dt>
  <dd>Создание динамической переменной с именем <span class="cpp">Name</span> в блоке, указываемом целым параметром
  <span class="cpp">Block</span>, который может принимать одно из трех значений:
  <span id="light_ref2" class="cpp">RDS_DVSELF</span> (создать переменную в вызвавшем блоке),
  <span class="cpp" id="light_ref3">RDS_DVPARENT</span> (создать переменную в
  <a href="um_1_2.htm#ref13" title="Родительская подсистема">родительской подсистеме</a>) или
  <span class="cpp" id="light_ref4">RDS_DVROOT</span> (создать переменную в
  <a href="um_1_2.htm#ref11" title="Корневая подсистема">корневой подсистеме</a>).
  Чаще всего используются варианты <span class="cpp">RDS_DVPARENT</span> и <span class="cpp">RDS_DVROOT</span>,
  поскольку переменная, созданная в простом блоке, не будет видна никому, кроме этого блока. Значение
  <span class="cpp">TRUE</span> в параметре <span class="cpp">Fixed</span> разрешает удалять переменную только
  создавшему ее блоку, значение <span class="cpp">FALSE</span> &ndash; любому из блоков схемы. Функция
  возвращает успешность создания переменной. Если вызвать эту функцию-член у объекта, который уже связан с
  созданной динамической переменной, ранее созданная переменная будет удалена, после чего будет создана
  новая, согласно параметрам функции.</dd>

  <dt><span class="cpp"><a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> <span id="light_ref5">Delete</span>(void)</span></dt>
  <dd>Удалить переменную, ранее созданную вызовом <span class="cpp">Create</span>.
  Возвращается успешность удаления.</dd>

  <dt><span class="cpp"><a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> <span id="light_ref6">Subscribe</span>(int Block,char *Name,<a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> Search)</span></dt>
  <dd>Получить доступ к переменной с именем <span class="cpp">Name</span> в блоке, указываемом целым параметром
  <span class="cpp">Block</span>, который принимает те же три значения, что и одноименный параметр функции
  <span class="cpp">Create</span>: <span class="cpp">RDS_DVSELF</span> (искать переменную в вызвавшем блоке),
  <span class="cpp">RDS_DVPARENT</span> (искать переменную в родительской подсистеме) или
  <span class="cpp">RDS_DVROOT</span> (искать переменную в корневой подсистеме). Значение <span class="cpp">TRUE</span>
  в параметре <span class="cpp">Search</span> заставит RDS искать переменную с указанным в параметре
  <span class="cpp">Name</span> именем и заложенным в сам объект типом начиная с указанного блока вверх по всей
  иерархии подсистем вплоть до корневой. Функция возвращает <span class="cpp">FALSE</span> только в случае
  какой-либо серьезной ошибки &ndash; например, если вместо имени переменной передана пустая строка.
  <span class="cpp">TRUE</span> возвращается даже тогда, когда переменная с указанным именем не найдена:
  RDS запоминает факт обращения к этой переменной и, как только она появится, предоставит блоку доступ к
  ней. Для проверки фактического существования переменной используется функция-член
  <span class="cpp"><a href="um_3_7_3_1.htm#ref5" title="Проверка существования динамической переменной">Exists</a></span>. Если вызвать функцию
  <span class="cpp">Subscribe</span> у объекта, который уже связан с какой-либо динамической переменной,
  прежняя связь будет разорвана и будет установлена новая.</dd>

  <dt><span class="cpp"><a class="hidden" href="app_ids.htm#light_ref11" title="Логический тип Windows API">BOOL</a> <span id="light_ref7">Unsubscribe</span>(void)</span></dt>
  <dd>Разорвать связь с динамической переменной, ранее установленную вызовом <span class="cpp">Subscribe</span>.</dd>

</dl>

<p class="noindent">Во всех этих функциях тип динамической переменной не указывается, он всегда жестко закладывается в объект
для работы с ней при его
<a href="um_3_6_3.htm" title="&sect;3.6.3. Динамические переменные блока">добавлении в редактор модели</a>.</p>

<p>В качестве примера использования этих функций изменим пример из
<a href="um_3_7_7.htm" title="&sect;3.7.7. Задание пользователем имен динамических переменных">&sect;3.7.7</a>: будем вручную выполнять все действия,
которые необходимы для изменения имени переменной. Начнем с модели блока-передатчика.</p>

<p><span id="ref8">Прежде всего</span>
откроем редактор модели блока, дважды щелкнем на динамической переменной
&laquo;<span class="rdsvar">DynVar</span>&raquo;, в окне ее параметров в выпадающем списке
&laquo;<span class="menu">действие</span>&raquo; выберем вариант
&laquo;<span id="light_ref8">все действия &ndash; вручную</span>&raquo;
(<a href="#pic1" title="Параметры объекта для динамической переменной без привязки к конкретной переменной">рис.&nbsp;434</a>)
и закроем окно кнопкой &laquo;<span class="menu">OK</span>&raquo;.</p>

<div class="pic"><div class="container" id="pic1">
<img src="../img/AC_createdynvar_man.png" width="630" height="364" alt="Параметры объекта для динамической переменной без привязки к конкретной переменной" />
<p id="light_pic1">Рис.&nbsp;434. Параметры объекта для динамической переменной<br />без привязки к конкретной переменной</p>
</div></div>


<div class="picright"><div class="container" id="pic2">
<img src="../img/AC_dynvarlist_man.png" width="282" height="114" alt="Измененный объект в списке динамических переменных модели" />
<p id="light_pic2">Рис.&nbsp;435. Измененный объект в списке<br />динамических переменных модели</p>
</div></div>


<p>После закрытия окна в списке динамических переменных редактора модели в левой колонке рядом с именем объекта
&laquo;<span class="rdsvar">DynVar</span>&raquo; будет нарисован пустой белый квадрат
(<a href="#pic2" title="Измененный объект в списке динамических переменных модели">рис.&nbsp;435</a>) &ndash; это указывает на то,
что объект автоматически не связывается с какой-либо динамической переменной.</p>

<p>Теперь в нашей модели есть объект <span class="cpp">DynVar</span> для обращения к динамической переменной типа
<span class="cpp">double</span>, не связанный автоматически ни с какой переменной, и объект <span class="cpp">VarName</span>,
хранящий имя переменной, введенное пользователем в настройках  (он
остался от прежней версии модели). Необходимо дать указание объекту
<span class="cpp">DynVar</span> создать переменную с таким именем &ndash; для этого служит его функция-член
<span class="cpp"><a href="#light_ref1" title="Функция Create класса динамической переменной">Create</a></span>, описанная выше. Причем вызывать эту функцию
нужно после любого изменения значения настроечного параметра <span class="cpp">VarName</span>.</p>

<p>В автокомпилируемой модели есть всего два места, в которых значение настроечных параметров может
меняться. Во-первых, их значения могут быть изменены пользователем &ndash; это происходит в момент закрытия
окна настройки блока кнопкой &laquo;<span class="menu">OK</span>&raquo;. Во-вторых, значения параметров изменяются в момент
загрузки данных блока &ndash; это происходит при загрузке в память схемы с этим блоком, при отмене пользователем
сделанного им изменения в схеме, при <a href="um_2_5.htm" title="&sect;2.5. Добавление в схему стандартных блоков">вставке блока в схему</a> из
библиотеки или буфера обмена, и т.п. Нам нужно создавать динамическую переменную с новым именем вызовом
функции <span class="cpp">Create</span> в обоих этих случаях. Эта функция автоматически удаляет переменную,
которая была ранее создана этим же объектом, поэтому при изменении имени переменной в параметре нам не
придется заботиться об удалении переменной со старым именем перед созданием новой.</p>

<p><span id="ref9">Начнем</span>
с создания переменной при изменении пользователем ее имени в окне настроек блока. Если в модель добавлено
окно настроек, при его закрытии кнопкой &laquo;<span class="menu">OK</span>&raquo; вызывается реакция на событие
&laquo;вызов настройки&raquo;. Добавим в нашу модель эту реакцию: на левой панели окна редактора выберем
вкладку &laquo;<span class="menu"><a href="um_3_6_4.htm#pic1" title="Список фрагментов программы модели">события</a></span>&raquo;, раскроем на ней раздел
&laquo;<span class="menu">разное</span>&raquo; и дважды щелкнем на его подразделе
&laquo;<span class="menu">вызов настройки (<span id="light_ref9">RDS_BFM_SETUP</span>)</span>&raquo;. При этом значок
подраздела станет желтым, а в правой части окна появится новая пустая вкладка
&laquo;<span class="menu">настройка</span>&raquo;. Введем на ней следующий текст:</p>

<pre class="cpp">  DynVar.<a class="hidden" href="#light_ref1" title="Функция Create класса динамической переменной">Create</a>(RDS_DVPARENT,VarName.<a class="hidden" href="um_3_7_2_5.htm#light_ref2" title="Функция c_str класса rdsbcppString">c_str</a>(),TRUE);</pre>

<p>Здесь мы вызываем у объекта <span class="cpp">DynVar</span> функцию-член <span class="cpp">Create</span>,
передавая ей параметры <span class="cpp">RDS_DVPARENT</span> (создать переменную в родительской подсистеме
блока), <span class="cpp">VarName.c_str()</span> (строка с именем переменной из настроечного параметра
<span class="cpp">VarName</span>) и <span class="cpp">TRUE</span> (удалить созданную переменную сможет только этот блок).
Переменную мы создаем в родительской подсистеме блока-передатчика, чтобы к ней могли получить доступ блоки в
одной с ним подсистеме и в подсистемах, вложенных в нее. Следует обратить внимание на то, что во втором
параметре функции мы вызываем у параметра <span class="cpp">VarName</span> функцию-член
<span class="cpp"><a href="um_3_7_2_5.htm#light_ref2" title="Функция c_str класса rdsbcppString">c_str</a></span>: дело в том, что
<span class="cpp">VarName</span> имеет тип <span class="cpp">rdsbcppString</span> (это объект
специального класса для хранения строк), а функция <span class="cpp">Create</span> требует имени переменной типа
<span class="cpp">char*</span>. Функция <span class="cpp">c_str</span> возвращает указатель на строку
<span class="cpp">char*</span>, хранящуюся внутри объекта.</p>

<p>Теперь, если пользователь откроет окно настроек блока и закроет его кнопкой &laquo;<span class="menu">OK</span>&raquo;, мы стираем
ранее созданную блоком динамическую переменную, и создаем новую, с именем, взятым из параметра
<span class="cpp">VarName</span>. Все это делает вызов функции <span class="cpp">Create</span>.</p>

<p><span id="ref10">Добавим</span>
в нашу модель реакцию на загрузку параметров блока. На вкладке
&laquo;<span class="menu">события</span>&raquo; раскроем раздел &laquo;<span class="menu">загрузка и запись данных</span>&raquo; (важно не перепутать его с
похожим разделом &laquo;<span class="menu">загрузка и запись состояния</span>&raquo;) и дважды щелкнем на его подразделе
&laquo;<span class="menu">загрузка данных блока (<span id="light_ref10">RDS_BFM_LOADTXT</span>)</span>&raquo;.
Значок подраздела станет желтым, а в правой части окна появится новая вкладка
&laquo;<span class="menu">загрузка/текст</span>&raquo;, на которой нужно ввести точно такой же вызов функции
<span class="cpp">Create</span>, какой мы ввели на вкладке
&laquo;<span class="menu">настройка</span>&raquo; (можно скопировать его оттуда через буфер обмена). Теперь при загрузке данных блока,
когда сохраненное ранее значение параметра <span class="cpp">VarName</span> будет восстановлено в момент
загрузки отдельного блока или всей схемы, мы тоже создаем динамическую переменную с новым именем.</p>

<p><span id="ref11">Уничтожение</span>
созданных динамических переменных при уничтожении данных всего блока (например, при закрытии
RDS или перед загрузкой в память другой схемы) производится автоматически, но, чтобы проиллюстрировать
возможность программного удаления переменной, сделаем это вручную, в реакции на событие очистки данных блока.
На вкладке &laquo;<span class="menu">события</span>&raquo; раскроем раздел &laquo;<span class="menu">создание и уничтожение</span>&raquo; и дважды щелкнем на
его подразделе &laquo;<span class="menu">очистка блока (<span id="light_ref11">RDS_BFM_CLEANUP</span>)</span>&raquo;. Введем на
открывшейся вкладке следующий текст:</p>

<pre class="cpp">  DynVar.<a class="hidden" href="#light_ref5" title="Функция Delete класса динамической переменной">Delete</a>();</pre>

<p>Здесь мы просто удаляем ранее созданную переменную &ndash; у функции
<span class="cpp"><a href="#light_ref5" title="Функция Delete класса динамической переменной">Delete</a></span> нет параметров.</p>

<p><span id="ref12">Осталось</span>
<span id="ref13">изменить</span>
реакцию на
<a href="um_1_3.htm#ref4" title="Такт расчета">такт расчета</a>, в которой значение входа блока копируется в
динамическую переменную. Раскроем раздел &laquo;<span class="menu">моделирование и режимы</span>&raquo; вкладки
&laquo;<span class="menu">события</span>&raquo; и дважды щелкнем на его подразделе &laquo;<span class="menu">модель</span>&raquo;. На открывшейся
одноименной вкладке введем следующий текст:</p>

<pre class="cpp">  if(DynVar.<span id="light_ref12"><a class="hidden" href="um_3_7_3_1.htm#ref5" title="Проверка существования динамической переменной">Exists</a></span>())
    { DynVar=x;
      DynVar.<span id="light_ref13"><a class="hidden" href="um_3_7_3_2.htm#ref1" title="Функция NotifySubscribers класса динамической переменной">NotifySubscribers</a></span>();
    }</pre>

<p>В отличие от модели из <a href="um_3_7_7.htm" title="&sect;3.7.7. Задание пользователем имен динамических переменных">&sect;3.7.7</a>, здесь мы обязательно должны убедиться
в существовании динамической переменной, поскольку при создании объекта <span class="cpp">DynVar</span> мы
указали, что все действия с ним мы будем выполнять вручную. Если функция-член
<span class="cpp"><a href="um_3_7_3_1.htm#ref5" title="Проверка существования динамической переменной">Exists</a></span> этого объекта вернет <span class="cpp">TRUE</span>,
значит, переменная существует, и мы можем присвоить ей значение с входа блока <span class="cpp">x</span>
и уведомить об этом всех ее подписчиков вызовом
<span class="cpp"><a href="um_3_7_3_2.htm#ref1" title="Функция NotifySubscribers класса динамической переменной">NotifySubscribers</a></span>.</p>

<p>Модель передатчика готова &ndash; отредактируем теперь модель приемника. В ней нужно изменить параметры объекта
&laquo;<span class="rdsvar">DynVar</span>&raquo; точно так же, как они были изменены для передатчика: в выпадающем списке
&laquo;<span class="menu">действие</span>&raquo; следует выбрать вариант
&laquo;все действия &ndash; вручную&raquo;
(см. <a href="#pic1" title="Параметры объекта для динамической переменной без привязки к конкретной переменной">рис.&nbsp;434</a>).</p>

<p>Добавим в модель команды для получения доступа к переменной, имя которой содержится в параметре
<span class="cpp">VarName</span>. Как и в предыдущей модели, их нужно выполнять при изменении значения
настроечного параметра, то есть в реакциях на вызов окна настроек (вкладка
&laquo;<span class="menu">события</span>&raquo;, раздел &laquo;<span class="menu">разное</span>&raquo;, подраздел &laquo;<span class="menu">вызов настройки</span>&raquo;) и на
загрузку данных блока (раздел &laquo;<span class="menu">загрузка и запись данных</span>&raquo;, подраздел
&laquo;<span class="menu">загрузка данных блока</span>&raquo;). В обеих реакциях введем один и тот же текст:</p>

<pre class="cpp">  DynVar.<a class="hidden" href="#light_ref6" title="Функция Subscribe класса динамической переменной">Subscribe</a>(RDS_DVPARENT,VarName.<a class="hidden" href="um_3_7_2_5.htm#light_ref2" title="Функция c_str класса rdsbcppString">c_str</a>(),TRUE);</pre>

<p>У объекта <span class="cpp">DynVar</span> мы вызываем функцию-член
<span class="cpp"><a href="#light_ref6" title="Функция Subscribe класса динамической переменной">Subscribe</a></span>, передавая ей параметры
<span class="cpp">RDS_DVPARENT</span> (искать переменную в родительской подсистеме блока),
<span class="cpp">VarName.c_str()</span> (строка с именем переменной из настроечного параметра
<span class="cpp">VarName</span>) и <span class="cpp">TRUE</span> (если переменной не будет в
родительской подсистеме, искать ее далее вверх по иерархии). Эта функция автоматически разорвет старую
связь объекта <span class="cpp">DynVar</span> с переменной, если она была установлена ранее, и даст
ему доступ к переменной с новым именем.</p>

<p>При уничтожении данных всего блока разрыв связей с динамическими переменными, доступ к которым
он затребовал, производится автоматически, поэтому мы могли бы не предпринимать для этого никаких
дополнительных действий. Чтобы проиллюстрировать возможность программного разрыва связи с
переменной, все-таки сделаем это вручную в реакции на событие очистки данных блока
(раздел &laquo;<span class="menu">создание и уничтожение</span>&raquo;, подраздел
&laquo;<span class="menu">очистка блока</span>&raquo; на вкладке
&laquo;<span class="menu">события</span>&raquo;). Введем в эту реакцию такой текст:</p>

<pre class="cpp">  DynVar.<a class="hidden" href="#light_ref7" title="Функция Unsubscribe класса динамической переменной">Unsubscribe</a>();</pre>

<p>Функция <span class="cpp"><a href="#light_ref7" title="Функция Unsubscribe класса динамической переменной">Unsubscribe</a></span> без параметров
разрывает ранее созданную функцией <span class="cpp">Subscribe</span> связь с динамической переменной.</p>

<p>Теперь отредактируем в модели реакцию на изменение динамической переменной (раздел
&laquo;<span class="menu">моделирование и режимы</span>&raquo;, подраздел &laquo;<span class="menu">изменение динамической переменной</span>&raquo;), в
которой мы считываем число из этой переменной и выдаем его на выход. Новый текст реакции будет таким:</p>

<pre class="cpp">  if(DynVar.<a class="hidden" href="um_3_7_3_1.htm#ref5" title="Проверка существования динамической переменной">Exists</a>())
    { y=DynVar;
      Ready=1;
    }</pre>

<p>Прежде чем обращаться к динамической переменной через объект <span class="cpp">DynVar</span>, мы должны
проверить, существует ли эта переменная. Даже если в параметрах модели включен запрет ее вызова при
отсутствии динамических переменных, на объект <span class="cpp">DynVar</span> этот запрет не распространяется
&ndash; при создании объекта мы указали, что все действия с ним мы будем выполнять вручную. Поэтому сначала
мы вызываем его функцию-член <span class="cpp">Exists</span>. Только если она вернет
<span class="cpp">TRUE</span>, что будет означать существование переменной, мы скопируем ее значение в
выход блока <span class="cpp">y</span> и взведем сигнал готовности <span class="cpp">Ready</span> (в отличие
от реакции на такт расчета, в  реакции на изменение динамической переменной сигнал готовности не взводится
автоматически).</p>

<p>Измененные модели приемника и передатчика будут работать точно так же, как и модели, описанные в
<a href="um_3_7_7.htm" title="&sect;3.7.7. Задание пользователем имен динамических переменных">&sect;3.7.7</a>, пользователь не заметит между ними разницы. В данном случае
для решения поставленной задачи вызов функций
для программного управления переменными не требуется, они используются только для
демонстрации работы с ними.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_7_7.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_8.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_7a">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
