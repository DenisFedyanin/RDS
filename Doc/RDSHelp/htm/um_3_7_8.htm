<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.7.9. Всплывающие подсказки</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_7">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</a></p>
<div class="level"><p>&sect;3.7.9. Всплывающие подсказки</p>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_7_7a.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_9.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_8">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.7. Принципы создания автокомпилируемых моделей блоков</h3>
<h4>&sect;3.7.9. Всплывающие подсказки</h4>
<p class="abstract">Описывается создание всплывающих подсказок, сообщающих пользователю различную информацию о блоке и значения его основных параметров.</p>


<p>Если пользователь задержит курсор над изображением блока, модель этого блока может вывести 
всплывающую подсказку &ndash; окно с текстом, которое на некоторое время появится поверх 
изображения, и, через некоторое время, исчезнет. Всплывающие подсказки часто используются в 
Windows для вывода различных пояснений к кнопкам и полям ввода, когда такие пояснения заняли бы в самом окне 
слишком много места. В подсказках к блокам часто выводятся значения параметров этих блоков, сообщения об 
ошибках или комментарии. Модель может вывести подсказку ко всему блоку или к отдельному элементу его изображения, 
причем она может задать не только текст, который увидит пользователь, но и некоторые другие параметры подсказки,
например, время ее нахождения на экране, или координаты зоны окна, при выходе курсора из которой подсказка 
автоматически исчезнет. 
<span id="ref1">Для</span>
того, чтобы при задержке курсора над блоком подсказка появилась на экране, 
должны быть одновременно выполнены два условия: во-первых, в параметрах блока должен быть 
разрешен вывод всплывающих подсказок и, во-вторых, модель блока, среагировав на событие вывода подсказки 
(ему соответствует константа <span id="light_ref1"><span class="cpp"><a href="RDS_BFM_POPUPHINT.htm" title="А.2.6.12. RDS_BFM_POPUPHINT &ndash; вывод всплывающей подсказки">RDS_BFM_POPUPHINT</a></span></span>), 
должна передать текст подсказки в RDS функцией 
<span class="cpp"><a href="rdsSetHintText.htm" title="А.5.6.53. rdsSetHintText &ndash; текст всплывающей подсказки">rdsSetHintText</a></span>. Ниже будут рассмотрены два примера моделей, выводящих подсказки 
пользователю.</p>

<p>Начнем с простого примера, в котором подсказка выводится ко всему блоку целиком. В 
<a href="um_3_7_6.htm" title="&sect;3.7.6. Блоки с настраиваемыми пользователем параметрами">&sect;3.7.6</a> рассматривается модель блока, выдающего на выход 
&laquo;<span class="rdsvar">y</span>&raquo; произведение входа &laquo;<span class="rdsvar">x</span>&raquo; и настроечного параметра 
&laquo;<span class="rdsvar">K</span>&raquo;. Поскольку параметр &laquo;<span class="rdsvar">K</span>&raquo; скрыт внутри блока, пользователь может увидеть 
его, только вызвав окно настройки в режиме редактирования. Сделаем так, чтобы при задержке курсора над 
блоком значение &laquo;<span class="rdsvar">K</span>&raquo; выводилось во всплывающей подсказке &ndash; 
так пользователю будет удобнее работать.</p>

<p>Прежде всего, добавим в модель реакцию на событие вывода всплывающей подсказки. Для этого на 
левой панели окна редактора выберем вкладку 
вкладку &laquo;<span class="menu"><a href="um_3_6_4.htm#pic1" title="Список фрагментов программы модели">события</a></span>&raquo;, раскроем на ней раздел 
&laquo;<span class="menu">разное</span>&raquo; и дважды щелкнем на его подразделе 
&laquo;<span class="menu">всплывающая подсказка (RDS_BFM_POPUPHINT)</span>&raquo; 
(<a href="#pic1" title="Вывод подсказки в списке событий">рис.&nbsp;436</a>). 
При этом значок подраздела станет желтым, а в правой части окна появится новая пустая вкладка 
&laquo;<span class="menu">подсказка</span>&raquo;. Программа на этой вкладке должна сформировать текст подсказки и 
передать его в RDS.</p>

<p><span id="ref2">Введем</span>
<span id="ref3">на</span> 
вкладке &laquo;<span class="menu">подсказка</span>&raquo; следующий текст:</p>

<pre class="cpp">  char buf[100]; // Здесь будет формироваться текст
  // Вывод текста в массив buf
  <span id="light_ref2">sprintf</span>(buf,"K: %lf",K);
  // Передача сформированного текста в RDS
  <span id="light_ref3"><a class="hidden" href="rdsSetHintText.htm" title="А.5.6.53. rdsSetHintText &ndash; текст всплывающей подсказки">rdsSetHintText</a></span>(buf);</pre>

<div class="picright"><div class="container" id="pic1">
<img src="../img/AC_hint_event.png" width="443" height="276" alt="Вывод подсказки в списке событий" />
<p id="light_pic1">Рис.&nbsp;436. Вывод подсказки в списке событий</p>
</div></div>


<p>Здесь мы для создания текста со значением параметра используем 
<span class="cpp">sprintf</span> &ndash; стандартную библиотечную функцию языка C, выполняющую 
форматированный вывод в строку. Она записывает текст подсказки, в котором после буквы 
&laquo;K&raquo; и двоеточия выведено значение параметра <span class="cpp">K</span>, во вспомогательный массив 
<span class="cpp">buf</span> (его размера в сто символов хватит для выполняемого нами вывода текста). Затем 
вызывается функция <span class="cpp">rdsSetHintText</span>, которая передает содержимое массива 
<span class="cpp">buf</span> в RDS. Теперь, как только реакция модели на событие закончится, на экране возле 
курсора мыши должна будет появится подсказка с переданным нами текстом.</p>

<p><span id="ref4">Во</span> введенном фрагменте программы все написано верно, однако, если попытаться скомпилировать модель, 
будет выведено сообщение об ошибке с текстом, подобным 
&laquo;call to undefined function 'sprintf' in...&raquo; 
(&laquo;вызов неизвестной функции 'sprintf'...&raquo;, конкретный текст сообщения зависит от используемого 
компилятора). Дело в том, что функция <span class="cpp">sprintf</span>, которую мы используем, описана в 
файле заголовков &laquo;<span class="file"><span id="light_ref4">stdio.h</span></span>&raquo;, а этот файл не 
включается в программу модели по умолчанию. 
Мы уже сталкивались с этим в  
<a href="um_3_7_2_5.htm#ref5" title="Включение stdio.h в автокомпилируемую модель">примере из &sect;3.7.2.5</a>. Чтобы пользоваться функцией 
<span class="cpp">sprintf</span>, необходимо включить этот файл вручную. Для этого следует на вкладке 
&laquo;<span class="menu">события</span>&raquo; левой панели редактора 
раскрыть раздел &laquo;<span class="menu">описания</span>&raquo; (это самый первый раздел в списке) и дважды щелкнуть на его 
подразделе &laquo;<span class="menu">глобальные описания</span>&raquo;, после чего на открывшейся пустой вкладке 
&laquo;<span class="menu">описания</span>&raquo; в правой части окна ввести единственную строчку: 
&laquo;<span class="cpp">#include &lt;stdio.h&gt;</span>&raquo;. После этого ошибки при компиляции исчезнут.</p>

<p>Теперь в нашей модели есть реакция на вывод всплывающей подсказки, однако, если задержать курсор над 
блоком, никакой подсказки не появится. Необходимо разрешить блоку выводить подсказку &ndash; без этого созданная 
нами реакция не будет вызвана. Разрешить вывод подсказки можно двумя способами: через 
<a href="um_2_9_1.htm#ref2" title="окно параметров простого блока">окно параметров блока</a>
и через 
<a href="um_3_6_8.htm" title="&sect;3.6.8. Установка параметров блоков с автокомпилируемой моделью">окно групповой установки</a>. В нашем случае, поскольку у нас 
только один блок с такой моделью, первый вариант удобнее: нужно открыть окно параметров блока 
(пункт &laquo;<span class="menu">параметры</span>&raquo; в его контекстном меню), и на вкладке 
&laquo;<span class="menu">DLL</span>&raquo; включить флажок 
&laquo;<span class="menu">блок выводит всплывающую подсказку</span>&raquo; 
(<a href="#pic2" title="Разрешение всплывающей подсказки в окне параметров блока">рис.&nbsp;437</a>).</p>

<div class="pic"><div class="container" id="pic2">
<img src="../img/AC_hint_enable_single.png" width="534" height="409" alt="Разрешение всплывающей подсказки в окне параметров блока" />
<p id="light_pic2">Рис.&nbsp;437. Разрешение всплывающей подсказки в окне параметров блока</p>
</div></div>


<p>Если бы наша модель была подключена к нескольким блокам, разрешить вывод подсказки удобнее было бы 
для всех них одновременно через окно групповой установки. Для этого нужно было бы открыть редактор модели 
и выбрать пункт меню &laquo;<span class="menu">модель | установка параметров блоков</span>&raquo;. 
В открывшемся окне следовало бы выбрать вкладку &laquo;<span class="menu">DLL</span>&raquo;, включить на ней флажок 
&laquo;<span class="menu">всплывающая подсказка</span>&raquo; и выбрать в выпадающем списке справа от него вариант 
&laquo;<span class="menu">есть</span>&raquo; (<a href="#pic3" title="Разрешение всплывающей подсказки в окне групповой установки">рис.&nbsp;438</a>).</p>

<div class="pic"><div class="container" id="pic3">
<img src="../img/AC_hint_enable_group.png" width="638" height="444" alt="Разрешение всплывающей подсказки в окне групповой установки" />
<p id="light_pic3">Рис.&nbsp;438. Разрешение всплывающей подсказки в окне групповой установки</p>
</div></div>


<div class="picright"><div class="container" id="pic4">
<img src="../img/AC_hint_test1.png" width="201" height="65" alt="Всплывающая подсказка к блоку" />
<p id="light_pic4">Рис.&nbsp;439. Всплывающая<br />подсказка к блоку</p>
</div></div>


<p>Теперь вывод подсказки разрешен и, задержав курсор над изображением блока, можно увидеть значение множителя 
&laquo;<span class="rdsvar">K</span>&raquo;, введенного в настройках этого блока 
(<a href="#pic4" title="Всплывающая подсказка к блоку">рис.&nbsp;439</a>).</p>

<p>В нашей подсказке в функции <span class="cpp">sprintf</span> мы использовали формат 
&laquo;%lf&raquo;, поэтому в значении &laquo;<span class="rdsvar">K</span>&raquo; выведено слишком много незначащих нулей. 
Мы не можем знать заранее, в каком формате пользователь введет значение в настройках, поэтому не можем заложить в 
подсказку фиксированное число знаков в дробной части. Однако, мы можем воспользоваться функцией 
RDS <span class="cpp"><a href="rdsDtoA.htm" title="А.5.4.5. rdsDtoA &ndash; преобразование вещественного числа в строку">rdsDtoA</a></span>, которая способна сама отбросить незначащие нули 
&ndash; мы уже 
<a href="um_3_7_5.htm#ref20" title="Функция rdsDtoA">использовали ее в &sect;3.7.5</a>
в круглом индикаторе со шкалой.</p>

<p><span id="ref5">Изменим</span>
<span id="ref6">текст</span>
<span id="ref7">программы</span> на вкладке &laquo;<span class="menu">подсказка</span>&raquo; так, чтобы формат вывода &laquo;<span class="rdsvar">K</span>&raquo; подбирался 
автоматически. Старый текст мы полностью сотрем, и введем вместо него следующий:</p>

<pre class="cpp">  // Преобразование K в строку с подбором формата
  char *val=<span id="light_ref6"><a class="hidden" href="rdsDtoA.htm" title="А.5.4.5. rdsDtoA &ndash; преобразование вещественного числа в строку">rdsDtoA</a></span>(K,-1,NULL);
  // Сложение строк "K:" и значения K
  char *hint=<span id="light_ref5"><a class="hidden" href="rdsDynStrCat.htm" title="А.5.4.6. rdsDynStrCat &ndash; сложение двух строк">rdsDynStrCat</a></span>("K: ",val,FALSE);
  // Передача текста подсказки в RDS
  <a class="hidden" href="rdsSetHintText.htm" title="А.5.6.53. rdsSetHintText &ndash; текст всплывающей подсказки">rdsSetHintText</a>(hint);
  // Освобождение динамических строк
  <span id="light_ref7"><a class="hidden" href="rdsFree.htm" title="А.5.4.8. rdsFree &ndash; освобождение отведенной динамической памяти">rdsFree</a></span>(val);
  <a class="hidden" href="rdsFree.htm" title="А.5.4.8. rdsFree &ndash; освобождение отведенной динамической памяти">rdsFree</a>(hint);</pre>

<p>В первой строке этой программы мы присваиваем вспомогательной переменной <span class="cpp">val</span> результат возврата 
функции <span class="cpp">rdsDtoA</span>, в которую мы передаем вещественное число <span class="cpp">K</span> и 
значение &minus;1 в качестве числа знаков дробной части 
&ndash; отрицательное число во втором параметре заставит функцию автоматически подобрать для числа формат. 
<span class="cpp">NULL</span> в третьем параметре передается вместо указателя на целую переменную, куда 
<span class="cpp">rdsDtoA</span> могла бы записать длину сформированной строки. Сама строка, указатель на 
которую возвращается функцией, формируется в динамической памяти, и ее нужно будет потом обязательно освободить 
вызовом <span class="cpp"><a href="rdsFree.htm" title="А.5.4.8. rdsFree &ndash; освобождение отведенной динамической памяти">rdsFree</a></span>.</p>

<p>Во второй строке мы, при помощи функции RDS 
<span class="cpp"><a href="rdsDynStrCat.htm" title="А.5.4.6. rdsDynStrCat &ndash; сложение двух строк">rdsDynStrCat</a></span>, объединяем строку с буквой &laquo;K&raquo; и двоеточием со строкой 
значения параметра, которую ранее вернула <span class="cpp">rdsDtoA</span>, и присваиваем ее результат 
вспомогательной переменной <span class="cpp">hint</span> &ndash; это и будет текст нашей подсказки. 
Функция <span class="cpp">rdsDynStrCat</span> тоже формирует строку-результат в динамической памяти, 
поэтому эту строку тоже нужно будет освобождать при помощи <span class="cpp">rdsFree</span>. Помимо объединяемых 
строк в первом и втором параметрах, в третьем параметре <span class="cpp">rdsDynStrCat</span> передается 
логическое значение, разрешающее или запрещающее функции возвращать <span class="cpp">NULL</span> если обе 
объединяемые строки пусты. В нашем случае первая строка гарантированно не пуста, поэтому не важно, что 
передается в третьем параметре (мы передаем <span class="cpp">FALSE</span>).</p>

<p>Далее сформированный текст подсказки передается в RDS уже знакомым нам вызовом 
<span class="cpp">rdsSetHintText</span>, после чего обе динамических строки 
(<span class="cpp">hint</span> и <span class="cpp">val</span>) освобождаются вызовами 
<span class="cpp">rdsFree</span> &ndash; они нам больше не нужны.</p>

<div class="picright"><div class="container" id="pic5">
<img src="../img/AC_hint_test2.png" width="201" height="65" alt="Всплывающая подсказка к блоку &ndash; второй вариант" />
<p id="light_pic5">Рис.&nbsp;440. Всплывающая<br />подсказка к блоку &ndash;<br />второй вариант</p>
</div></div>


<p>Новая версия текста подсказки не содержит лишних нулей в дробной части числа 
(<a href="#pic5" title="Всплывающая подсказка к блоку &ndash; второй вариант">рис.&nbsp;440</a>). При этом, если пользователь введет 
дробное значение &laquo;<span class="rdsvar">K</span>&raquo;, в подсказке отобразится столько знаков после десятичной точки, 
сколько он ввел.</p>

<p><span id="ref8">В</span> 
<span id="ref9">рассмотренном</span>
примере выводилась одна и та же подсказка при попадании курсора мыши в любую точку 
прямоугольной области окна, занимаемой блоком. Если требуется выводить разные подсказки к 
разным элементам изображения одного и того же блока, необходимо, во-первых, определять, какой 
именно элемент находится под курсором, и, во-вторых, ограничить зону действия подсказки размером этого 
элемента, чтобы при выходе курсора из нее подсказка могла снова появится уже для другого элемента. 
Чтобы сделать это возможным, в параметре <span class="cpp" id="light_ref8">HintData</span> функции реакции на 
всплывающую подсказку передается указатель на структуру 
<span id="light_ref9"><span class="cpp"><a href="RDS_BFM_POPUPHINT.htm#ref3" title="Структура RDS_POPUPHINTDATA">RDS_POPUPHINTDATA</a></span></span>, при помощи которой модель считывает 
и устанавливает параметры подсказки. Многие из ее полей по смыслу совпадают 
с полями структуры <span class="cpp"><a href="RDS_BFM_DRAW.htm#ref1" title="Структура RDS_DRAWDATA">RDS_DRAWDATA</a></span>, используемой при 
<a href="um_3_7_5.htm#ref3" title="Структура RDS_DRAWDATA">рисовании</a>. Кратко перечислим поля структуры и их назначение:</p>

<dl>
  <dt><span class="cpp">x</span>,&nbsp;<span class="cpp">y</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Координаты курсора мыши на рабочем поле окна подсистемы на момент вывода подсказки (уже 
  с учетом масштаба подсистемы).</dd>
  
  <dt><span class="cpp">BlockX</span>,&nbsp;<span class="cpp">BlockY</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Координаты точки привязки блока на рабочем поле с учетом масштаба и возможной связи положения этого блока с 
  переменными. Для блоков с <a href="um_1_2.htm#light_ref22">векторной картинкой</a>
  точка привязки &ndash; это положение начала координат этой картинки, для всех остальных 
  &ndash; левый верхний угол прямоугольной области.</dd>
  
  <dt><span class="cpp">Left</span>,&nbsp;<span class="cpp">Top</span>,&nbsp;<span class="cpp">Width</span>,&nbsp;<span class="cpp">Height</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Координаты левого верхнего угла (<span class="cpp">Left</span>, <span class="cpp">Top</span>) прямоугольной 
  области, занимаемой блоком, ее ширина (<span class="cpp">Width</span>) и высота (<span class="cpp">Height</span>) в 
  текущем масштабе с учетом возможной связи положения блока с его переменными. Соответствуют одноименным 
  полям структуры <span class="cpp">RDS_PDRAWDATA</span>.</dd>
  
  <dt><span class="cpp">HZLeft</span>,&nbsp;<span class="cpp">HZTop</span>,&nbsp;<span class="cpp">HZWidth</span>,&nbsp;<span class="cpp">HZHeight</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Возвращаемая моделью зона действия подсказки: горизонтальная (<span class="cpp">HZLeft</span>) и вертикальная 
  (<span class="cpp">HZTop</span>) координаты верхнего левого угла зоны, ее ширина (<span class="cpp">HZWidth</span>) 
  и высота (<span class="cpp">HZHeight</span>). При выходе курсора мыши за пределы этой прямоугольной зоны будет 
  запрошен повторный вывод подсказки. По умолчанию в этих полях записаны координаты и размер всей прямоугольной 
  области блока, то есть они совпадают с полями <span class="cpp">Left</span>, <span class="cpp">Top</span>, 
  <span class="cpp">Width</span> и <span class="cpp">Height</span> соответственно, поэтому подсказка 
  для любой точки его изображения будет одной и той же. Модель может записать в эти поля другие значения, 
  чтобы при выходе курсора из указанной зоны можно было вывести другую подсказку.</dd>
  
  <dt><span class="cpp">ReshowTimeout</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Возвращаемое моделью время в миллисекундах после гашения подсказки, по истечении которого подсказку 
  необходимо вывести снова. По умолчанию в этом поле записан ноль &ndash; подсказка не будет выведена 
  повторно до тех пор, пока курсор мыши не покинет зону ее действия.</dd>
  
  <dt><span class="cpp">HideTimeout</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Возвращаемое моделью время в миллисекундах после вывода подсказки, по истечении которого ее 
  необходимо убрать с экрана. По умолчанию в этом поле записано стандартное для Windows значение.</dd>
  
  <dt><span class="cpp">IntZoom</span>&emsp;(<span class="cpp"><i>int</i></span>)</dt>
  <dd>Текущий масштаб окна <a href="um_1_2.htm#ref13" title="Родительская подсистема">родительской подсистемы</a>
  блока в процентах (используется крайне редко).</dd>
  
  <dt><span class="cpp">DoubleZoom</span>&emsp;(<span class="cpp"><i>double</i></span>)</dt>
  <dd>Текущий масштаб окна родительской подсистемы блока в долях единицы: 1 &ndash; 100%, 0.5 &ndash; 50%, 
  2 &ndash; 200% и т.п. Соответствует одноименному полю структуры <span class="cpp">RDS_PDRAWDATA</span>.</dd>
  
</dl>

<p class="noindent">Помимо указателя 
<span class="cpp">HintData</span>, в функцию реакции на вывод подсказки передается также ссылка на целую 
переменную <span class="cpp">Show</span>, присвоение ей константы 
<span class="cpp">RDS_BFR_NOTPROCESSED</span> отменит вывод подсказки. Обычно эта переменная в модели 
никак не используется, поскольку для того, чтобы отменить вывод подсказки, достаточно просто ничего 
не передавать в RDS функцией <span class="cpp">rdsSetHintText</span>.</p>

<p>Рассмотрим пример модели, которая будет выводить разные подсказки к разным частям изображения своего блока. 
Создадим блок, на входе которого будет матрица вещественных чисел с произвольным количеством строк и 
двумя столбцами. Каждая строка этой матрицы содержит пару координат точки на плоскости (горизонтальная 
координата в нулевом столбце и вертикальная в первом), и блок будет рисовать эти точки на своем изображении 
в виде небольших окружностей, соединяя эти окружности линиями в порядке следования строк матрицы 
(<a href="#pic6" title="Предполагаемый внешний вид блока и его связь с входной матрицей">рис.&nbsp;441</a>). 
При наведении курсора мыши на любую из этих точек во всплывающей подсказке должны отображаться номер 
точки и ее координаты.</p>

<div class="pic"><div class="container" id="pic6">
<img src="../img/AC_matrpoints.png" width="575" height="311" alt="Предполагаемый внешний вид блока и его связь с входной матрицей" />
<p id="light_pic6">Рис.&nbsp;441. Предполагаемый внешний вид блока и его связь с входной матрицей</p>
</div></div>


<p>Чтобы не усложнять пример, мы не будем закладывать в этот блок настройку отображаемого диапазона 
координат, цветов и размера окружности точек. Окружности будем рисовать радиусом в три точки для масштаба 
100% (как всегда, увеличивая и уменьшая этот радиус вместе с масштабом), а диапазон определим по максимальным и 
минимальным значениям координат в матрице. Диапазону горизонтальных вещественных координат (то есть минимуму 
и максимуму значений в нулевом столбце матрицы) будет соответствовать вся ширина блока за вычетом двух радиусов 
окружности точки (иначе окружности крайних точек выйдут за пределы изображения блока), а диапазону вертикальных 
(минимуму и максимуму значений в первом столбце матрицы) &ndash; вся высота блока за вычетом тех же 
двух радиусов. На <a href="#pic6" title="Предполагаемый внешний вид блока и его связь с входной матрицей">рис.&nbsp;441</a> отображаемый диапазон изображен 
пунктирной линией внутри блока, на настоящем блоке эта линия рисоваться не будет.</p>

<p>У нашего блока, помимо двух обязательных сигналов, будет единственный вход: матрица вещественных чисел 
&laquo;<span class="rdsvar">A</span>&raquo;. 
<a href="um_3_7_2_1.htm#light_ref6" title="Создание нового блока с моделью">Создадим</a> в схеме новый блок, 
запускающийся <a href="um_3_7_2_1.htm#pic2" title="Установка запуска по сигналу в окне параметров блока">по сигналу</a>, и зададим 
ему следующую структуру статических переменных:</p>

<div class="tablecenter"><div class="tcont">
<table>
  <tr>
    <th>Имя</th>
    <th>Тип</th>
    <th>Вход/выход</th>
    <th>Пуск</th>
    <th>Начальное значение</th>
  </tr>

  <tr><td class="vcenter">Start</td>
<td class="center">Сигнал</td>
<td class="center">Вход</td>
<td class="center">&checkmark;</td>
<td class="center">1</td>
</tr>
<tr><td class="vcenter">Ready</td>
<td class="center">Сигнал</td>
<td class="center">Выход</td>
<td></td>
<td class="center">0</td>
</tr>
<tr><td class="vcenter">A</td>
<td class="center">Матрица double</td>
<td class="center">Вход</td>
<td class="center">&checkmark;</td>
<td class="center">[&nbsp;]&nbsp;0</td>
</tr>


</table>
</div></div>

<p>В модели этого блока будет две реакции: реакция на рисование блока, в которой мы будем рисовать точки 
и линии между ними, и реакция на всплывающую подсказку, в которой мы будем проверять попадание курсора 
мыши в одну из точек и выводить ее координаты. Очевидно, в этих реакциях будет много общего: 
в обеих нужно вычислять координаты точек, для чего нужно будет определять границы отображаемого 
диапазона, то есть минимальные и максимальные значения координат в матрице. Чтобы не писать в этих 
реакциях одни и те же вычисления два раза, мы введем в нашу модель дополнительную функцию расчета вспомогательных 
параметров, которая будет вызываться из обеих реакций. Эту функцию необходимо сделать членом класса блока, 
поскольку ей необходим доступ к переменной блока &laquo;<span class="rdsvar">A</span>&raquo;. Параметры, которые она вычислит, 
тоже сделаем полями класса &ndash; так к ним проще будет обращаться из реакций. Таким образом, и функцию, 
и все вспомогательные параметры мы будем вводить на вкладке описаний внутри класса. Откроем ее: на 
левой панели окна редактора выберем вкладку 
&laquo;<span class="menu"><a href="um_3_6_4.htm#pic1" title="Список фрагментов программы модели">события</a></span>&raquo;, раскроем на ней раздел 
&laquo;<span class="menu">описания</span>&raquo; и дважды щелкнем на его подразделе 
&laquo;<span class="menu">описания внутри класса блока</span>&raquo; 
(<a href="#pic7" title="Описания внутри класса в списке событий">рис.&nbsp;442</a>). </p>

<div class="pic"><div class="container" id="pic7">
<img src="../img/AC_def_in_class.png" width="319" height="276" alt="Описания внутри класса в списке событий" />
<p id="light_pic7">Рис.&nbsp;442. Описания внутри класса в списке событий</p>
</div></div>


<p>При этом значок подраздела станет желтым, а в правой части окна появится новая пустая вкладка 
&laquo;<span class="menu">описания в классе</span>&raquo;. Введем на ней следующий текст:</p>

<pre class="cpp">
  // Вспомогательные параметры, используемые и при рисовании,
  // и при выводе подсказки

  // Радиус круга точки с учетом масштаба
  int point_r; 
  // Границы области рисования внутри блока
  int draw_x1,draw_y1,draw_x2,draw_y2;
  // Диапазон координат в матрице
  double xmin,xmax,ymin,ymax;

  // Функция вычисления перечисленных выше параметров
  void CalcParams(int left,int top,	// левый верхний угол блока
                  int width,int height,	// ширина и высота
                  double zoom) 		// масштаб
  {
    // Радиус круга точки
    point_r=zoom*3; // 3 точки с учетом масштаба

    // Зона рисования внутри блока (на радиус круга внутрь от рамки)
    draw_x1=left+point_r+1;
    draw_y1=top+point_r+1;
    draw_x2=left+width-point_r-1;
    draw_y2=top+height-point_r-1;

    // Определение минимума и максимума координат в матрице
    xmin=xmax=A[0][0];
    ymin=ymax=A[0][1];
    for(int i=1;i&lt;A.Rows();i++)
      { if(xmin&gt;A[i][0]) xmin=A[i][0];
        if(xmax&lt;A[i][0]) xmax=A[i][0];
        if(ymin&gt;A[i][1]) ymin=A[i][1];
        if(ymax&lt;A[i][1]) ymax=A[i][1];
      }
    if(xmin==xmax) // Нет горизонтального диапазона
      { // Принудительно создаем его
        xmin-=1; xmax+=1;
      }
    if(ymin==ymax) // Нет вертикального диапазона
      { // Принудительно создаем его
        ymin-=1; ymax+=1;
      }
  }</pre>

<p>В начале этого текста описываются добавляемые нами поля класса для вспомогательных параметров 
(эти описания станут именно полями класса, а не глобальными переменными, поскольку весь введенный нами текст 
будет вставлен внутрь описания класса блока). В целом поле <span class="cpp">point_r</span> будет 
вычисляться радиус окружности точки с учетом текущего масштаба подсистемы. В целых полях 
<span class="cpp">draw_x1</span> и <span class="cpp">draw_y1</span> будут вычисляться координаты 
левого верхнего, а в <span class="cpp">draw_x2</span> и <span class="cpp">draw_y2</span> &ndash; правого 
нижнего углов области рисования внутри прямоугольника блока (то есть пунктирной области 
на <a href="#pic6" title="Предполагаемый внешний вид блока и его связь с входной матрицей">рис.&nbsp;441</a>). 
Вещественные поля <span class="cpp">xmin</span>, <span class="cpp">xmax</span>, 
<span class="cpp">ymin</span> и <span class="cpp">ymax</span> будут содержать минимальные и максимальные 
значения координат из поступившей на вход блока матрицы.</p>

<p>Сразу за описаниями полей записана функция <span class="cpp">CalcParams</span>, которая будет вычислять 
значения этих полей. В функцию передаются координаты левого верхнего угла (<span class="cpp">left</span>, 
<span class="cpp">top</span>) и размеры (<span class="cpp">width</span>, <span class="cpp">height</span>) 
прямоугольной области блока, а также масштабный коэффициент подсистемы <span class="cpp">zoom</span>: в 
зависимости от того, из какой именно реакции будет вызываться эта функция, эти значения будут браться либо 
из структуры <span class="cpp"><a href="RDS_BFM_DRAW.htm#ref1" title="Структура RDS_DRAWDATA">RDS_DRAWDATA</a></span> (при рисовании), либо из структуры 
<span class="cpp"><a href="RDS_BFM_POPUPHINT.htm#ref3" title="Структура RDS_POPUPHINTDATA">RDS_POPUPHINTDATA</a></span> (при выводе подсказки).</p>

<p>Внутри функции мы сначала вычисляем действительный размер окружности точки <span class="cpp">point_r</span>, 
умножая 3 (радиус окружности в масштабе 100% мы решили сделать равным трем точкам экрана) на масштабный 
коэффициент <span class="cpp">zoom</span>. Затем вычисляются размеры области рисования точек внутри блока: 
из общих размеров блока, переданных в параметрах функции, со всех сторон вычитается по радиусу 
<span class="cpp">point_r</span> с дополнительным запасом в одну точку. После этого, в цикле перебирая 
все точки матрицы на входе блока <span class="cpp">A</span>, мы вычисляем диапазоны содержащихся в ней 
координат <span class="cpp">xmin</span>, <span class="cpp">xmax</span>, <span class="cpp">ymin</span> и 
<span class="cpp">ymax</span>. Горизонтальные координаты содержатся в нулевом столбце матрицы, то есть в 
<span class="cpp">A[</span>&hellip;<span class="cpp">][0]</span>, а вертикальные &ndash; в первом столбце, то есть в 
<span class="cpp">A[</span>&hellip;<span class="cpp">][1]</span>. Проверка наличия в матрице двух столбцов и, по крайней мере, 
одной строки будет выполняться внутри реакций на события до вызова функции 
<span class="cpp">CalcParams</span>, поэтому в самой функции нет никаких проверок &ndash; мы просто 
обращаемся к нулевому и первому столбцу, считая, что они в матрице есть.</p>

<p>После того, как диапазоны координат точек в матрице определены, нужно проверить, не совпадают ли минимальное и 
максимальное значения по каждой из координат. Для преобразования вещественных координат точки в ее 
целые координаты на экране нам придется делить значение координаты на размер соответствующего ей диапазона, 
и, если этот размер будет нулевым, мы не сможем выполнить преобразование. Например, чтобы вычислить 
горизонтальную координату точки на экране, нужно разделить ее вещественную координату на 
(<span class="cpp">xmax-xmin</span>) и умножить результат на (<span class="cpp">draw_x2-draw_x1</span>), а 
затем добавить координату левой границы блока &ndash; это обычное линейное преобразование диапазонов. При этом, 
очевидно, значение <span class="cpp">xmax</span> не должно быть равным <span class="cpp">xmin</span>.</p>

<p>Выйти из этого затруднения очень просто: поскольку мы не рисуем на блоке никаких шкал или координатных сеток, 
при совпадении максимального и минимального значений какой-либо координаты (то есть если данная координата совпадает 
у всех точек матрицы &ndash; они расположены на строго горизонтальной или вертикальной линии) можно принудительно 
расширить этот диапазон, добавив какую-либо константу к максимальному значению и вычтя ее же из минимального. 
При этом все точки матрицы окажутся в середине этого диапазона и будут нарисованы в середине изображения блока. 
Константу можно взять любой &ndash; мы будем добавлять и вычитать единицу. Два оператора 
<span class="cpp">if</span>, расположенных после цикла перебора точек матрицы, выполняют именно эту функцию. 
Таким образом, на момент завершения функции <span class="cpp">CalcParams</span>, диапазоны 
<span class="cpp">xmin</span>&hellip;<span class="cpp">xmax</span> и 
<span class="cpp">ymin</span>&hellip;<span class="cpp">ymax</span> гарантированно не будут иметь 
нулевой размер.</p>

<p>Теперь введем в нашу модель реакцию на событие рисования блока. На вкладке 
&laquo;<span class="menu">события</span>&raquo; левой панели окна редактора раскроем раздел 
&laquo;<span class="menu">внешний вид блока</span>&raquo; и дважды щелкнем на подразделе 
&laquo;<span class="menu">рисование блока (RDS_BFM_DRAW)</span>&raquo; 
(см. <a href="um_3_7_5.htm#pic2" title="Реакция на рисование блока в списке событий">рис.&nbsp;412</a>) &ndash; в правой части окна появится новая 
пустая вкладка &laquo;<span class="menu">рисование</span>&raquo;. Запишем не ней следующую программу:</p>

<pre class="cpp">  // Вспомогательные переменные
  int right,bottom,ix,iy;

  // Правый нижний угол области блока
  right=DrawData-&gt;Left+DrawData-&gt;Width;
  bottom=DrawData-&gt;Top+DrawData-&gt;Height;

  // Черная линия
  <a class="hidden" href="rdsXGSetPenStyle.htm" title="А.5.18.25. rdsXGSetPenStyle &ndash; установить стиль линии">rdsXGSetPenStyle</a>(0,PS_SOLID,DrawData-&gt;DoubleZoom,0,R2_COPYPEN);
  // Белый фон
  <a class="hidden" href="rdsXGSetBrushStyle.htm" title="А.5.18.20. rdsXGSetBrushStyle &ndash; установить стиль заливки">rdsXGSetBrushStyle</a>(0,RDS_GFS_SOLID,0xffffff); 
  // Прямоугольник - черная рамка и белый фон
  <a class="hidden" href="rdsXGRectangle.htm" title="А.5.18.18. rdsXGRectangle &ndash; прямоугольник">rdsXGRectangle</a>(DrawData-&gt;Left,DrawData-&gt;Top,right,bottom);

  // Отключаем заливку
  <a class="hidden" href="rdsXGSetBrushStyle.htm" title="А.5.18.20. rdsXGSetBrushStyle &ndash; установить стиль заливки">rdsXGSetBrushStyle</a>(RDS_GFSTYLE,RDS_GFS_EMPTY,0); 

  if(A.<a class="hidden" href="um_3_7_2_2.htm#light_ref4" title="Функция Cols класса матрицы">Cols</a>()&lt;2 || A.<a class="hidden" href="um_3_7_2_2.htm#light_ref5" title="Функция Rows класса матрицы">Rows</a>()&lt;1 ) // Меньше двух столбцов или нет строк
    return;

  // Вычисляем вспомогательные параметры
  CalcParams(DrawData-&gt;Left,DrawData-&gt;Top,
             DrawData-&gt;Width,DrawData-&gt;Height,
             DrawData-&gt;DoubleZoom);

  // Рисуем точки и линии
  for(int i=0;i&lt;A.<a class="hidden" href="um_3_7_2_2.htm#light_ref5" title="Функция Rows класса матрицы">Rows</a>();i++)
    { // Вычисляем оконные координаты точки i
      ix=draw_x1+(A[i][0]-xmin)*(draw_x2-draw_x1)/(xmax-xmin);
      iy=draw_y2-(A[i][1]-ymin)*(draw_y2-draw_y1)/(ymax-ymin);
      // Рисуем окружность радиусом point_r
      <a class="hidden" href="rdsXGEllipse.htm" title="А.5.18.6. rdsXGEllipse &ndash; эллипс или окружность">rdsXGEllipse</a>(ix-point_r,iy-point_r,ix+point_r,iy+point_r);
      // Соединяем линией с предыдущей точкой
      if(i) <a class="hidden" href="rdsXGLineTo.htm" title="А.5.18.13. rdsXGLineTo &ndash; отрезок прямой">rdsXGLineTo</a>(ix,iy);
      else <a class="hidden" href="rdsXGMoveTo.htm" title="А.5.18.14. rdsXGMoveTo &ndash; установить текущую точку рисования">rdsXGMoveTo</a>(ix,iy);
    }</pre>

<p>В этой программе, как и в моделях из <a href="um_3_7_5.htm" title="&sect;3.7.5. Блоки, программно рисующие свое изображение">&sect;3.7.5</a>,
для рисования используются 
<a href="app_index.htm#light_htm:app_a_5_18" title="А.5.18. Графические функции">графические функции RDS</a>. 
В ее начале описано несколько вспомогательных переменных, затем располагаются команды установки 
стиля линии, заливки и рисования прямоугольника размером во весь блок. После их выполнения блок будет выглядеть 
как белый прямоугольник с черной рамкой, поверх этого прямоугольника мы и будем рисовать точки из матрицы.</p>

<p>Прежде чем приступать к рисованию точек, необходимо проверить, соответствует ли матрица нашим ожиданиям. 
Чтобы она описывала хотя бы одну точку, в ней должна быть по крайней мере одна строка и два столбца. Если 
число столбцов в матрице <span class="cpp">A</span> 
(<span class="cpp">A.<a href="um_3_7_2_2.htm#light_ref4" title="Функция Cols класса матрицы">Cols</a>()</span>, 
см. <a href="um_3_7_2_2.htm" title="&sect;3.7.2.2. Модели с матрицами">&sect;3.7.2.2</a>) меньше двух, или число строк 
(<span class="cpp">A.<a href="um_3_7_2_2.htm#light_ref5" title="Функция Rows класса матрицы">Rows</a>()</span>) меньше одной, мы немедленно завершаем 
реакцию &ndash; с такой матрицей ничего нельзя нарисовать. В противном случае мы вызываем написанную ранее 
функцию расчета вспомогательных параметров <span class="cpp">CalcParams</span>, передавая ей координаты блока, 
его размеры и масштаб подсистемы, взятые из структуры <span class="cpp">RDS_DRAWDATA</span> по указателю 
<span class="cpp">DrawData</span>.</p>

<p>Теперь мы можем пользоваться полями класса, которые заполнила функция <span class="cpp">CalcParams</span>. 
В цикле по всем точкам матрицы для каждой точки <span class="cpp">i</span> мы вычисляем экранные координаты 
(<span class="cpp">ix</span>,<span class="cpp">iy</span>) по ее вещественным координатам 
(<span class="cpp">A[i][0]</span>,<span class="cpp">A[i][1]</span>), рисуем круг радиусом 
<span class="cpp">point_r</span> с центром в точке (<span class="cpp">ix</span>,<span class="cpp">iy</span>), и, 
если это не самая первая точка матрицы (то есть если <span class="cpp">i</span> не равно нулю), соединяем эту 
точку с предыдущей вызовом <span class="cpp"><a href="rdsXGLineTo.htm" title="А.5.18.13. rdsXGLineTo &ndash; отрезок прямой">rdsXGLineTo</a></span>. Для самой первой точки вместо 
<span class="cpp">rdsXGLineTo</span> вызывается функция <span class="cpp"><a href="rdsXGMoveTo.htm" title="А.5.18.14. rdsXGMoveTo &ndash; установить текущую точку рисования">rdsXGMoveTo</a></span>, которая просто 
устанавливает координаты точки для последующих вызовов <span class="cpp">rdsXGLineTo</span>.</p>

<p>Программа рисования написана &ndash; теперь введем в модель реакцию на вывод подсказки. Для этого 
раскроем на вкладке &laquo;<span class="menu">события</span>&raquo; раздел 
&laquo;<span class="menu">разное</span>&raquo; и дважды щелкнем на подразделе 
&laquo;<span class="menu">всплывающая подсказка (RDS_BFM_POPUPHINT)</span>&raquo; 
(см. <a href="#pic1" title="Вывод подсказки в списке событий">рис.&nbsp;436</a>). 
В правой части окна появится пустая вкладка &laquo;<span class="menu">подсказка</span>&raquo;, на которой мы введем следующий текст:</p>

<pre class="cpp">  // Индекс найденной точки
  int index=-1;
  // Экранные координаты найденной точки
  int ix,iy;

  if(A.<a class="hidden" href="um_3_7_2_2.htm#light_ref4" title="Функция Cols класса матрицы">Cols</a>()&lt;2 || A.<a class="hidden" href="um_3_7_2_2.htm#light_ref5" title="Функция Rows класса матрицы">Rows</a>()&lt;1) // Меньше двух столбцов или нет строк
    return;

  // Вычисляем вспомогательные параметры
  CalcParams(HintData-&gt;Left,HintData-&gt;Top,
             HintData-&gt;Width,HintData-&gt;Height,
             HintData-&gt;DoubleZoom);

  // Ищем попадание в круг точки
  for(int i=0;i&lt;A.<a class="hidden" href="um_3_7_2_2.htm#light_ref5" title="Функция Rows класса матрицы">Rows</a>();i++)
    { // Вычисляем оконные координаты точки i
      ix=draw_x1+(A[i][0]-xmin)*(draw_x2-draw_x1)/(xmax-xmin);
      iy=draw_y2-(A[i][1]-ymin)*(draw_y2-draw_y1)/(ymax-ymin);
      if(fabs(HintData-&gt;x-ix)&lt;=point_r &amp;&amp; 
         fabs(HintData-&gt;y-iy)&lt;=point_r) // Попали
        { index=i;
          break;
        }
    }

  if(index&gt;=0) // Нашли точку
    { char *hint,*val_x,*val_y,*val_n;
      // Левый верхний угол зоны подсказки
      HintData-&gt;HZLeft=ix-point_r;
      HintData-&gt;HZTop=iy-point_r;
      // Размеры зоны подсказки
      HintData-&gt;HZWidth=HintData-&gt;HZHeight=point_r*2;
      // Задержка гашения подсказки – одна минута
      HintData-&gt;HideTimeout=60000;
      <span id="ref10">//</span> <span id="ref11"></span> текста подсказки
      val_n=<span id="light_ref10"><a href="rdsItoA.htm" title="А.5.4.11. rdsItoA &ndash; преобразование целого числа в строку">rdsItoA</a></span>(index,10,0);           // номер точки
      val_x=<a class="hidden" href="rdsDtoA.htm" title="А.5.4.5. rdsDtoA &ndash; преобразование вещественного числа в строку">rdsDtoA</a>(A[index][0],-1,FALSE); // x
      val_y=<a class="hidden" href="rdsDtoA.htm" title="А.5.4.5. rdsDtoA &ndash; преобразование вещественного числа в строку">rdsDtoA</a>(A[index][1],-1,FALSE); // y
      hint=<span class="cpp"><a class="hidden" href="rdsDynStrCat.htm" title="А.5.4.6. rdsDynStrCat &ndash; сложение двух строк">rdsDynStrCat</a></span>("Точка: ",val_n,FALSE);
      <span id="light_ref11"><a class="hidden" href="rdsAddToDynStr.htm" title="А.5.4.1. rdsAddToDynStr &ndash; добавление строки к динамически отведенной строке">rdsAddToDynStr</a></span>(&amp;hint,"\nX: ",FALSE);
      <a class="hidden" href="rdsAddToDynStr.htm" title="А.5.4.1. rdsAddToDynStr &ndash; добавление строки к динамически отведенной строке">rdsAddToDynStr</a>(&amp;hint,val_x,FALSE);
      <a class="hidden" href="rdsAddToDynStr.htm" title="А.5.4.1. rdsAddToDynStr &ndash; добавление строки к динамически отведенной строке">rdsAddToDynStr</a>(&amp;hint,"\nY: ",FALSE);
      <a class="hidden" href="rdsAddToDynStr.htm" title="А.5.4.1. rdsAddToDynStr &ndash; добавление строки к динамически отведенной строке">rdsAddToDynStr</a>(&amp;hint,val_y,FALSE);
      // Передача текста в RDS
      <a class="hidden" href="rdsSetHintText.htm" title="А.5.6.53. rdsSetHintText &ndash; текст всплывающей подсказки">rdsSetHintText</a>(hint);
      // Освобождение динамических строк
      <a class="hidden" href="rdsFree.htm" title="А.5.4.8. rdsFree &ndash; освобождение отведенной динамической памяти">rdsFree</a>(hint);
      <a class="hidden" href="rdsFree.htm" title="А.5.4.8. rdsFree &ndash; освобождение отведенной динамической памяти">rdsFree</a>(val_x);
      <a class="hidden" href="rdsFree.htm" title="А.5.4.8. rdsFree &ndash; освобождение отведенной динамической памяти">rdsFree</a>(val_y);
      <a class="hidden" href="rdsFree.htm" title="А.5.4.8. rdsFree &ndash; освобождение отведенной динамической памяти">rdsFree</a>(val_n);
    }</pre>

<p>В начале этого текста описаны вспомогательные целые переменные <span class="cpp">index</span>, 
<span class="cpp">ix</span> и <span class="cpp">iy</span> &ndash; в них будут занесены номер точки 
(строки матрицы) под курсором мыши и ее координаты в окне подсистемы соответственно. Переменная 
<span class="cpp">index</span> инициализирована значением &minus;1: если в процессе перебора точек матрицы 
ни одна из них не окажется близко к курсору мыши, значение <span class="cpp">index</span> останется отрицательным, 
и это будет признаком того, что курсор не над точкой матрицы и подсказку выводить не нужно.</p>

<p>Далее мы, как и при рисовании, проверяем размер матрицы на входе блока: если в ней нет хотя бы двух 
столбцов и одной строки, мы немедленно завершаем реакцию. Если же числа строк и столбцов достаточно для 
хранения данных об одной точке, мы вычисляем вспомогательные параметры вызовом <span class="cpp">CalcParams</span>. 
В нее мы передаем координаты блока, его размеры и масштаб подсистемы, на этот раз взятые из структуры 
<span class="cpp">RDS_POPUPHINTDATA</span> по указателю <span class="cpp">HintData</span>.</p>

<p>Теперь, когда диапазоны координат матрицы и границы области рисования внутри блока вычислены, мы 
можем проверить, попал ли курсор мыши в одну из точек матрицы <span class="cpp">A</span>. Для этого мы 
перебираем все ее точки и вычисляем для каждой экранные координаты (<span class="cpp">ix</span>,<span class="cpp">iy</span>) 
по вещественным координатам (<span class="cpp">A[i][0]</span>,<span class="cpp">A[i][1]</span>) при помощи тех 
же самых формул, которые использовались в программе рисования. Если расстояния между координатами курсора 
мыши (<span class="cpp">HintData-&gt;x</span>,<span class="cpp">HintData-&gt;y</span>) и точкой матрицы 
(<span class="cpp">ix</span>,<span class="cpp">iy</span>) и по горизонтали, и по вертикали не больше радиуса 
круга точки <span class="cpp">point_r</span>, значит, курсор попал внутрь этого круга (точнее, внутрь квадрата, 
в который вписан этот круг, но для проверки это не принципиально). В этом случае мы присваиваем переменной 
<span class="cpp">index</span>
номер найденной точки и прерываем цикл перебора точек оператором <span class="cpp">break</span>. В переменных 
<span class="cpp">ix</span> и <span class="cpp">iy</span> при этом останутся координаты этой точки на экране.</p>

<p>После выполнения цикла перебора в переменной <span class="cpp">index</span> останется начальное значение 
&minus;1, если курсор мыши не оказался в пределах круга ни одной из точек. Если же курсор попал в один из 
кругов, значение <span class="cpp">index</span> будет большим или равным нулю, и нам нужно вывести подсказку, 
сформировав текст из номера точки (<span class="cpp">index</span>) и двух ее координат 
(<span class="cpp">A[index][0]</span> и <span class="cpp">A[index][1]</span>). Кроме того, нам нужно 
ограничить зону действия подсказки данной точкой, чтобы при выходе курсора за ее круг и попадании его в 
круг другой точки подсказка вывелась бы снова, уже с другими координатами. Этим мы и займемся.</p>

<p>Сначала зададим левый верхний угол зоны действия подсказки &ndash; он будет находиться левее и выше самой точки 
(<span class="cpp">ix</span>,<span class="cpp">iy</span>) на радиус ее круга <span class="cpp">point_r</span>. В поля 
<span class="cpp">HintData-&gt;HZLeft</span> и <span class="cpp">HintData-&gt;HZTop</span> мы записываем 
<span class="cpp">ix-point_r</span> и <span class="cpp">iy-point_r</span> соответственно. Ширина и высота 
зоны должны быть равны диаметру, то есть двум радиусам, круга, поэтому в поля 
<span class="cpp">HintData-&gt;HZWidth</span> и <span class="cpp">HintData-&gt;HZHeight</span> мы 
записываем значение <span class="cpp">point_r*2</span>. Теперь зона действия подсказки установлена. В нашей 
подсказке будет три числа, и, чтобы пользователь гарантированно успел ее прочесть, увеличим время ее 
показа до одной минуты: в поле <span class="cpp">HintData-&gt;HideTimeout</span> мы записываем 60000 
(шестьдесят тысяч миллисекунд &ndash; это одна минута).</p>

<p>Теперь нужно сформировать текст. Можно воспользоваться для этого стандартной функцией <span class="cpp">sprintf</span>, 
заранее отведя под формируемую строку буфер заведомо большего размера, но мы будем использовать функции RDS, 
работающие с динамическими строками. Сначала мы формируем динамические строки из целого номера точки при помощи 
функции <span class="cpp"><a href="rdsItoA.htm" title="А.5.4.11. rdsItoA &ndash; преобразование целого числа в строку">rdsItoA</a></span>. У этой функции три параметра: преобразуемое число, система счисления 
(мы передаем 10, то есть используем десятичную систему) и минимальное число разрядов в числе (нам не 
нужно дополнять число ведущими нулями до заданного количества разрядов, поэтому мы передаем ноль). Указатель на 
динамическую строку, который возвращает функция, мы записываем во вспомогательную переменную <span class="cpp">val_n</span>, 
потом эту строку обязательно нужно будет освободить вызовом <span class="cpp"><a href="rdsFree.htm" title="А.5.4.8. rdsFree &ndash; освобождение отведенной динамической памяти">rdsFree</a></span>. 
Координаты точки мы преобразуем в строки при помощи функции <span class="cpp"><a href="rdsDtoA.htm" title="А.5.4.5. rdsDtoA &ndash; преобразование вещественного числа в строку">rdsDtoA</a></span>, которая уже встречалась 
нам ранее. Динамические строки с символьным представлением этих координат записываются во вспомогательные 
переменные <span class="cpp">val_x</span> и <span class="cpp">val_y</span>, их тоже нужно будет освободить функцией 
<span class="cpp">rdsFree</span>. Далее начинается формирование самого текста подсказки: прежде всего мы 
объединяем строку &laquo;Точка:&raquo; и строку <span class="cpp">val_n</span> с номером точки в 
новую динамическую строку <span class="cpp">hint</span> при помощи функции 
<span class="cpp"><a href="rdsDynStrCat.htm" title="А.5.4.6. rdsDynStrCat &ndash; сложение двух строк">rdsDynStrCat</a></span> (мы уже использовали ее 
<a href="#ref5" title="Функция rdsDynStrCat">выше</a>). Затем мы по очереди добавляем в конец к этой динамической строке строки 
&laquo;
X:&raquo;, <span class="cpp">val_x</span>, &laquo;
Y:&raquo; и 
<span class="cpp">val_y</span> (символы &laquo;
&raquo;, как всегда в C, означают перевод строки 
&ndash; текст всплывающей подсказки может состоять из нескольких строк). Добавление осуществляется при 
помощи функции <span class="cpp"><a href="rdsAddToDynStr.htm" title="А.5.4.1. rdsAddToDynStr &ndash; добавление строки к динамически отведенной строке">rdsAddToDynStr</a></span>:</p>

<pre class="cpp">
  <a class="hidden" href="rdsAddToDynStr.htm" title="А.5.4.1. rdsAddToDynStr &ndash; добавление строки к динамически отведенной строке">rdsAddToDynStr</a>(&amp;hint, // Куда добавляем
                 "\nX: ",  // Что добавляем
                 FALSE);   // Заменять пустую строку на NULL?</pre>

<p>В первом параметре этой функции передается указатель на переменную, в которой хранится указатель на 
динамическую строку, к которой дописывается указанный текст. В данном случае мы передаем 
<span class="cpp">&amp;hint</span>, то есть, после последнего вызова <span class="cpp">rdsAddToDynStr</span>, 
в <span class="cpp">hint</span> будет находиться указатель на полностью сформированный текст подсказки. 
Этот текст мы передаем в RDS вызовом <span class="cpp"><a href="rdsSetHintText.htm" title="А.5.6.53. rdsSetHintText &ndash; текст всплывающей подсказки">rdsSetHintText</a></span>, после чего освобождаем более не 
нужные нам динамические строки <span class="cpp">hint</span>, <span class="cpp">val_n</span>, 
<span class="cpp">val_x</span> и <span class="cpp">val_y</span> при помощи 
<span class="cpp"><a href="rdsFree.htm" title="А.5.4.8. rdsFree &ndash; освобождение отведенной динамической памяти">rdsFree</a></span>.</p>

<p>Теперь в нашей модели есть все необходимые реакции, но нужно еще переключить сам блок на программное 
рисование и разрешить ему вывод всплывающих подсказок. Проще всего сделать это в окне параметров блока 
(см. <a href="um_3_7_5.htm#pic3" title="Включение программного рисования в окне параметров блока">рис.&nbsp;413</a> и 
<a href="#pic2" title="Разрешение всплывающей подсказки в окне параметров блока">рис.&nbsp;437</a>), но можно также вызвать 
<a href="um_3_6_8.htm" title="&sect;3.6.8. Установка параметров блоков с автокомпилируемой моделью">групповую установку параметров</a> блоков из редактора модели и 
включить рисование и подсказки там.</p>

<p>Для проверки работы созданного блока можно собрать схему, изображенную 
на <a href="#pic8" title="Тестирование блока с разными подсказками к разным точкам изображения">рис.&nbsp;443</a>. 
В ней к входу блока подключен выход стандартного блока ввода матрицы, в который введена матрица из восьми 
строк и двух столбцов. После запуска расчета при наведении курсора на одну из нарисованных точек в 
подсказке отображается номер соответствующей этой точке строки матрицы и координаты этой точки.</p>

<div class="pic"><div class="container" id="pic8">
<img src="../img/AC_hint_zones.png" width="613" height="283" alt="Тестирование блока с разными подсказками к разным точкам изображения" />
<p id="light_pic8">Рис.&nbsp;443. Тестирование блока с разными подсказками к разным точкам изображения</p>
</div></div>



</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_7_7a.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_7_9.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_7_8">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
