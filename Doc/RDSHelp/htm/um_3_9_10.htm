<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.9.10. Настройка обработки исключений и ошибок</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_9">&sect;3.9. Настройки стандартного модуля автокомпиляции</a></p>
<div class="level"><p>&sect;3.9.10. Настройка обработки исключений и ошибок</p>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_9_9.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="disbutton">&gt;&gt;</span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_9_10">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.9. Настройки стандартного модуля автокомпиляции</h3>
<h4>&sect;3.9.10. Настройка обработки исключений и ошибок</h4>
<p class="abstract">Описывается настройка процедур и способов обработки ошибок, возникающих при работе модели. Эти процедуры могут включаться в формируемый текст программы по желанию пользователя.</p>


<p>В настройках модуля автокомпиляции можно указать, какими операторами можно перехватывать возникшие
в модели исключения и как модель может перехватывать ошибки в математических функциях. Такой перехват ошибок
включается индивидуально в
<a href="um_3_6_7.htm" title="&sect;3.6.7. Параметры модели">настройках каждой модели</a>, но, чтобы его вообще можно было
включить, в настройках модуля должны быть заданы способы обработки исключений и ошибок. Чтобы настроить эти
способы, следует
<a href="um_3_9_1.htm#light_ref1" title="Вызов настроек модуля автокомпиляции">вызвать окно настройки</a> модуля  и на его вкладке
&laquo;<span class="menu">компилятор</span>&raquo; нажать кнопку &laquo;<span class="menu">дополнительно</span>&raquo;. В открывшемся дополнительном окне
настроек следует выбрать вкладку &laquo;<span class="menu">обработка исключений</span>&raquo;
(<a href="#pic1" title="Настройка обработки исключений и ошибок (на примере Borland C++ 5.5)">рис.&nbsp;501</a>).</p>

<div class="pic"><div class="container" id="pic1">
<img src="../img/AC_setup_aux_excep.png" width="571" height="473" alt="Настройка обработки исключений и ошибок (на примере Borland C++ 5.5)" />
<p id="light_pic1">Рис.&nbsp;501. Настройка обработки исключений и ошибок (на примере Borland C++ 5.5)</p>
</div></div>


<p><span id="ref1">В</span>
<span id="ref2">верхней</span> части вкладки настраивается перехват исключений.
Чтобы описать его, необходимо установить одноименный флажок
и ввести в поля ввода &laquo;<span class="menu">оператор try</span>&raquo; и &laquo;<span class="menu">универсальный catch</span>&raquo; операторы начала блока
обработки исключений (<span class="cpp" id="light_ref1">try</span>) и начала блока реакции на исключение
(<span class="cpp" id="light_ref2">catch</span>) соответственно. Желательно ввести операторы для перехвата любого исключения,
то есть самые универсальные из них.</p>

<p><span id="light_ref3">Исключения</span>
(<span id="light_ref4">exceptions</span>, исключительные ситуации) &ndash; это события,
возникающие при каких-либо
серьезных ошибках и прерывающие нормальный ход выполнения программы. Эти события часто создаются
различными библиотечными функциями, разработчики которых, по каким-то причинам, решили сообщать об
ошибках именно таким образом, а не возвратом какого-либо признака ошибки. Могут исключения возникать
и при математических операциях, например, при делении на ноль.</p>

<p>Обработка исключений обычно устроена следующим образом: часть программы, в которой могут возникнуть
исключения, помещают в блок обработки исключений, чаще всего описываемый оператором <span class="cpp">try</span>.
За ним размещают один или несколько блоков реакции на исключение, чаще всего описываемых оператором
<span class="cpp">catch</span>. При возникновении исключения внутри блока <span class="cpp">try</span> управление
немедленно передается ближайшему к нему блоку <span class="cpp">catch</span>, предназначенному для обработки
исключения соответствующего типа. Если такого блока не найдется в данной функции, управление будет передано
выше. Если же его не будет во всей программе, ее выполнение будет прервано. Для моделей блоков в
RDS это будет означать, что расчет остановится и RDS выдаст
<a href="um_3_6_7.htm#pic2" title="Стандартное сообщение RDS о критической ошибке в модели">стандартное сообщение об ошибке</a>. Более подробно
обработка исключений описывается в учебниках по языку C++.</p>

<p><span id="ref5">При</span>
<span id="ref6">включении</span>
<span id="ref7">флажка</span>
&laquo;<span class="menu">перехват исключений в модели</span>&raquo; модуль автокомпиляции добавляет в
текст формируемой программы описания трех констант:</p>

<pre class="cpp">  // Обработка исключений включена
  #define <span id="light_ref5">RDSBCPP_EXCEPTIONS</span>
  // Оператор try
  #define <span id="light_ref6">RDSBCPP_TRY</span> <span class="changes"><i>текст_первого_поля</i></span>
  // Оператор catch
  #define <span id="light_ref7">RDSBCPP_CATCHALL</span> <span class="changes"><i>текст_второго_поля</i></span></pre>

<p>Например, для настроек на <a href="#pic1" title="Настройка обработки исключений и ошибок (на примере Borland C++ 5.5)">рис.&nbsp;501</a> будут добавлены такие описания:</p>

<pre class="cpp">  // Обработка исключений включена
  #define RDSBCPP_EXCEPTIONS
  // Оператор try
  #define RDSBCPP_TRY __try
  // Оператор catch
  #define RDSBCPP_CATCHALL __except(EXCEPTION_EXECUTE_HANDLER)</pre>

<p>В операторах перехвата исключений (<span class="cpp">catch</span>) может указываться тип перехватываемого
исключения. В данной настройке следует вводить наиболее универсальный обработчик &ndash; например,
&laquo;<span class="cpp">catch(...)</span>&raquo;, или, как в примере, оператор
&laquo;<span class="cpp">__except(EXCEPTION_EXECUTE_HANDLER)</span>&raquo;. Компиляторы поддерживают различные операторы обработки
исключений, но введенный оператор перехвата должен соответствовать оператору начала блока обработки: для
&laquo;<span class="cpp">try</span>&raquo; нужно указывать &laquo;<span class="cpp">catch</span>&raquo;, для
&laquo;<span class="cpp">__try</span>&raquo; &ndash; &laquo;<span class="cpp">__except</span>&raquo;, и т.п. Способы обработки исключений и
использующиеся для этого операторы приводятся в описании конкретного компилятора.</p>

<p>Добавленные константы используются следующим образом: наличие определения константы
<span class="cpp">RDSBCPP_EXCEPTIONS</span> говорит о том, что в параметрах модуля автокомпиляции указаны
операторы обработки исключений (то есть флажок &laquo;<span class="menu">перехват исключений в модели</span>&raquo; установлен),
константа <span class="cpp">RDSBCPP_TRY</span> может быть использована как оператор начала блока исключений, а
константа <span class="cpp">RDSBCPP_CATCHALL</span> &ndash; как оператор начала блока перехвата. Использование
этих констант вместо конкретных операторов позволяет создавать модели, которые можно использовать с
любым компилятором, если параметры модуля, работающего с этим компилятором, настроены правильно.</p>

<p>Рассмотрим простой пример. Допустим, в модели блока есть вещественные переменные <span class="cpp">x1</span>,
<span class="cpp">x2</span> и <span class="cpp">y</span>, и в реакции на нажатие кнопки мыши мы хотим присвоить
<span class="cpp">y</span> результат деления <span class="cpp">x1</span> на <span class="cpp">x2</span>. Простейший
текст реакции будет выглядеть так:</p>

<pre class="cpp">  y=x1/x2;</pre>

<p>Однако, если <span class="cpp">x2</span> будет иметь нулевое значение, при делении возникнет исключение,
расчет будет остановлен, и пользователь увидит сообщение, подобное изображенному на
<a href="um_3_6_7.htm#pic2" title="Стандартное сообщение RDS о критической ошибке в модели">рис.&nbsp;354</a>. Можно перехватить это исключение следующим образом:</p>

<pre class="cpp">  RDSBCPP_TRY
    { y=x1/x2; }
  RDSBCPP_CATCHALL
    { <a class="hidden" href="rdsMessageBox.htm" title="А.5.5.6. rdsMessageBox &ndash; вывод окна сообщения">rdsMessageBox</a>("Деление на ноль","Ошибка",MB_OK|MB_ICONERROR);
      y=<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a>;
    }</pre>

<p>Здесь мы заключили деление в блок обработки исключений, причем вместо конкретного оператора
<span class="cpp">try</span> использовали константу <span class="cpp">RDSBCPP_TRY</span> &ndash; вместо
нее компилятором будет подставлен оператор, указанный в настройках модуля. В оператор перехвата, записанного
после константы <span class="cpp">RDSBCPP_CATCHALL</span>, мы включили вывод сообщения об ошибке и присвоение
переменной <span class="cpp">y</span>
<a href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">значения-маркера ошибки</a>. Расчет при этом остановлен не будет.</p>

<p>Приведенный пример, хотя и позволяет использовать для модели разные компиляторы, имеет один недостаток:
если в настройках модуля не указан способ обработки исключений (флажок
&laquo;<span class="menu">перехват исключений в модели</span>&raquo; не установлен), константы <span class="cpp">RDSBCPP_TRY</span> и
<span class="cpp">RDSBCPP_CATCHALL</span> будут определены таким образом, чтобы обработка исключений
игнорировалась и блок перехвата никогда не выполнялся. Для этого <span class="cpp">RDSBCPP_TRY</span> будет
иметь пустое значение, а <span class="cpp">RDSBCPP_CATCHALL</span> будет иметь значение
&laquo;<span class="cpp">if(0)</span>&raquo;, то есть будет заменяться на никогда не выполняющийся оператор
<span class="cpp">if</span>. Модель при этом будет работать так, как будто никакой обработки исключений нет,
однако, при компиляции &laquo;<span class="cpp">if(0)</span>&raquo; будет все время выдаваться предупреждение
&laquo;условие всегда ложно&raquo;. Отключать это предупреждение в параметрах компилятора опасно,
поскольку оно позволяет обнаружить потенциальные алгоритмические ошибки в программе. Лучше всего
переписать приведенный пример с использованием константы <span class="cpp">RDSBCPP_EXCEPTIONS</span>:</p>

<pre class="cpp">  RDSBCPP_TRY
    { y=x1/x2; }
  #ifdef RDSBCPP_EXCEPTIONS
    RDSBCPP_CATCHALL
      { <a class="hidden" href="rdsMessageBox.htm" title="А.5.5.6. rdsMessageBox &ndash; вывод окна сообщения">rdsMessageBox</a>("Деление на ноль","Ошибка",MB_OK|MB_ICONERROR);
        y=<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a>;
      }
  #endif</pre>

<p>Здесь весь блок перехвата исключений заключен внутрь конструкции
&laquo;<span class="cpp">#ifdef&nbsp;&hellip;&nbsp;#endif</span>&raquo;. Таким образом, если константа <span class="cpp">RDSBCPP_EXCEPTIONS</span>
будет определена, то есть если в настройках модуля описана обработка исключений, блок перехвата будет
скомпилирован и перехватит возникшее исключение при работе модели. Если же константа будет отсутствовать,
весь блок перехвата скомпилирован не будет и не выдаст никаких предупреждений.</p>

<p>Вторая часть вкладки &laquo;<span class="menu">обработка исключений</span>&raquo; служит для настройки перехвата ошибок
математики. Эти ошибки возникают только в функциях математической библиотеки и могут обрабатываться отдельно.
Их обработка позволяет не прерывать выполнение программы в случае ошибки, а подставлять вместо результата
операции, которая не может быть выполнена, какое-либо значение &ndash; например, маркер ошибки
<span class="cpp"><a href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a></span>. Следует помнить, что деление на ноль не может быть перехвачено
таким образом, оно всегда создает исключение, обработка которого рассматривается выше. Обработка ошибок
математики включается индивидуально в параметрах каждой модели флажком
&laquo;<span class="menu">перехватывать ошибки математических функций</span>&raquo;
(см. <a href="um_3_6_7.htm#pic1" title="Окно параметров модели &ndash; параметры исходного текста">рис.&nbsp;353</a>).</p>

<p>Флажок &laquo;<span class="menu">перехват ошибок математики</span>&raquo; разрешает модулю автокомпиляции добавлять в текст
формируемой программы функции для такого перехвата. В поле ввода &laquo;<span class="menu">регистрация функции</span>&raquo;
вводится оператор, который может потребоваться для инициализации перехвата математических ошибок &ndash;
он будет добавлен к процедуре инициализации глобальных переменных,
<a href="um_3_9_9.htm#ref8" title="Место инициализации глобальных переменных">место вставки</a>
которой указывается в настройках модуля на вкладке &laquo;<span class="menu">исходный текст</span>&raquo;. Следует отметить, что
ни один из поддерживаемых модулями компиляторов не требует никаких специальных действий для инициализации
обработки ошибок математики, поэтому это поле ввода в настройках модулей всегда пустое. Тем не менее,
оно может оказаться полезным для какого-либо нестандартного компилятора.</p>

<p>В многострочное поле &laquo;<span class="menu">тело функции</span>&raquo; вводится функция перехвата математических
ошибок в том виде, который требуется компилятору. Функция вводится полностью, вместе с заголовком и
телом. Имя этой функции и ее параметры приводятся в описании конкретного компилятора. Для Borland C++,
например, подходит такая функция:</p>

<pre class="cpp">  int _matherr(struct _exception *a)
  { a->retval=(a->type==UNDERFLOW)?0.0:<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a>;
    return 1;
  }</pre>

<p>Здесь анализируется возникшая ошибка и, в случае потери точности, результат математической операции считается
нулем, а для вех остальных ошибок результатом будет маркер ошибки <span class="cpp"><a href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a></span>.
Возврат функцией единицы указывает на то, что функция успешно обработала ошибку.</p>

<p>В поля ввода &laquo;<span class="menu">в начале функции блока</span>&raquo; и
&laquo;<span class="menu">в конце функции блока</span>&raquo; вводятся команды, позволяющие, если в настройках модели разрешен
перехват ошибок математики, временно блокировать специфические математические исключения (команды в поле
&laquo;<span class="menu">в начале функции блока</span>&raquo;) на время работы модели, а затем разрешать их снова (команды в поле
&laquo;<span class="menu">в конце функции блока</span>&raquo;). Функции для управления математическими исключениями и их параметры
описываются в руководстве по Windows API и в описаниях компиляторов. Команды, записанные в этих полях по
умолчанию, в начале функции модели блокируют все исключения, а в конце &ndash; восстанавливают их
прежнее состояние.</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_9_9.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="disbutton">&gt;&gt;</span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_9_10">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
