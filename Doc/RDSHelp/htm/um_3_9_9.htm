<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/cpp.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
  <script type="text/javascript" src="script.js"></script>
  <title>&sect;3.9.9. Параметры формирования исходного текста</title>
</head><body onload="DocLoad()">
<div class="pageheader"><span class="off"><b>Текущий раздел:</b></span>
<div class="int"><p id="top"><a href="../index.htm">Описания RDS</a></p>
<div class="level"><p><a href="um_index.htm">Описание пользователя</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3">Глава 3. Использование стандартных модулей автокомпиляции</a></p>
<div class="level"><p><a href="um_index.htm#light_htm:um_3_9">&sect;3.9. Настройки стандартного модуля автокомпиляции</a></p>
<div class="level"><p>&sect;3.9.9. Параметры формирования исходного текста</p>
</div>
</div>
</div>
</div>
</div></div>
<div class="topnav"><span class="off"><b>Навигация:</b></span>
<div class="left">
<span class="button"><a href="um_3_9_8.htm" title="Предыдущий параграф" id="pgup">&lt;&lt;</a></span>
<span class="button"><a href="um_3_9_10.htm" title="Следующий параграф" id="pgdn">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_9_9">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>

<div class="text">
<h1 class="off">Описание пользователя</h1>
<h2 class="off">Глава 3. Использование стандартных модулей автокомпиляции</h2>
<h3 class="off">&sect;3.9. Настройки стандартного модуля автокомпиляции</h3>
<h4>&sect;3.9.9. Параметры формирования исходного текста</h4>
<p class="abstract">Описываются различные настройки, управляющие формированием исходного текста программы по введенным пользователем фрагментам: как называется главная функция DLL, как выглядит заголовок экспортированной функции, какие описания RDS нужно автоматически включать в программу и т.п.</p>


<p>В настройках модуля автокомпиляции можно указать, как именно формируются те части исходного текста
программы модели, за которые не отвечает пользователь: главная функция DLL, экспортированная функция модели,
код инициализации глобальных переменных и т.п. Чтобы настроить эти параметры, следует
<a href="um_3_9_1.htm#light_ref1" title="Вызов настроек модуля автокомпиляции">вызвать окно настройки</a> модуля и на его вкладке
&laquo;<span class="menu">компилятор</span>&raquo; нажать кнопку &laquo;<span class="menu">дополнительно</span>&raquo;. В открывшемся дополнительном
окне настроек следует выбрать вкладку &laquo;<span class="menu">исходный текст</span>&raquo;
(<a href="#pic1" title="Настройка параметров исходного текста (на примере Borland C++ 5.5)">рис.&nbsp;500</a>).</p>

<div class="pic"><div class="container" id="pic1">
<img src="../img/AC_setup_aux_src.png" width="571" height="473" alt="Настройка параметров исходного текста (на примере Borland C++ 5.5)" />
<p id="light_pic1">Рис.&nbsp;500. Настройка параметров исходного текста (на примере Borland C++ 5.5)</p>
</div></div>


<p><span id="ref1">Первый</span>
<span id="ref2">флажок</span>
<span id="ref3">на</span>
<span id="ref4">вкладке</span>
<span id="ref5">отвечает</span>
<span id="ref6">за</span>
автоматическое включение в текст программы файлов, содержащих описания,
необходимые для взаимодействия модели блока с RDS. Включение флажка добавляет в текст непосредственно
после общих описаний следующий фрагмент:</p>

<pre class="cpp">  #include <<span id="light_ref1">RdsDef.h</span>>
  #define <span id="light_ref2">RDS_SERV_FUNC_BODY</span> <span id="light_ref3">rdsbcppGetService</span>
  #include <<span id="light_ref4">RdsFunc.h</span>>
  #include <<span id="light_ref5">CommonBl.h</span>>
  #include <<span id="light_ref6">CommonAC.hpp</span>></pre>

<p>Он содержит команды &laquo;<span class="cpp">#include</span>&raquo; для стандартных файлов заголовков, входящих в состав
RDS. Чтобы эти команды могли выполниться, путь к папке с этими файлами должен быть передан в параметрах
запуска компилятора (имена параметров для указания папок заголовков должны быть указаны в описании компилятора).
В <a href="um_3_9_6.htm" title="&sect;3.9.6. Запуск компилятора и редактора связей">настройках его запуска</a> для этого пути можно использовать
символическое обозначение &laquo;$RDSINCLUDE$&raquo; (см. <a href="um_3_9_4.htm" title="&sect;3.9.4. Символические имена параметров в настройках">&sect;3.9.4</a>).
Перед включением файла &laquo;<span class="file">RdsFunc.h</span>&raquo; расположена команда
&laquo;<span class="cpp">#define</span>&raquo;, вводящая макроопределение <span class="cpp">RDS_SERV_FUNC_BODY</span> &ndash;
его наличие приведет к автоматической вставке в текст программы функции для доступа к сервисным функциям DLL,
которая, в данном случае, будет называться <span class="cpp">rdsbcppGetService</span>
(подробнее об этом &ndash; в <a href="pm_2_2.htm" title="&sect;2.2. Главная функция DLL и файлы заголовков">&sect;2.2 руководства программиста</a>).</p>

<p>Если не устанавливать флажок &laquo;<span class="menu">включать стандартные заголовки RDS</span>&raquo;, приведенные выше описания
добавлены не будут, а без них модель скомпилировать невозможно. Все необходимые команды в этом случае следует
добавить вручную в
<a href="um_3_9_8.htm" title="&sect;3.9.8. Общие описания в программе">общие описания модуля</a>. Это менее удобно, поэтому отключать
автоматическое добавление описаний RDS следует только в том случае, если в них необходимо что-либо
изменить &ndash; например, ввести какие-либо настроечные макроопределения
(см. <a href="app_a_5_1.htm" title="А.5.1. Доступ к сервисным функциям RDS">А.5.1 приложений</a>).</p>

<p>Ниже флажка &laquo;<span class="menu">включать стандартные заголовки RDS</span>&raquo; расположен зависящий от него флажок
&laquo;<span class="menu">#define для RDSCALL</span>&raquo; &ndash; если не включен первый, второй будет заблокирован. Справа от него
можно ввести значение для используемой в RDS константы <span class="cpp"><a href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a></span>,
обозначающей тип вызова всех сервисных функций.
Если не включать в текст программы определение для <span class="cpp">RDSCALL</span>, она будет
автоматически правильно определена при включении файла &laquo;<span class="file">RdsDef.h</span>&raquo; как
<span class="cpp">CALLBACK</span> &ndash; это именно тот тип, который нужен, поэтому устанавливать флажок
&laquo;<span class="menu">#define для RDSCALL</span>&raquo; в большинстве случаев не нужно. Он оставлен в настройках для
совместимости со старыми версиями файла &laquo;<span class="file">RdsDef.h</span>&raquo;, в которых автоматическое
определение для <span class="cpp">RDSCALL</span> отсутствовало. Если включить его, в поле ввода справа
необходимо ввести либо &laquo;CALLBACK&raquo;, либо другой тип вызова, поддерживаемый компилятором,
при котором аргументы функции передаются в стеке справа налево и стек освобождается вызванной функцией.
Например, для Borland С++ можно использовать тип <span class="cpp">__stdcall</span> (с двумя знаками подчеркивания
в начале слова). При этом непосредственно перед командой &laquo;<span class="cpp">#include</span>&raquo; для
&laquo;<span class="file">RdsDef.h</span>&raquo; будет вставлено описание:</p>

<pre class="cpp">  #define RDSCALL <i><span class="changes">введенный_в_поле_текст</span></i> </pre>

<p><span id="ref7">Ниже</span>
располагается флажок &laquo;<span class="menu">создать главную функцию DLL</span>&raquo;, при установке которого
<span id="light_ref7">главная функция DLL</span> будет добавлена в текст автоматически.
Главная функция (точка входа) &ndash; это функция, которая вызывается при загрузке библиотеки в
память и ее выгрузке (подробнее об этом &ndash; в <a href="DllEntryPoint.htm" title="А.2.2. Главная функция DLL">А.2.2 приложений</a>).
Каждая DLL должна иметь главную функцию, поэтому, если не включать этот флажок, эту функцию нужно вручную добавить
в <a href="um_3_9_8.htm" title="&sect;3.9.8. Общие описания в программе">общие описания модуля</a>. Заголовок формируемой функции вводится
полностью в одну строчку в поле &laquo;<span class="menu">главная функция DLL</span>&raquo;, расположенное непосредственно под флажком.
В этот заголовок должно входить полное описание функции &ndash; тип, имя и список параметров, причем второй
параметр в списке обязательно должен называться &laquo;<span class="cpp">reason</span>&raquo; &ndash; внутри автоматически
формируемой функции используется его значение. После этой строки заголовка модуль автокомпиляции вставляет
открывающую фигурную скобку и начинает тело функции, поэтому точку с запятой в конце заголовка добавлять не
следует. Имя главной функции DLL обычно указывается в описании используемого компилятора. Например, для
Borland С++ следует использовать такой заголовок:</p>

<pre class="cpp">  int WINAPI <a class="hidden" href="DllEntryPoint.htm" title="А.2.2. Главная функция DLL">DllEntryPoint</a>(<a class="hidden" href="app_ids.htm#light_ref17" title="Дескриптор модуля">HINSTANCE</a> hinst,unsigned long reason,void *lpReserved)</pre>

<p class="noindent">При этом автоматически сформированная главная функция DLL будет иметь примерно следующий вид:</p>

<pre class="cpp">  #pragma argsused
  int WINAPI <a class="hidden" href="DllEntryPoint.htm" title="А.2.2. Главная функция DLL">DllEntryPoint</a>(<a class="hidden" href="app_ids.htm#light_ref17" title="Дескриптор модуля">HINSTANCE</a> hinst,unsigned long reason,void *lpReserved)
  { if(reason==DLL_PROCESS_ATTACH)
      { if(!RDS_SERV_FUNC_BODY())
          { MessageBox(NULL,
              "Невозможно получить доступ к сервисным "
              "функциям RDS",RDSBCPP_MODELNAME,
              MB_OK | MB_ICONERROR);
            return 0;
          }
        else // Есть доступ к сервисным функциям
          { <a class="hidden" href="rdsGetHugeDouble.htm" title="А.5.2.22. rdsGetHugeDouble &ndash; получение значения-индикатора математической ошибки">rdsGetHugeDouble</a>(&<a class="hidden" href="um_3_7_1.htm#ref15" title="Переменная rdsbcppHugeDouble">rdsbcppHugeDouble</a>);
            // Регистрация функций блока
            rdsfuncControlValueChanged.Register(
                      "Common.ControlValueChanged");
          }
      }
    return 1;
  }</pre>

<p>Конкретное наполнение тела главной функции DLL зависит от настроек модуля автокомпиляции и от наличия
функций блока в создаваемой модели (см. <a href="um_3_6_5.htm" title="&sect;3.6.5. Функции блока">&sect;3.6.5</a>).</p>

<p><span id="ref8">Далее</span>
располагается выпадающий список &laquo;<span class="menu">инициализация глобальных</span>&raquo;, который указывает модулю, в какое именно
место формируемого текста программы следует добавить
<span id="light_ref8">команды присвоения начальных значений глобальным переменным</span>, необходимым для
работы модели. К этим переменным относятся переменные-указатели на сервисные функции RDS, глобальные объекты
функций блоков и т.п. Возможен выбор одного из трех вариантов:</p>

<ul>
  <li>&laquo;в главной функции DLL&raquo; &ndash; команды присвоения начальных значений будут добавлены внутрь
  автоматически формируемой главной функции DLL, как в примере выше (инициализация при этом производится в
  момент загрузки DLL в память);</li>
  <li>&laquo;при первом вызове функции блока&raquo; &ndash; команды будут добавлены в автоматически
  формируемую функцию модели блока, изнутри которой вызываются все пользовательские реакции (инициализация
  при этом производится в момент первого обращения к модели блока);</li>
  <li>&laquo;не инициализировать&raquo; &ndash; глобальные переменные автоматически не инициализируются,
  все необходимые команды нужно добавлять вручную &ndash; например, в реакцию на
  <a href="ac_RDS_BFM_INIT.htm" title="&sect;3.8.2.1. Инициализация блока">инициализацию блока</a>.</li>
</ul>

<p class="noindent">Выполнять инициализацию глобальных переменных по возможности рекомендуется в главной
функции DLL. Если при настройке модуля на работу с компилятором возникли проблемы, связанные с главной
функцией (например, пришлось добавлять ее вручную в общие описания модуля), инициализацию следует проводить при
первом вызове функции модели блока. Выбирать в выпадающем списке вариант &laquo;не инициализировать&raquo;
рекомендуется только в самом крайнем случае, когда компилятор по каким-либо причинам выдает ошибки в
автоматически добавленных командах инициализации.</p>

<p>Следует учитывать, что, хотя регистрация функций блока тоже относится к инициализации глобальных переменных,
она будет выполнена даже в том случае, если в выпадающем списке выбран вариант
&laquo;не инициализировать&raquo;. В этом случае регистрация функций будет выполнена в конструкторе
класса блока.</p>

<p>Под выпадающим списком выбора места инициализации глобальных переменных находятся поля ввода
&laquo;<span class="menu">объявление функции блока</span>&raquo; и &laquo;<span class="menu">экспортированное имя</span>&raquo;. С их помощью задается тип
и имя автоматически формируемой функции модели блока, то есть общей функции, отвечающей за всю работу блока,
и имя, под которым эта функция видна &laquo;снаружи&raquo; библиотеки при ее подключении.</p>

<p><span id="ref9">В</span>
поле &laquo;<span class="menu">объявление функции блока</span>&raquo; вводится тип и имя функции модели блока <span class="emph">без
списка параметров</span> &ndash; этот список будет добавлен автоматически. Вместо имени функции следует
использовать символическое обозначение &laquo;$FUNC$&raquo;
(см. <a href="um_3_9_4.htm" title="&sect;3.9.4. Символические имена параметров в настройках">&sect;3.9.4</a>), которое при формировании текста будет автоматически заменено
на жестко встроенное в модуль автокомпиляции имя
&laquo;<span class="cpp"><span id="light_ref9">rdsbcppBlockEntryPoint</span></span>&raquo;. Перед этим именем должны
находиться все описания, необходимые для того, чтобы эта функция была экспортирована из библиотеки, то есть
чтобы указатель на нее можно было бы получить функцией Windows API <span class="cpp">GetProcAddress</span>.
Кроме того, эта функция должна иметь тип вызова <span class="cpp"><a href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a></span>.</p>

<p>На <a href="#pic1" title="Настройка параметров исходного текста (на примере Borland C++ 5.5)">рис.&nbsp;500</a> приведен пример описания, подходящего для
Borland С++. На рисунке видно только начало этого описания (весь текст на рисунке не уместился), но,
на самом деле, в поле ввода введен следующий текст:</p>

<pre class="cpp">  extern "C" __declspec(dllexport) int <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> $FUNC$</pre>

<p>Когда модуль автокомпиляции будет формировать функцию модели блока по этому описанию, она будет выглядеть
следующим образом (фрагмент, сформированный по тексту из поля ввода,
выделен <span class="changes">цветом</span>):</p>

<pre class="cpp">  #pragma argsused
  <span class="changes">extern "C" __declspec(dllexport) int <a class="hidden" href="app_ids.htm#light_ref24" title="Тип вызова сервисных функций">RDSCALL</a> rdsbcppBlockEntryPoint</span>(
      int CallMode,              // Режим вызова
      <a class="hidden" href="RDS_BLOCKDATA.htm#ref2" title="Указатель на RDS_BLOCKDATA">RDS_PBLOCKDATA</a> BlockData,  // Данные блока
      <a class="hidden" href="app_ids.htm#light_ref21" title="Указатель на любые данные (void*)">LPVOID</a> ExtParam)           // Дополнительные данные
  {
    &hellip;
  }</pre>

<p>Во введенном в поле тексте &laquo;$FUNC$&raquo; заменено на &laquo;<span class="cpp">rdsbcppBlockEntryPoint</span>&raquo;
и получившийся текст добавлен перед открывающей скобкой списка параметров функции, который, как и ее тело,
формируется модулем автоматически согласно требованиям RDS.</p>

<p><span id="ref10">В</span>
поле &laquo;<span class="menu">экспортированное имя</span>&raquo; вводится экспортированное имя функции модели,
которое может не совпадать с именем функции в программе (изменение имен экспортированных функций называется
&laquo;<span id="light_ref10">name mangling</span>&raquo; и указывается в описании каждого
компилятора). Именно экспортированное имя будет аргументом вызова <span class="cpp">GetProcAddress</span>,
при помощи которого RDS подключает функцию модели к блоку. В поле ввода этого имени можно использовать
символические обозначения &laquo;$FUNC$&raquo;, &laquo;$FUNCLC$&raquo; и
&laquo;$FUNCUC$&raquo; (см. <a href="um_3_9_4.htm" title="&sect;3.9.4. Символические имена параметров в настройках">&sect;3.9.4</a>).
<span id="ref11">На</span>
<a href="#pic1" title="Настройка параметров исходного текста (на примере Borland C++ 5.5)">рис.&nbsp;500</a> в примере для Borland С++ экспортированное имя
совпадает с именем самой функции, поэтому в поле введено обозначение
&laquo;$FUNC$&raquo;. Но, например, компилятор <span id="light_ref11">Digital Mars C++</span>
по умолчанию добавляет к экспортированному имени дополнительные символы. Функция блока с именем
&laquo;<span class="cpp">rdsbcppBlockEntryPoint</span>&raquo; и требуемым списком параметров получает в этом компиляторе имя
&laquo;_rdsbcppBlockEntryPoint@12&raquo; &ndash; это можно определить опытным путем, скомпилировав модель блока
с таким именем вручную и посмотрев список экспортированных функций получившегося файла DLL (как правило, в
состав компилятора входят специализированные программы для такого просмотра). Таким образом, при настройке
модуля на работу с Digital Mars C++ в поле &laquo;<span class="menu">экспортированное имя</span>&raquo; нужно вводить текст
&laquo;_$FUNC$@12&raquo;.</p>

<p>В нижней части вкладки размещаются флажки, управляющие дополнительными описаниями и разрешающие
использование некоторых директив препроцессора.</p>

<p>Флажок &laquo;<span class="menu">добавить описания для констант M_PI и M_E</span>&raquo; вставляет в формируемый текст
программы следующие команды:</p>

<pre class="cpp">  #ifndef M_PI
    #define M_PI 3.14159265358979323846
  #endif
  #ifndef M_E
    #define M_E 2.71828182845904523536
  #endif</pre>

<p>При этом в программе для числа
&pi; можно использовать константу <span class="cpp">M_PI</span>, а для основания натурального логарифма
&ndash; константу <span class="cpp">M_E</span>. Эти имена констант общеприняты, и многие компиляторы уже
содержат их описания в своих стандартных файлах заголовков, поэтому, в большинстве случаев, этот флажок
можно не устанавливать.</p>

<p>Флажок &laquo;<span class="menu">использовать директиву #line</span>&raquo; разрешает модулю автокомпиляции вставлять в формируемый текст
директиву &laquo;<span class="cpp">#line</span>&raquo;, изменяющую номера строк в сообщениях об ошибках. При использовании
этой директивы снижается вероятность того, что модуль неправильно соотнесет номер строки в общем
сформированном файле с номером строки в одном из фрагментов текста, введенных пользователем, что приведет к
тому, что при двойном щелчке на сообщении об ошибке в редакторе модели курсор будет установлен не в ту строку,
где эта ошибка возникла. Если компилятор поддерживает директиву &laquo;<span class="cpp">#line</span>&raquo;,
этот флажок лучше установить.</p>

<p><span id="ref12">Флажок</span>
&laquo;<span class="menu">использовать директиву <span id="light_ref12">#pragma argsused</span></span>&raquo;
разрешает модулю вставлять указанную директиву перед каждой автоматически сформированной функцией с
параметрами. Эта директива отключает для следующей за ней функции предупреждение компилятора о том,
что параметры функции не используются в ее теле. Это предупреждение, хотя и может быть полезно для
пользовательских функций (с его помощью можно обнаружить и исключить ненужные параметры), бессмысленно для
автоматически формируемых функций реакции на события: модуль всегда передает в них все возможные параметры,
а уже пользователь решает, нужны ли они ему. Например, функция, формируемая для реакции на
<a href="ac_RDS_BFM_MOUSEDOWN.htm" title="&sect;3.8.4.1. Нажатие кнопки мыши">нажатие кнопки мыши</a>
(см. <a href="um_3_7_10.htm" title="&sect;3.7.11. Реакция блока на мышь">&sect;3.7.11</a>), всегда получает в качестве параметра указатель на
структуру, содержащую координаты курсора, нажатую кнопку и т.п. Пользователь пишет только тело этой функции,
и, для самых простых реакций, ему не нужна вся эта информация &ndash; достаточно самого факта нажатия кнопки.
Но компилятор, обнаружив, что указатель на структуру описания события в теле функции нигде не использован,
выдаст предупреждение, которое увидит пользователь, и оно может сбить его с толку. По этой причине,
если компилятор поддерживает директиву &laquo;<span class="cpp">#pragma argsused</span>&raquo;, рекомендуется включать этот
флажок. Если директива не поддерживается, рекомендуется запретить вывод предупреждения о неиспользованных
параметрах функций в настройках запуска компилятора (как правило, в командной строке компиляторов предусмотрены
параметры, позволяющие включать и выключать вывод отдельных предупреждений). В настройках некоторых стандартных
модулей автокомпиляции это предупреждение по умолчанию выключено, хотя компиляторы, для которых предназначены
модули, и поддерживают &laquo;<span class="cpp">#pragma argsused</span>&raquo;.</p>

<p>В правой нижней части вкладки находится кнопка &laquo;<span class="menu">восстановить исходные</span>&raquo;, заполняющая все поля
ввода значениями, предлагаемыми разработчиками модуля (для поддерживаемых компиляторов это будут значения,
совместимые с ними).</p>

</div>
<p style="clear:both; min-height:1em; padding:0px; margin: 0px;"></p><hr class="off" /><div class="bottomnav">
<div class="left">
<span class="button"><a href="um_3_9_8.htm" title="Предыдущий параграф" id="pgup_f">&lt;&lt;</a></span>
<span class="button"><a href="um_3_9_10.htm" title="Следующий параграф" id="pgdn_f">&gt;&gt;</a></span>
<span class="divider"></span>
<span class="button"><a href="um_index.htm#light_htm:um_3_9_9">Оглавление</a></span>
<span class="button"><a href="alpha.htm">Указатель</a></span>
</div>
</div>
</body>
</html>
